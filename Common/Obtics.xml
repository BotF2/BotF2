<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Obtics</name>
    </assembly>
    <members>
        <member name="T:Obtics.Values.DynamicValueProvider`1">
            <summary>
            ValueProvider object holding a value that can be dynamically updated.
            </summary>
            <typeparam name="TType">Type of the Value property</typeparam>
            <remarks>This is a STATEFULL object in the sense that it doesn't just represent a statically defined view on some source data.
            It maintains a reference to the data. </remarks>
        </member>
        <member name="T:Obtics.Values.IValueProvider`1">
            <summary>
            value provider interface for a specific type
            </summary>
            <typeparam name="TType">Type for the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property</typeparam>
        </member>
        <member name="T:Obtics.Values.IValueProvider">
            <summary>
            untyped value provider interface
            </summary>
            <remarks>
            An IValueProvider implementation typically also implements <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>, but this is not required.
            </remarks>
        </member>
        <member name="P:Obtics.Values.IValueProvider.Value">
            <summary>
            the value
            </summary>
        </member>
        <member name="P:Obtics.Values.IValueProvider.IsReadOnly">
            <summary>
            is it read-write or read only
            </summary>
        </member>
        <member name="P:Obtics.Values.IValueProvider`1.Value">
            <summary>
            The typed value. The Typed Value property should always return the same value as the untyped Value property.
            </summary>
        </member>
        <member name="T:Obtics.INotifyChanged">
            <summary>
            Basic interface for change notification supplier
            </summary>
        </member>
        <member name="M:Obtics.INotifyChanged.SubscribeINC(Obtics.IReceiveChangeNotification)">
            <summary>
            Register for change notifications
            </summary>
            <param name="consumer">The consumer that is to receive change notifications</param>
            <remarks>
            A specific consumer can register only once. Calling SubscribeINC repeatedly with the
            same <paramref name="consumer"/> will lead to the consumer being registered only once.
            </remarks>
        </member>
        <member name="M:Obtics.INotifyChanged.UnsubscribeINC(Obtics.IReceiveChangeNotification)">
            <summary>
            Unregisters for change notifications
            </summary>
            <param name="consumer">The consumer to unregister.</param>
            <remarks>
            A consumer can have only one registration at a specific supplier. UnsubscribeINC will remove
            this one registration. Repeated calls to UnsubscribeINC without reregistering first will have
            no effect.
            </remarks>
        </member>
        <member name="F:Obtics.Values.DynamicValueProvider`1.ValuePropertyName">
            <summary>
            Propertyname of the Value property
            </summary>
        </member>
        <member name="F:Obtics.Values.DynamicValueProvider`1.IsReadOnlyPropertyName">
            <summary>
            Propertyname of the IsReadOnly property
            </summary>
        </member>
        <member name="M:Obtics.Values.DynamicValueProvider`1.#ctor(`0)">
            <summary>
            Constructor, taking the initial value for Value as argument
            </summary>
            <param name="value">The value to initalize the Value property with.</param>
        </member>
        <member name="P:Obtics.Values.DynamicValueProvider`1.Value">
            <summary>
            Value property.
            </summary>
        </member>
        <member name="P:Obtics.Values.DynamicValueProvider`1.IsReadOnly">
            <summary>
            IsReadOnly property, indicating if the Value property is readonly. In the case of the 
            DynamicValueProvider class IsReadOnly always returns false.
            </summary>
        </member>
        <member name="E:Obtics.Values.DynamicValueProvider`1.PropertyChanged">
            <summary>
            PropertyChanged event. Raised whenever a public property may have changed its value.
            </summary>
        </member>
        <member name="T:Obtics.Values.ValueProvider">
            <summary>
            Provides a set of static methods for querying objects that implement <see cref="T:Obtics.Values.IValueProvider`1"/>.
            </summary>
            <remarks>
            <para>
            The majority of the methods in this class are defined as extension methods that extend <see cref="T:Obtics.Values.IValueProvider`1"/>. This means they can be called like an instance method on any object that implements <see cref="T:Obtics.Values.IValueProvider`1"/>.
            </para><para>
            Methods that are used in a query that returns a value provider do not consume the target data until the query objects Value property getter is accessed. This is known as deferred execution.
            </para>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.DependencyProperties``1(Obtics.Values.IValueProvider{``0})">
            <summary>
            Creates a 'property getter struct' that can retrieve individual live properties on the source DependencyObject.
            </summary>
            <typeparam name="TSource">Type of the Value property of IValueProvider <paramref name="source"/>. Type of the object the property value is gotten from. This must be <see cref="T:System.Windows.DependencyObject"/> or a derived type.</typeparam>
            <param name="source">The <see cref="T:Obtics.Values.IValueProvider`1"/> who's Value provides the DependencyObject we are taking the property from.</param>
            <returns>A <see cref="T:Obtics.Values.ValueProvider.PropertyGetter`1"/> of <typeparamref name="TSource"/> that can retrieve individual properties.</returns>
            <remarks>
            Other than the standard 'Property' methods, this construct allows the retrieval of properties without
            having to explicitly specify the type of the source object.
            <code> ccProvider.Property&lt;ContentControl,object&gt;( "Content" ) </code>
            can be written as:
            <code> ccProvider.Properties().Get&lt;object&gt;( "Content" ) </code>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.DependencyProperties``1(``0)">
            <summary>
            Creates a 'property getter struct' that can retrieve individual live properties on the source DependencyObject.
            </summary>
            <typeparam name="TSource">Type of the Value property of IValueProvider <paramref name="source"/>. Type of the object the property value is gotten from. This must be <see cref="T:System.Windows.DependencyObject"/> or a derived type.</typeparam>
            <param name="source">The <typeparamref name="TSource"/> object we are taking the property from.</param>
            <returns>A <see cref="T:Obtics.Values.ValueProvider.PropertyGetter`1"/> of <typeparamref name="TSource"/> that can retrieve individual properties.</returns>
            <remarks>
            Other than the standard 'Property' methods, this construct allows the retrieval of properties without
            having to explicitly specify the type of the source object.
            <code> ValueProvider.Property&lt;ContentControl,object&gt;( contentControl, "Content" ) </code>
            can be written as:
            <code> ValueProvider.Properties(contentControl).Get&lt;object&gt;( "Content" ) </code>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Properties``1(Obtics.Values.IValueProvider{``0})">
            <summary>
            Creates a 'property getter struct' that can retrieve individual live properties on the source object.
            </summary>
            <typeparam name="TSource">Type of the Value property of IValueProvider <paramref name="source"/>. Type of the object the property value is gotten from. This must be a reference type.</typeparam>
            <param name="source">The <see cref="T:Obtics.Values.IValueProvider`1"/> who's Value provides the object we are taking the property from.</param>
            <returns>A <see cref="T:Obtics.Values.ValueProvider.PropertyGetter`1"/> of <typeparamref name="TSource"/> that can retrieve individual properties.</returns>
            <remarks>
            Other than the standard 'Property' methods, this construct allows the retrieval of properties without
            having to explicitly specify the type of the source object.
            <code> dictProvider.Property&lt;Dictionary&lt;string,int&gt;,int&gt;( "Count" ) </code>
            can be written as:
            <code> dictProvider.Properties().Get&lt;int&gt;( "Count" ) </code>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Properties``1(``0)">
            <summary>
            Creates a 'property getter struct' that can retrieve individual live properties on the source object.
            </summary>
            <typeparam name="TSource">Type of <paramref name="source"/> where the property value is gotten from. This must be a reference type.</typeparam>
            <param name="source">The <typeparamref name="TSource"/> object we are taking the property from.</param>
            <returns>A <see cref="T:Obtics.Values.ValueProvider.PropertyGetter`1"/> of <typeparamref name="TSource"/> that can retrieve individual properties.</returns>
            <remarks>
            Other than the standard 'Property' methods, this construct allows the retrieval of properties without
            having to explicitly specify the type of the source object.
            <code> ValueProvider.Property&lt;Dictionary&lt;string,int&gt;,int&gt;( dict, "Count" ) </code>
            can be written as:
            <code> ValueProvider.Properties(dict).Get&lt;int&gt;( "Count" ) </code>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Property``2(Obtics.Values.IValueProvider{``0},System.Windows.DependencyProperty)">
            <summary>
            Gets the value of the dependency property indicated by <paramref name="dependencyProperty"/> from the dependency object provided by <paramref name="source"/>
            </summary>
            <typeparam name="TSource">Type of the Value property of IValueProvider <paramref name="source"/>. Type of the dependency object the property value is gotten from. This must be <see cref="T:System.Windows.DependencyObject"/> or a derived type.</typeparam>
            <typeparam name="TProperty">Type of the property indicated by <paramref name="dependencyProperty"/></typeparam>
            <param name="source">The <see cref="T:Obtics.Values.IValueProvider`1"/> who's Value provides the dependency object we are taking the property from.</param>
            <param name="dependencyProperty">The <see cref="T:System.Windows.DependencyProperty"/> object indicating the property we are getting the value from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> who's Value will hold the property value.</returns>
            <remarks>
            The pipeline generated here will register for property change notifications from the active Value of <paramref name="source"/>. 
            This means the Value of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be updated when either the Value of <paramref name="source"/> changes
            or the property indicated by <paramref name="dependencyProperty"/> on the current <paramref name="source"/> Value changes.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Property``2(Obtics.Values.IValueProvider{``0},System.Reflection.PropertyInfo)">
            <summary>
            Gets the value of the property indicated by <paramref name="propInfo"/> from the object provided by <paramref name="source"/>
            </summary>
            <typeparam name="TSource">Type of the Value property of IValueProvider <paramref name="source"/>. Type of the object the property value is gotten from. This must be a reference type.</typeparam>
            <typeparam name="TProperty">Type of the property indicated by <paramref name="propInfo"/></typeparam>
            <param name="source">The <see cref="T:Obtics.Values.IValueProvider`1"/> who's Value provides the object we are taking the property from.</param>
            <param name="propInfo">The <see cref="T:System.Reflection.PropertyInfo"/> object indicating the property we are getting the value from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> who's Value will hold the property value. 
            If either <paramref name="source"/> or <paramref name="propInfo"/> equals null then null is returned.</returns>
            <remarks>
            The pipeline generated here will register for property change notifications from the active Value of <paramref name="source"/>. 
            It does this by using the <see cref="T:System.ComponentModel.PropertyDescriptor"/> for the property. Provided that
            the object returned by the Value of <paramref name="source"/> sends change notifications for the property
            this means that the Value of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be updated when either the Value of <paramref name="source"/> changes
            or the property indicated by <paramref name="propInfo"/> on the current <paramref name="source"/> Value changes.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Property``2(Obtics.Values.IValueProvider{``0},System.String)">
            <summary>
            Gets the value of the property indicated by <paramref name="propName"/> from the object provided by <paramref name="source"/>
            </summary>
            <typeparam name="TSource">Type of the Value property of IValueProvider <paramref name="source"/>. Type of the object the property value is gotten from. This must be a reference type.</typeparam>
            <typeparam name="TProperty">Type of the property indicated by <paramref name="propName"/></typeparam>
            <param name="source">The <see cref="T:Obtics.Values.IValueProvider`1"/> who's Value provides the object we are taking the property from.</param>
            <param name="propName">The <see cref="T:System.String"/> indicating the property we are getting the value from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> who's Value will hold the property value. 
            If either <paramref name="source"/> or <paramref name="propName"/> equals null then null is returned.</returns>
            <remarks>
            The pipeline generated here will register for property change notifications from the active Value of <paramref name="source"/>. 
            It does this by using the <see cref="T:System.ComponentModel.PropertyDescriptor"/> for the property. Provided that
            the object returned by the Value of <paramref name="source"/> sends change notifications for the property
            this means that  the Value of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be updated when either the Value of <paramref name="source"/> changes
            or the property indicated by <paramref name="propName"/> on the current <paramref name="source"/> Value changes.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Property``2(``0,System.Windows.DependencyProperty)">
            <summary>
            Gets the value of the dependency property indicated by <paramref name="dependencyProperty"/> from the dependency object <paramref name="source"/>
            </summary>
            <typeparam name="TSource">Type of <paramref name="source"/>. Type of the dependency object the property value is gotten from. This must be <see cref="T:System.Windows.DependencyObject"/> or a derived type.</typeparam>
            <typeparam name="TProperty">Type of the property indicated by <paramref name="dependencyProperty"/></typeparam>
            <param name="source">The <typeparamref name="TSource"/> object we are getting the property from.</param>
            <param name="dependencyProperty">The <see cref="T:System.Windows.DependencyProperty"/> object indicating the property we are getting the value from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> who's Value will hold the property value.</returns>
            <remarks>
            The pipeline generated here will register for property change notifications from <paramref name="source"/>. 
            This means the Value of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be updated when the property indicated 
            by <paramref name="dependencyProperty"/> changes value.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Property``2(``0,System.Reflection.PropertyInfo)">
            <summary>
            Gets the value of the property indicated by <paramref name="propInfo"/> from <paramref name="source"/>
            </summary>
            <typeparam name="TSource">Type of <paramref name="source"/> where the property value is gotten from. This must be a reference type.</typeparam>
            <typeparam name="TProperty">Type of the property indicated by <paramref name="propInfo"/></typeparam>
            <param name="source">The <typeparamref name="TSource"/> object we are taking the property from.</param>
            <param name="propInfo">The <see cref="T:System.Reflection.PropertyInfo"/> object indicating the property on <paramref name="source"/> we are getting the value from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> who's Value will hold the property value. 
            If either <paramref name="source"/> or <paramref name="propInfo"/> equals null then null is returned instead.</returns>
            <remarks>
            The pipeline generated here will register for property change notifications from <paramref name="source"/>. 
            It does this by using the <see cref="T:System.ComponentModel.PropertyDescriptor"/> for the property. Provided that
            <paramref name="source"/> sends change notifications for the property
            this means that the Value of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be updated when 
            the property indicated by <paramref name="propInfo"/> on <paramref name="source"/> changes.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Property``2(``0,System.String)">
            <summary>
            Gets the value of the property indicated by <paramref name="propName"/> from <paramref name="source"/>
            </summary>
            <typeparam name="TSource">Type of <paramref name="source"/> where the property value is gotten from. This must be a reference type.</typeparam>
            <typeparam name="TProperty">Type of the property indicated by <paramref name="propName"/></typeparam>
            <param name="source">The <typeparamref name="TSource"/> object we are taking the property from.</param>
            <param name="propName">The <see cref="T:System.String"/> indicating the property on <paramref name="source"/> we are getting the value from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> who's Value will hold the property value. 
            If either <paramref name="source"/> or <paramref name="propName"/> equals null then null is returned instead.</returns>
            <remarks>
            The pipeline generated here will register for property change notifications from <paramref name="source"/>. 
            It does this by using the <see cref="T:System.ComponentModel.PropertyDescriptor"/> for the property. Provided that
            <paramref name="source"/> sends change notifications for the property
            this means that the Value of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be updated when 
            the property indicated by <paramref name="propName"/> on <paramref name="source"/> changes.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Async``1(Obtics.Values.IValueProvider{``0},Obtics.Async.IWorkQueue)">
            <summary>
            Buffers the value of the source <see cref="T:Obtics.Values.IValueProvider`1"/> and propagates changes asynchronously using a specified work queue.
            </summary>
            <typeparam name="TType">The type of the elements of the input and result value providers.</typeparam>
            <param name="source">The value provider to buffer.</param>
            <param name="workQueue">The <see cref="T:Obtics.Async.IWorkQueue"/> to use.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, that with respect to some asynchronous delay has the same value as <paramref name="source"/>, or null when either <paramref name="source"/> or <paramref name="workQueue"/> is null.</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Async``1(Obtics.Values.IValueProvider{``0})">
            <summary>
            Buffers the value of the source <see cref="T:Obtics.Values.IValueProvider`1"/> and propagates changes asynchronously using the default work queue.
            </summary>
            <typeparam name="TType">The type of the elements of the input and result sequences.</typeparam>
            <param name="source">The value provider to buffer.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, that with respect to some asynchronous delay has the same value as <paramref name="source"/>, or null when <paramref name="source"/> is null.</returns>
            <remarks>The default work queue can be configured using the 'DefaultWorkQueueProvider' attribute of the 'Obtics' configuration section.</remarks>
            <seealso cref="P:Obtics.Async.WorkQueue.DefaultWorkQueueProvider"/>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Cast``1(Obtics.Values.IValueProvider)">
            <summary>
            Casts an untyped source IValueProvider to a Typed IValueProvider.
            </summary>
            <typeparam name="TType">The Value type of the IValueProvider to cast to.</typeparam>
            <param name="source">The untyped IValueProvider that needs to be converted to a typed IValueProvider</param>
            <returns>A Typed IValueProvider.</returns>
            <remarks>
            Alternatively, when the source is a typed IValueProvider but of with a different Value type than the intended type
            and this original Value type is a value-type (like int, long or a struct), 
            the Select method can be used with a Func that returns the value casted to the target type. 
            This may be more efficient than the Cast from an untyped source because the casting from an untyped source
            may require some boxing and unboxing.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Convert``2(Obtics.Values.IValueProvider{``0},System.Func{Obtics.Values.IValueProvider{``0},``1})">
            <summary>
            Converts an input value to a new value using a given converter delegate.
            </summary>
            <typeparam name="TSource">Type of the Value of source IValueProvider.</typeparam>
            <typeparam name="TResult">Type of the Value of the result IValueProvider, also the return type of the converter delegate.</typeparam>
            <param name="source">IValueProvider that is the source value for the conversion</param>
            <param name="valueConverter">delegate (Func&lt;IValueProvider&lt;TSource&gt;,TResult&gt;) that converts the input IValueProvider to the result value.</param>
            <returns>An IValueProvider whose Value is the result of the latest call to the valueConverter.
            If source or valueConverter equals null then the return value will be null.</returns>
            <remarks>
            The converter delegate is passed the original IValueProvider and not just the Value of that IValueProvider.
            This allows the converter NOT TO ACCESS the Value property of the source, possibly preventing wasting of resources.
            This is the only purpose the passed IValueProvider should be used for. The valueConverter should only consume the current
            Value of the given IValueProvider.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Convert``3(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},System.Func{Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},``2})">
            <summary>
            Converts the input values of two sources to a new value using a given converter delegate.
            </summary>
            <typeparam name="TSource1">Type of the Value of first source IValueProvider.</typeparam>
            <typeparam name="TSource2">Type of the Value of second source IValueProvider.</typeparam>
            <typeparam name="TResult">Type of the Value of the result IValueProvider, also the return type of the converter delegate.</typeparam>
            <param name="source1">IValueProvider that is the first source value for the conversion</param>
            <param name="source2">IValueProvider that is the second source value for the conversion</param>
            <param name="valueConverter">delegate (Func&lt;IValueProvider&lt;TSource1&gt;,IValueProvider&lt;TSource2&gt;,TResult&gt;) that converts the input IValueProviders to the result value.</param>
            <returns>An IValueProvider whose Value is the result of the latest call to the valueConverter.
            If source1, source2 or valueConverter equals null then the return value will be null.</returns>
            <remarks>
            The converter delegate is passed the original IValueProviders and not just the Values of those IValueProviders.
            This allows the converter NOT TO ACCESS the Value properties of the sources, possibly preventing wasting of resources.
            This is the only purpose the passed IValueProviders should be used for. The valueConverter should only consume the current
            Values of the given IValueProviders.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Convert``4(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},System.Func{Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},``3})">
            <summary>
            Converts the input values of three sources to a new value using a given converter delegate.
            </summary>
            <typeparam name="TSource1">Type of the Value of first source IValueProvider.</typeparam>
            <typeparam name="TSource2">Type of the Value of second source IValueProvider.</typeparam>
            <typeparam name="TSource3">Type of the Value of third source IValueProvider.</typeparam>
            <typeparam name="TResult">Type of the Value of the result IValueProvider, also the return type of the converter delegate.</typeparam>
            <param name="source1">IValueProvider that is the first source value for the conversion</param>
            <param name="source2">IValueProvider that is the second source value for the conversion</param>
            <param name="source3">IValueProvider that is the third source value for the conversion</param>
            <param name="valueConverter">delegate (Func&lt;IValueProvider&lt;TSource1&gt;,IValueProvider&lt;TSource2&gt;,IValueProvider&lt;TSource3&gt;,TResult&gt;) 
            that converts the input IValueProviders to the result value.</param>
            <returns>An IValueProvider whose Value is the result of the latest call to the valueConverter.
            If source1, source2, source3 or valueConverter equals null then the return value will be null.</returns>
            <remarks>
            The converter delegate is passed the original IValueProviders and not just the Values of those IValueProviders.
            This allows the converter NOT TO ACCESS the Value properties of the sources, possibly preventing wasting of resources.
            This is the only purpose the passed IValueProviders should be used for. The valueConverter should only consume the current
            Values of the given IValueProviders.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Convert``5(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},Obtics.Values.IValueProvider{``3},System.Func{Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},Obtics.Values.IValueProvider{``3},``4})">
            <summary>
            Converts the input values of four sources to a new value using a given converter delegate.
            </summary>
            <typeparam name="TSource1">Type of the Value of first source IValueProvider.</typeparam>
            <typeparam name="TSource2">Type of the Value of second source IValueProvider.</typeparam>
            <typeparam name="TSource3">Type of the Value of third source IValueProvider.</typeparam>
            <typeparam name="TSource4">Type of the Value of fourth source IValueProvider.</typeparam>
            <typeparam name="TResult">Type of the Value of the result IValueProvider, also the return type of the converter delegate.</typeparam>
            <param name="source1">IValueProvider that is the first source value for the conversion</param>
            <param name="source2">IValueProvider that is the second source value for the conversion</param>
            <param name="source3">IValueProvider that is the third source value for the conversion</param>
            <param name="source4">IValueProvider that is the fourth source value for the conversion</param>
            <param name="valueConverter">delegate (Func&lt;IValueProvider&lt;TSource1&gt;,IValueProvider&lt;TSource2&gt;,IValueProvider&lt;TSource3&gt;,IValueProvider&lt;TSource4&gt;,TResult&gt;) 
            that converts the input IValueProviders to the result value.</param>
            <returns>An IValueProvider whose Value is the result of the latest call to the valueConverter.
            If source1, source2, source3, source4 or valueConverter equals null then the return value will be null.</returns>
            <remarks>
            The converter delegate is passed the original IValueProviders and not just the Values of those IValueProviders.
            This allows the converter NOT TO ACCESS the Value properties of the sources, possibly preventing wasting of resources.
            This is the only purpose the passed IValueProviders should be used for. The valueConverter should only consume the current
            Values of the given IValueProviders.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Convert``1(Obtics.Values.IValueProvider[],System.Func{Obtics.Values.IValueProvider[],``0})">
            <summary>
            Converts the input values of multiple sources to a new value using a given converter delegate.
            </summary>
            <typeparam name="TResult">Type of the Value of the result IValueProvider, also the return type of the converter delegate.</typeparam>
            <param name="sources">An array of untyped IValueProviders that are the source for the conversion</param>
            <param name="valueConverter">delegate (Func&lt;IValueProvider[],TResult&gt;) 
            that converts the input untyped IValueProviders to the result value.</param>
            <returns>An IValueProvider whose Value is the result of the latest call to the valueConverter.
            If sources, any item of sources or valueConverter equals null then the return value will be null.</returns>
            <remarks>
            The converter delegate is passed the original IValueProviders and not just the Values of those IValueProviders.
            This allows the converter NOT TO ACCESS the Value properties of the sources, possibly preventing wasting of resources by doing so.
            This is the only purpose the passed IValueProviders should be used for. The valueConverter should only consume the current
            Values of the given IValueProviders.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Convert``1(System.Func{Obtics.Values.IValueProvider[],``0},Obtics.Values.IValueProvider[])">
            <summary>
            Converts the input values of multiple sources to a new value using a given converter delegate.
            </summary>
            <typeparam name="TResult">Type of the Value of the result IValueProvider, also the return type of the converter delegate.</typeparam>
            <param name="sources">mutiple untyped IValueProviders that are the source for the conversion</param>
            <param name="valueConverter">delegate (Func&lt;IValueProvider[],TResult&gt;)
            that converts the input untyped IValueProviders to the result value.</param>
            <returns>An IValueProvider whose Value is the result of the latest call to the valueConverter.
            If sources, any item of sources or valueConverter equals null then the return value will be null.</returns>
            <remarks>
            The converter delegate is passed the original IValueProviders and not just the Values of those IValueProviders.
            This allows the converter NOT TO ACCESS the Value properties of the sources, possibly preventing wasting of resources by doing so.
            This is the only purpose the passed IValueProviders should be used for. The valueConverter should only consume the current
            Values of the given IValueProviders.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Convert``2(Obtics.Values.IValueProvider{``0},System.Func{Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1}})">
            <summary>
            Converts an input value to an IValueProvider using a given converter delegate.
            </summary>
            <typeparam name="TSource">Type of the Value of source IValueProvider.</typeparam>
            <typeparam name="TResult">Type of the Value of the result IValueProvider.</typeparam>
            <param name="source">IValueProvider that is the source value for the conversion</param>
            <param name="valueConverter">delegate (Func&lt;IValueProvider&lt;TSource&gt;,IValueProvider&lt;TResult&gt;&gt;) that converts the input IValueProvider to a result IValueProvider.</param>
            <returns>An IValueProvider whose Value is the Value of the IValueProvider returned by the latest call to the valueConverter.
            If source or valueConverter equals null then the return value will be null.</returns>
            <remarks>
            The converter delegate is passed the original IValueProvider and not just the Value of that IValueProvider.
            This allows the converter NOT TO ACCESS the Value property of the source, possibly preventing wasting of resources.
            This is the only purpose the passed IValueProvider should be used for. The valueConverter should only consume the current
            Value of the given IValueProvider.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Convert``3(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},System.Func{Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2}})">
            <summary>
            Converts two input values to an IValueProvider using a given converter delegate.
            </summary>
            <typeparam name="TSource1">Type of the Value of the first source IValueProvider.</typeparam>
            <typeparam name="TSource2">Type of the Value of the second source IValueProvider.</typeparam>
            <typeparam name="TResult">Type of the Value of the result IValueProvider.</typeparam>
            <param name="source1">IValueProvider that is the first source value for the conversion</param>
            <param name="source2">IValueProvider that is the second source value for the conversion</param>
            <param name="valueConverter">delegate (Func&lt;IValueProvider&lt;TSource1&gt;,IValueProvider&lt;TSource2&gt;,IValueProvider&lt;TResult&gt;&gt;) 
            that converts the two input IValueProviders to a result IValueProvider.</param>
            <returns>An IValueProvider whose Value is the Value of the IValueProvider returned by the latest call to the valueConverter.
            If source1, source2 or valueConverter equals null then the return value will be null.</returns>
            <remarks>
            The converter delegate is passed the original IValueProviders and not just the Values of those IValueProviders.
            This allows the converter NOT TO ACCESS the Value properties of the sources, possibly preventing wasting of resources by doing so.
            This is the only purpose the passed IValueProviders should be used for. The valueConverter should only consume the current
            Values of the given IValueProviders.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Convert``4(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},System.Func{Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},Obtics.Values.IValueProvider{``3}})">
            <summary>
            Converts three input values to an IValueProvider using a given converter delegate.
            </summary>
            <typeparam name="TSource1">Type of the Value of the first source IValueProvider.</typeparam>
            <typeparam name="TSource2">Type of the Value of the second source IValueProvider.</typeparam>
            <typeparam name="TSource3">Type of the Value of the third source IValueProvider.</typeparam>
            <typeparam name="TResult">Type of the Value of the result IValueProvider.</typeparam>
            <param name="source1">IValueProvider that is the first source value for the conversion</param>
            <param name="source2">IValueProvider that is the second source value for the conversion</param>
            <param name="source3">IValueProvider that is the third source value for the conversion</param>
            <param name="valueConverter">delegate (Func&lt;IValueProvider&lt;TSource1&gt;,IValueProvider&lt;TSource2&gt;,IValueProvider&lt;TSource3&gt;,IValueProvider&lt;TResult&gt;&gt;) 
            that converts the three input IValueProviders to a result IValueProvider.</param>
            <returns>An IValueProvider whose Value is the Value of the IValueProvider returned by the latest call to the valueConverter.
            If source1, source2, source3 or valueConverter equals null then the return value will be null.</returns>
            <remarks>
            The converter delegate is passed the original IValueProviders and not just the Values of those IValueProviders.
            This allows the converter NOT TO ACCESS the Value properties of the sources, possibly preventing wasting of resources by doing so.
            This is the only purpose the passed IValueProviders should be used for. The valueConverter should only consume the current
            Values of the given IValueProviders.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Convert``5(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},Obtics.Values.IValueProvider{``3},System.Func{Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},Obtics.Values.IValueProvider{``3},Obtics.Values.IValueProvider{``4}})">
            <summary>
            Converts four input values to an IValueProvider using a given converter delegate.
            </summary>
            <typeparam name="TSource1">Type of the Value of the first source IValueProvider.</typeparam>
            <typeparam name="TSource2">Type of the Value of the second source IValueProvider.</typeparam>
            <typeparam name="TSource3">Type of the Value of the third source IValueProvider.</typeparam>
            <typeparam name="TSource4">Type of the Value of the fourth source IValueProvider.</typeparam>
            <typeparam name="TResult">Type of the Value of the result IValueProvider.</typeparam>
            <param name="source1">IValueProvider that is the first source value for the conversion</param>
            <param name="source2">IValueProvider that is the second source value for the conversion</param>
            <param name="source3">IValueProvider that is the third source value for the conversion</param>
            <param name="source4">IValueProvider that is the fourth source value for the conversion</param>
            <param name="valueConverter">delegate (Func&lt;IValueProvider&lt;TSource1&gt;,IValueProvider&lt;TSource2&gt;,IValueProvider&lt;TSource3&gt;,IValueProvider&lt;TSource4&gt;,IValueProvider&lt;TResult&gt;&gt;) 
            that converts the three input IValueProviders to a result IValueProvider.</param>
            <returns>An IValueProvider whose Value is the Value of the IValueProvider returned by the latest call to the valueConverter.
            If source1, source2, source3, source4 or valueConverter equals null then the return value will be null.</returns>
            <remarks>
            The converter delegate is passed the original IValueProviders and not just the Values of those IValueProviders.
            This allows the converter NOT TO ACCESS the Value properties of the sources, possibly preventing wasting of resources by doing so.
            This is the only purpose the passed IValueProviders should be used for. The valueConverter should only consume the current
            Values of the given IValueProviders.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Convert``1(Obtics.Values.IValueProvider[],System.Func{Obtics.Values.IValueProvider[],Obtics.Values.IValueProvider{``0}})">
            <summary>
            Converts multiple input values to an IValueProvider using a given converter delegate.
            </summary>
            <typeparam name="TResult">Type of the Value of the result IValueProvider.</typeparam>
            <param name="sources">An array of untyped IValueProviders that are the source for the conversion</param>
            <param name="valueConverter">delegate (Func&lt;IValueProvider[],IValueProvider&lt;TResult&gt;&gt;) 
            that converts the multiple input IValueProviders to a result IValueProvider.</param>
            <returns>An IValueProvider whose Value is the Value of the IValueProvider returned by the latest call to the valueConverter.
            If sources, any item of sources or valueConverter equals null then the return value will be null.</returns>
            <remarks>
            The converter delegate is passed the original IValueProviders and not just the Values of those IValueProviders.
            This allows the converter NOT TO ACCESS the Value properties of the sources, possibly preventing wasting of resources by doing so.
            This is the only purpose the passed IValueProviders should be used for. The valueConverter should only consume the current
            Values of the given IValueProviders.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Convert``1(System.Func{Obtics.Values.IValueProvider[],Obtics.Values.IValueProvider{``0}},Obtics.Values.IValueProvider[])">
            <summary>
            Converts multiple input values to an IValueProvider using a given converter delegate.
            </summary>
            <typeparam name="TResult">Type of the Value of the result IValueProvider.</typeparam>
            <param name="sources">An array of untyped IValueProviders that are the source for the conversion</param>
            <param name="valueConverter">delegate (Func&lt;IValueProvider[],IValueProvider&lt;TResult&gt;&gt;) 
            that converts the multiple input IValueProviders to a result IValueProvider.</param>
            <returns>An IValueProvider whose Value is the Value of the IValueProvider returned by the latest call to the valueConverter.
            If sources, any item of sources or valueConverter equals null then the return value will be null.</returns>
            <remarks>
            The converter delegate is passed the original IValueProviders and not just the Values of those IValueProviders.
            This allows the converter NOT TO ACCESS the Value properties of the sources, possibly preventing wasting of resources by doing so.
            This is the only purpose the passed IValueProviders should be used for. The valueConverter should only consume the current
            Values of the given IValueProviders.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.ReadOnly``1(Obtics.Values.IValueProvider{``0})">
            <summary>
            Returns a read only version of the <paramref name="source"/> <see cref="T:Obtics.Values.IValueProvider`1"/>
            </summary>
            <typeparam name="TType">Type of the Value property of the <paramref name="source"/> <see cref="T:Obtics.Values.IValueProvider`1"/></typeparam>
            <param name="source">The IValueProvider to return a read only version of.</param>
            <returns>A read only version of the <paramref name="source"/> <see cref="T:Obtics.Values.IValueProvider`1"/>
            If the <paramref name="source"/> parameter is null then null is returned instead.</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.AsValueProvider``1(Obtics.Values.IValueProvider{``0})">
            <summary>
            Returns value provider as an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            </summary>
            <typeparam name="TType">The type of the Value property of the source value provider</typeparam>
            <param name="source">The value provider that is to be returned as an <see cref="T:Obtics.Values.IValueProvider`1"/>.</param>
            <returns>the source as an <see cref="T:Obtics.Values.IValueProvider`1"/>.</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.And(System.Boolean,System.Boolean)">
            <summary>
            Returns an IValueProvider&lt;bool&gt; that represents the logical 'and' of the Values of its two source boolean values
            </summary>
            <param name="a">The first source boolean to calculate the result from.</param>
            <param name="b">The second source boolean to calculate the result from.</param>
            <returns>An IValueProvider&lt;bool&gt; that represents the logical 'and' of the source values.</returns>
            <remarks>The returned <see cref="T:Obtics.Values.IValueProvider`1"/> will be a static value provider.</remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.And(Obtics.Values.IValueProvider{System.Boolean},System.Boolean)">
            <summary>
            Returns an IValueProvider&lt;bool&gt; that represents the logical 'and' of the Values of its two source values.
            </summary>
            <param name="a">The first source IValueProvider&lt;bool&gt; to calculate the result from.</param>
            <param name="b">The second source boolean to calculate the result from.</param>
            <returns>An IValueProvider&lt;bool&gt; that represents the logical 'and' of the Values of its two source IValueProvider&lt;bool&gt;s</returns>
            <remarks>Change notifications are only propagated if the related change of the source value could ever influence the result value.</remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.And(System.Boolean,Obtics.Values.IValueProvider{System.Boolean})">
            <summary>
            Returns an IValueProvider&lt;bool&gt; that represents the logical 'and' of the Values of its two source values.
            </summary>
            <param name="a">The first source boolean to calculate the result from.</param>
            <param name="b">The second source IValueProvider&lt;bool&gt; to calculate the result from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> that represents the logical 'and' of its two source values.</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.And(Obtics.Values.IValueProvider{System.Boolean},Obtics.Values.IValueProvider{System.Boolean})">
            <summary>
            Returns an IValueProvider&lt;bool&gt; that represents the logical 'and' of the Values of its two source IValueProvider&lt;bool&gt;s
            </summary>
            <param name="a">The first source IValueProvider&lt;bool&gt; to calculate the result from.</param>
            <param name="b">The second source IValueProvider&lt;bool&gt; to calculate the result from.</param>
            <returns>An IValueProvider&lt;bool&gt; that represents the logical 'and' of the Values of its two source IValueProvider&lt;bool&gt;s</returns>
            <remarks>Change notifications are only propagated if the related change of the source value could ever influence the result value.</remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Or(System.Boolean,System.Boolean)">
            <summary>
            Returns an IValueProvider&lt;bool&gt; that represents the logical 'or' of the Values of its two source boolean values
            </summary>
            <param name="a">The first source boolean to calculate the result from.</param>
            <param name="b">The second source boolean to calculate the result from.</param>
            <returns>An IValueProvider&lt;bool&gt; that represents the logical 'or' of the source values.</returns>
            <remarks>The returned <see cref="T:Obtics.Values.IValueProvider`1"/> will be a static value provider.</remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Or(Obtics.Values.IValueProvider{System.Boolean},System.Boolean)">
            <summary>
            Returns an IValueProvider&lt;bool&gt; that represents the logical 'or' of the Values of its two source IValueProvider&lt;bool&gt;s
            </summary>
            <param name="a">The first source IValueProvider&lt;bool&gt; to calculate the result from.</param>
            <param name="b">The second source IValueProvider&lt;bool&gt; to calculate the result from.</param>
            <returns>An IValueProvider&lt;bool&gt; that represents the logical 'or' of the Values of its two source IValueProvider&lt;bool&gt;s</returns>
            <remarks>Change notifications are only propagated if the related change of the source value could ever influence the result value.</remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Or(System.Boolean,Obtics.Values.IValueProvider{System.Boolean})">
            <summary>
            Returns an IValueProvider&lt;bool&gt; that represents the logical 'or' of the Values of its two source values.
            </summary>
            <param name="a">The first source boolean to calculate the result from.</param>
            <param name="b">The second source IValueProvider&lt;bool&gt; to calculate the result from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> that represents the logical 'or' of its two source values.</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Or(Obtics.Values.IValueProvider{System.Boolean},Obtics.Values.IValueProvider{System.Boolean})">
            <summary>
            Returns an IValueProvider&lt;bool&gt; that represents the logical 'or' of the Values of its two source IValueProvider&lt;bool&gt;s
            </summary>
            <param name="a">The first source IValueProvider&lt;bool&gt; to calculate the result from.</param>
            <param name="b">The second source IValueProvider&lt;bool&gt; to calculate the result from.</param>
            <returns>An IValueProvider&lt;bool&gt; that represents the logical 'or' of the Values of its two source IValueProvider&lt;bool&gt;s</returns>
            <remarks>Change notifications are only propagated if the related change of the source value could ever influence the result value.</remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.XOr(Obtics.Values.IValueProvider{System.Boolean},Obtics.Values.IValueProvider{System.Boolean})">
            <summary>
            Returns an IValueProvider&lt;bool&gt; that represents the logical 'exclusive or' of the Values of its two source IValueProvider&lt;bool&gt;s
            </summary>
            <param name="a">The first source IValueProvider&lt;bool&gt; to calculate the result from.</param>
            <param name="b">The second source IValueProvider&lt;bool&gt; to calculate the result from.</param>
            <returns>An IValueProvider&lt;bool&gt; that represents the logical 'exclusive or' of the Values of its two source IValueProvider&lt;bool&gt;s</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.XOr(Obtics.Values.IValueProvider{System.Boolean},System.Boolean)">
            <summary>
            Returns an IValueProvider&lt;bool&gt; that represents the logical 'exclusive or' of the Values of its two source IValueProvider&lt;bool&gt;s
            </summary>
            <param name="a">The first source IValueProvider&lt;bool&gt; to calculate the result from.</param>
            <param name="b">The second source IValueProvider&lt;bool&gt; to calculate the result from.</param>
            <returns>An IValueProvider&lt;bool&gt; that represents the logical 'exclusive or' of the Values of its two source IValueProvider&lt;bool&gt;s</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Invert(Obtics.Values.IValueProvider{System.Boolean})">
            <summary>
            Returns an IValueProvider&lt;bool&gt; that represents the logical 'inverse' of the Value of its source IValueProvider&lt;bool&gt;
            </summary>
            <param name="a">The source IValueProvider&lt;bool&gt; to calculate the result from.</param>
            <returns>An IValueProvider&lt;bool&gt; that represents the logical 'inverse' of the Value of its source IValueProvider&lt;bool&gt;</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.IIf``1(System.Boolean,``0,``0)">
            <summary>
            Inline if. When the first value is true the second argument 'trueValue' will be returned and when it is false
            the third agrument falseValue will be returned.
            </summary>
            <typeparam name="TType">The Value type of the resulting IValueProvider and of IValuePRovider arguments 'trueValue' and 'falseValue'</typeparam>
            <param name="selector">A boolean value that determines if the value of the second or third argument is returned.</param>
            <param name="trueValue">Value if the 'selector' argument equals true.</param>
            <param name="falseValue">Value if the 'selector' argument equals true.</param>
            <returns>An IValueProvider whose Value depending on the Value of 'selector' will be the Value of 'trueValue' or 'falseValue'</returns>
            <remarks>The returned <see cref="T:Obtics.Values.IValueProvider`1"/> will be a static value provider.</remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.IIf``1(Obtics.Values.IValueProvider{System.Boolean},``0,``0)">
            <summary>
            Inline if. The first IValueProvider 'selector' returns a boolean value. When this value is true the second argument 'trueValue' will be returned and when it is false
            the third agrument falseValue will be returned.
            </summary>
            <typeparam name="TType">The Value type of the resulting IValueProvider and of IValuePRovider arguments 'trueValue' and 'falseValue'</typeparam>
            <param name="selector">The IValueProvider&lt;bool&gt; arguments whose Value determines if 'trueValue' or 'falseValue' will be returned.</param>
            <param name="trueValue">Value if the 'selector' argument equals true.</param>
            <param name="falseValue">Value if the 'selector' argument equals false.</param>
            <returns>An IValueProvider whose Value depending on the Value of 'selector' will be the Value of 'trueValue' or 'falseValue'</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.IIf``1(System.Boolean,Obtics.Values.IValueProvider{``0},``0)">
            <summary>
            Inline if. When the first value is true the Value proverty of the second argument <paramref name="trueValue"/> will be returned and when it is false
            the third agrument <paramref name="falseValue"/> will be returned.
            </summary>
            <typeparam name="TType">The Value type of the resulting- and <paramref name="falseValue"/> <see cref="T:Obtics.Values.IValueProvider"/>s and type of argument <paramref name="trueValue"/>.</typeparam>
            <param name="selector">A boolean value that determines if the value of the second or third argument is returned.</param>
            <param name="trueValue">Value if the 'selector' argument equals true.</param>
            <param name="falseValue">Value if the 'selector' argument equals false.</param>
            <returns>An IValueProvider whose Value depending on the Value of 'selector' will be the Value of 'trueValue' or 'falseValue'</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.IIf``1(Obtics.Values.IValueProvider{System.Boolean},Obtics.Values.IValueProvider{``0},``0)">
            <summary>
            Inline if. The first IValueProvider 'selector' returns a boolean value. When this value is true the second argument 'trueValue' will be returned and when it is false
            the third agrument falseValue will be returned.
            </summary>
            <typeparam name="TType">The Value type of the resulting IValueProvider and of IValueProvider arguments 'trueValue' and 'falseValue'</typeparam>
            <param name="selector">The IValueProvider&lt;bool&gt; arguments whose Value determines if 'trueValue' or 'falseValue' will be returned.</param>
            <param name="trueValue">Value if the 'selector' argument equals true.</param>
            <param name="falseValue">Value if the 'selector' argument equals false.</param>
            <returns>An IValueProvider whose Value depending on the Value of 'selector' will be the Value of 'trueValue' or 'falseValue'</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.IIf``1(System.Boolean,``0,Obtics.Values.IValueProvider{``0})">
            <summary>
            Inline if. When the first value is true the second argument <paramref name="trueValue"/> will be returned and when it is false
            the Value proverty of the third agrument <paramref name="falseValue"/> will be returned.
            </summary>
            <typeparam name="TType">The Value type of the resulting- and <paramref name="trueValue"/> <see cref="T:Obtics.Values.IValueProvider"/>s and type of argument <paramref name="falseValue"/>.</typeparam>
            <param name="selector">A boolean value that determines if the value of the second or third argument is returned.</param>
            <param name="trueValue">Value if the 'selector' argument equals true.</param>
            <param name="falseValue">Value if the 'selector' argument equals false.</param>
            <returns>An IValueProvider whose Value depending on the Value of 'selector' will be the Value of 'trueValue' or 'falseValue'</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.IIf``1(Obtics.Values.IValueProvider{System.Boolean},``0,Obtics.Values.IValueProvider{``0})">
            <summary>
            Inline if. The first IValueProvider 'selector' returns a boolean value. When this value is true the second argument 'trueValue' will be returned and when it is false
            the third agrument falseValue will be returned.
            </summary>
            <typeparam name="TType">The Value type of the resulting IValueProvider and of IValuePRovider arguments 'trueValue' and 'falseValue'</typeparam>
            <param name="selector">The IValueProvider&lt;bool&gt; arguments whose Value determines if 'trueValue' or 'falseValue' will be returned.</param>
            <param name="trueValue">The IValueProvider that will be return if the Value if the 'selector' argument equals true.</param>
            <param name="falseValue">The IValueProvider that will be return if the Value if the 'selector' argument equals true.</param>
            <returns>An IValueProvider whose Value depending on the Value of 'selector' will be the Value of 'trueValue' or 'falseValue'</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.IIf``1(System.Boolean,Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``0})">
            <summary>
            Inline if. When the first value is true the second argument <paramref name="trueValue"/> will be returned and when it is false
            the third agrument <paramref name="falseValue"/> will be returned.
            </summary>
            <typeparam name="TType">The Value type of the resulting IValueProvider and of IValuePRovider arguments 'trueValue' and 'falseValue'</typeparam>
            <param name="selector">A boolean value that determines if the value of the second or third argument is returned.</param>
            <param name="trueValue">The IValueProvider that will be return if the Value if the 'selector' argument equals true.</param>
            <param name="falseValue">The IValueProvider that will be return if the Value if the 'selector' argument equals true.</param>
            <returns>An IValueProvider whose Value depending on the Value of 'selector' will be the Value of 'trueValue' or 'falseValue'</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.IIf``1(Obtics.Values.IValueProvider{System.Boolean},Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``0})">
            <summary>
            Inline if. The first IValueProvider 'selector' returns a boolean value. When this value is true the second argument 'trueValue' will be returned and when it is false
            the third agrument falseValue will be returned.
            </summary>
            <typeparam name="TType">The Value type of the resulting IValueProvider and of IValuePRovider arguments 'trueValue' and 'falseValue'</typeparam>
            <param name="selector">The IValueProvider&lt;bool&gt; arguments whose Value determines if 'trueValue' or 'falseValue' will be returned.</param>
            <param name="trueValue">The IValueProvider that will be return if the Value if the 'selector' argument equals true.</param>
            <param name="falseValue">The IValueProvider that will be return if the Value if the 'selector' argument equals true.</param>
            <returns>An IValueProvider whose Value depending on the Value of 'selector' will be the Value of 'trueValue' or 'falseValue'</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Select``2(Obtics.Values.IValueProvider{``0},System.Func{``0,``1})">
            <summary>
            Converts an input value to a new value using a given converter delegate.
            </summary>
            <typeparam name="TSource">Type of the Value of the <paramref name="source"/> IValueProvider. And Type of the argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TResult">Type of the Value of the result IValueProvider. Also the return type of <paramref name="valueConverter"/>.</typeparam>
            <param name="source">IValueProvider that provides the source value for the conversion.</param>
            <param name="valueConverter">delegate (<see cref="T:System.Func`2"/>) that converts the Value of the <paramref name="source"/> IValueProvider to the result value.</param>
            <returns>An IValueProvider whose Value is the result of the latest call to the <paramref name="valueConverter"/>.
            If <paramref name="source"/> or <paramref name="valueConverter"/> equals null then the return value will be null.</returns>
            <remarks>
            <paramref name="valueConverter"/> is passed the current Value of the <paramref name="source"/> IValueProvider. This means
            that implicitly the Value of <paramref name="source"/> is collected whenever <paramref name="valueConverter"/> is called. To
            prevent this implicit value collection use <see cref="M:Obtics.Values.ValueProvider.Convert``2(Obtics.Values.IValueProvider{``0},System.Func{Obtics.Values.IValueProvider{``0},``1})"/>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Select``3(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},System.Func{``0,``1,``2})">
            <summary>
            Converts two input values to a new value using a given converter delegate.
            </summary>
            <typeparam name="TSource1">Type of the Value of the <paramref name="source1"/> IValueProvider. And Type of the first argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TSource2">Type of the Value of the <paramref name="source2"/> IValueProvider. And Type of the second argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TResult">Type of the Value of the result IValueProvider. Also the return type of <paramref name="valueConverter"/>.</typeparam>
            <param name="source1">IValueProvider that provides the first source value for the conversion.</param>
            <param name="source2">IValueProvider that provides the second source value for the conversion.</param>
            <param name="valueConverter">delegate (<see cref="T:System.Func`3"/>) that converts the Values of the source IValueProviders to the result value.</param>
            <returns>An IValueProvider whose Value is the result of the latest call to the <paramref name="valueConverter"/>.
            If <paramref name="source1"/>, <paramref name="source2"/> or <paramref name="valueConverter"/> equals null then the return value will be null.</returns>
            <remarks>
            <paramref name="valueConverter"/> is passed the current Values of the source IValueProviders. This means
            that implicitly the Value of each source is collected whenever <paramref name="valueConverter"/> is called. To
            prevent this implicit value collection use <see cref="M:Obtics.Values.ValueProvider.Convert``3(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},System.Func{Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},``2})"/>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Select``4(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Converts three input values to a new value using a given converter delegate.
            </summary>
            <typeparam name="TSource1">Type of the Value of the <paramref name="source1"/> IValueProvider. And Type of the first argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TSource2">Type of the Value of the <paramref name="source2"/> IValueProvider. And Type of the second argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TSource3">Type of the Value of the <paramref name="source3"/> IValueProvider. And Type of the third argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TResult">Type of the Value of the result IValueProvider. Also the return type of <paramref name="valueConverter"/>.</typeparam>
            <param name="source1">IValueProvider that provides the first source value for the conversion.</param>
            <param name="source2">IValueProvider that provides the second source value for the conversion.</param>
            <param name="source3">IValueProvider that provides the third source value for the conversion.</param>
            <param name="valueConverter">delegate (<see cref="T:System.Func`4"/>) that converts the Values of the source IValueProviders to the result value.</param>
            <returns>An IValueProvider whose Value is the result of the latest call to the <paramref name="valueConverter"/>.
            If <paramref name="source1"/>, <paramref name="source2"/>, <paramref name="source3"/> or <paramref name="valueConverter"/> equals null then the return value will be null.</returns>
            <remarks>
            <paramref name="valueConverter"/> is passed the current Values of the source IValueProviders. This means
            that implicitly the Value of each source is collected whenever <paramref name="valueConverter"/> is called. To
            prevent this implicit value collection use <see cref="M:Obtics.Values.ValueProvider.Convert``4(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},System.Func{Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},``3})"/>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Select``5(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},Obtics.Values.IValueProvider{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Converts four input values to a new value using a given converter delegate.
            </summary>
            <typeparam name="TSource1">Type of the Value of the <paramref name="source1"/> IValueProvider. And Type of the first argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TSource2">Type of the Value of the <paramref name="source2"/> IValueProvider. And Type of the second argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TSource3">Type of the Value of the <paramref name="source3"/> IValueProvider. And Type of the third argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TSource4">Type of the Value of the <paramref name="source4"/> IValueProvider. And Type of the fourth argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TResult">Type of the Value of the result IValueProvider. Also the return type of <paramref name="valueConverter"/>.</typeparam>
            <param name="source1">IValueProvider that provides the first source value for the conversion.</param>
            <param name="source2">IValueProvider that provides the second source value for the conversion.</param>
            <param name="source3">IValueProvider that provides the third source value for the conversion.</param>
            <param name="source4">IValueProvider that provides the fourth source value for the conversion.</param>
            <param name="valueConverter">delegate (<see cref="T:System.Func`5"/>) that converts the Values of the source IValueProviders to the result value.</param>
            <returns>An IValueProvider whose Value is the result of the latest call to the <paramref name="valueConverter"/>.
            If <paramref name="source1"/>, <paramref name="source2"/>, <paramref name="source3"/>, <paramref name="source4"/> or <paramref name="valueConverter"/> equals null then the return value will be null.</returns>
            <remarks>
            <paramref name="valueConverter"/> is passed the current Values of the source IValueProviders. This means
            that implicitly the Value of each source is collected whenever <paramref name="valueConverter"/> is called. To
            prevent this implicit value collection use <see cref="M:Obtics.Values.ValueProvider.Convert``5(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},Obtics.Values.IValueProvider{``3},System.Func{Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},Obtics.Values.IValueProvider{``3},``4})"/>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Select``1(Obtics.Values.IValueProvider[],System.Func{System.Object[],``0})">
            <summary>
            Converts multiple input values to a new value using a given converter delegate.
            </summary>
            <typeparam name="TResult">Type of the Value of the result IValueProvider. Also the return type of <paramref name="valueConverter"/>.</typeparam>
            <param name="sources">Array of untyped IValueProviders that provide the source values for <paramref name="valueConverter"/>.</param>
            <param name="valueConverter">delegate (<see cref="T:System.Func`2"/>) that converts the Values of the source IValueProviders to the result value.</param>
            <returns>An IValueProvider whose Value is the result of the latest call to the <paramref name="valueConverter"/>.
            If <paramref name="sources"/>, any of its items or <paramref name="valueConverter"/> equals null then the return value will be null.</returns>
            <remarks>
            <paramref name="valueConverter"/> is passed the current Values of the source IValueProviders. This means
            that implicitly the Value of each source is collected whenever <paramref name="valueConverter"/> is called. To
            prevent this implicit value collection use <see cref="M:Obtics.Values.ValueProvider.Convert``1(Obtics.Values.IValueProvider[],System.Func{Obtics.Values.IValueProvider[],``0})"/>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Select``1(System.Func{System.Object[],``0},Obtics.Values.IValueProvider[])">
            <summary>
            Converts multiple input values to a new value using a given converter delegate.
            </summary>
            <typeparam name="TResult">Type of the Value of the result IValueProvider. Also the return type of <paramref name="valueConverter"/>.</typeparam>
            <param name="valueConverter">delegate (<see cref="T:System.Func`2"/>) that converts the Values of the source IValueProviders to the result value.</param>
            <param name="sources">Array of untyped IValueProviders that provide the source values for <paramref name="valueConverter"/>.</param>
            <returns>An IValueProvider whose Value is the result of the latest call to the <paramref name="valueConverter"/>.
            If <paramref name="sources"/>, any of its items or <paramref name="valueConverter"/> equals null then the return value will be null.</returns>
            <remarks>
            <paramref name="valueConverter"/> is passed the current Values of the source IValueProviders. This means
            that implicitly the Value of each source is collected whenever <paramref name="valueConverter"/> is called. To
            prevent this implicit value collection use <see cref="M:Obtics.Values.ValueProvider.Convert``1(Obtics.Values.IValueProvider[],System.Func{Obtics.Values.IValueProvider[],``0})"/>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Select``2(Obtics.Values.IValueProvider{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}})">
            <summary>
            Converts an input value to an <see cref="T:Obtics.Values.IValueProvider`1"/> using a given converter delegate.
            </summary>
            <typeparam name="TSource">Type of the Value of the <paramref name="source"/> IValueProvider. And Type of the argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TResult">Type of the Value of the result IValueProvider. Also type of the Value of the IValueProvider returned by <paramref name="valueConverter"/>.</typeparam>
            <param name="source">IValueProvider that provides the source value for the conversion.</param>
            <param name="valueConverter">delegate (<see cref="T:System.Func`2"/>) that converts the Value of the <paramref name="source"/> IValueProvider to the result IValueProvider.</param>
            <returns>An IValueProvider whose Value is the Value of the IValueProvider returned by the latest call to the <paramref name="valueConverter"/>.
            If <paramref name="source"/> or <paramref name="valueConverter"/> equals null then the return value will be null.</returns>
            <remarks>
            <paramref name="valueConverter"/> is passed the current Value of the <paramref name="source"/> IValueProvider. This means
            that implicitly the Value of <paramref name="source"/> is collected whenever <paramref name="valueConverter"/> is called. To
            prevent this implicit value collection use <see cref="M:Obtics.Values.ValueProvider.Convert``2(Obtics.Values.IValueProvider{``0},System.Func{Obtics.Values.IValueProvider{``0},``1})"/>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Select``3(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},System.Func{``0,``1,Obtics.Values.IValueProvider{``2}})">
            <summary>
            Converts two input values to an <see cref="T:Obtics.Values.IValueProvider`1"/> using a given converter delegate.
            </summary>
            <typeparam name="TSource1">Type of the Value of the <paramref name="source1"/> IValueProvider. And Type of the first argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TSource2">Type of the Value of the <paramref name="source2"/> IValueProvider. And Type of the second argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TResult">Type of the Value of the result IValueProvider. Also type of the Value of the IValueProvider returned by <paramref name="valueConverter"/>.</typeparam>
            <param name="source1">IValueProvider that provides the first source value for the conversion.</param>
            <param name="source2">IValueProvider that provides the second source value for the conversion.</param>
            <param name="valueConverter">delegate (<see cref="T:System.Func`3"/>) that converts the Values of the source IValueProviders to the result IValueProvider.</param>
            <returns>An IValueProvider whose Value is the Value of the IValueProvider returned by the latest call to the <paramref name="valueConverter"/>.
            If <paramref name="source1"/>, <paramref name="source2"/> or <paramref name="valueConverter"/> equals null then the return value will be null.</returns>
            <remarks>
            <paramref name="valueConverter"/> is passed the current Values of the source IValueProviders. This means
            that implicitly the Value of the sources is collected whenever <paramref name="valueConverter"/> is called. To
            prevent this implicit value collection use <see cref="M:Obtics.Values.ValueProvider.Convert``3(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},System.Func{Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},``2})"/>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Select``4(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},System.Func{``0,``1,``2,Obtics.Values.IValueProvider{``3}})">
            <summary>
            Converts three input values to an <see cref="T:Obtics.Values.IValueProvider`1"/> using a given converter delegate.
            </summary>
            <typeparam name="TSource1">Type of the Value of the <paramref name="source1"/> IValueProvider. And Type of the first argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TSource2">Type of the Value of the <paramref name="source2"/> IValueProvider. And Type of the second argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TSource3">Type of the Value of the <paramref name="source3"/> IValueProvider. And Type of the third argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TResult">Type of the Value of the result IValueProvider. Also type of the Value of the IValueProvider returned by <paramref name="valueConverter"/>.</typeparam>
            <param name="source1">IValueProvider that provides the first source value for the conversion.</param>
            <param name="source2">IValueProvider that provides the second source value for the conversion.</param>
            <param name="source3">IValueProvider that provides the third source value for the conversion.</param>
            <param name="valueConverter">delegate (<see cref="T:System.Func`4"/>) 
            that converts the Values of the source IValueProviders to the result IValueProvider.</param>
            <returns>An IValueProvider whose Value is the Value of the IValueProvider returned by the latest call to the <paramref name="valueConverter"/>.
            If <paramref name="source1"/>, <paramref name="source2"/>, <paramref name="source3"/> or <paramref name="valueConverter"/> equals null then the return value will be null.</returns>
            <remarks>
            <paramref name="valueConverter"/> is passed the current Values of the source IValueProviders. This means
            that implicitly the Value of the sources is collected whenever <paramref name="valueConverter"/> is called. To
            prevent this implicit value collection use <see cref="M:Obtics.Values.ValueProvider.Convert``4(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},System.Func{Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},``3})"/>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Select``5(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},Obtics.Values.IValueProvider{``3},System.Func{``0,``1,``2,``3,Obtics.Values.IValueProvider{``4}})">
            <summary>
            Converts four input values to an <see cref="T:Obtics.Values.IValueProvider`1"/> using a given converter delegate.
            </summary>
            <typeparam name="TSource1">Type of the Value of the <paramref name="source1"/> IValueProvider. And Type of the first argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TSource2">Type of the Value of the <paramref name="source2"/> IValueProvider. And Type of the second argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TSource3">Type of the Value of the <paramref name="source3"/> IValueProvider. And Type of the third argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TSource4">Type of the Value of the <paramref name="source4"/> IValueProvider. And Type of the fourth argument to <paramref name="valueConverter"/>.</typeparam>
            <typeparam name="TResult">Type of the Value of the result IValueProvider. Also type of the Value of the IValueProvider returned by <paramref name="valueConverter"/>.</typeparam>
            <param name="source1">IValueProvider that provides the first source value for the conversion.</param>
            <param name="source2">IValueProvider that provides the second source value for the conversion.</param>
            <param name="source3">IValueProvider that provides the third source value for the conversion.</param>
            <param name="source4">IValueProvider that provides the fourth source value for the conversion.</param>
            <param name="valueConverter">delegate (<see cref="T:System.Func`5"/>) 
            that converts the Values of the source IValueProviders to the result IValueProvider.</param>
            <returns>An IValueProvider whose Value is the Value of the IValueProvider returned by the latest call to the <paramref name="valueConverter"/>.
            If <paramref name="source1"/>, <paramref name="source2"/>, <paramref name="source3"/>, <paramref name="source4"/> or <paramref name="valueConverter"/> equals null then the return value will be null.</returns>
            <remarks>
            <paramref name="valueConverter"/> is passed the current Values of the source IValueProviders. This means
            that implicitly the Value of the sources is collected whenever <paramref name="valueConverter"/> is called. To
            prevent this implicit value collection use <see cref="M:Obtics.Values.ValueProvider.Convert``5(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},Obtics.Values.IValueProvider{``3},System.Func{Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``1},Obtics.Values.IValueProvider{``2},Obtics.Values.IValueProvider{``3},``4})"/>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Select``1(Obtics.Values.IValueProvider[],System.Func{System.Object[],Obtics.Values.IValueProvider{``0}})">
            <summary>
            Converts multiple input values to an <see cref="T:Obtics.Values.IValueProvider`1"/> using a given converter delegate.
            </summary>
            <typeparam name="TResult">Type of the Value of the result IValueProvider. Also type of the Value of the IValueProvider returned by <paramref name="valueConverter"/>.</typeparam>
            <param name="sources">Array of untyped IValueProviders that provide the source values for <paramref name="valueConverter"/>.</param>
            <param name="valueConverter">delegate (<see cref="T:System.Func`2"/>)         
            that converts the Values of the source IValueProviders to the result IValueProvider.</param>
            <returns>An IValueProvider whose Value is the result of the latest call to the <paramref name="valueConverter"/>.
            If <paramref name="sources"/>, any of its items or <paramref name="valueConverter"/> equals null then the return value will be null.</returns>
            <remarks>
            <paramref name="valueConverter"/> is passed the current Values of the source IValueProviders. This means
            that implicitly the Value of each source is collected whenever <paramref name="valueConverter"/> is called. To
            prevent this implicit value collection use <see cref="M:Obtics.Values.ValueProvider.Convert``1(Obtics.Values.IValueProvider[],System.Func{Obtics.Values.IValueProvider[],``0})"/>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Select``1(System.Func{System.Object[],Obtics.Values.IValueProvider{``0}},Obtics.Values.IValueProvider[])">
            <summary>
            Converts multiple input values to an <see cref="T:Obtics.Values.IValueProvider`1"/> using a given converter delegate.
            </summary>
            <typeparam name="TResult">Type of the Value of the result IValueProvider. Also type of the Value of the IValueProvider returned by <paramref name="valueConverter"/>.</typeparam>
            <param name="sources">Array of untyped IValueProviders that provide the source values for <paramref name="valueConverter"/>.</param>
            <param name="valueConverter">delegate (<see cref="T:System.Func`2"/>)         
            that converts the Values of the source IValueProviders to the result IValueProvider.</param>
            <returns>An IValueProvider whose Value is the result of the latest call to the <paramref name="valueConverter"/>.
            If <paramref name="sources"/>, any of its items or <paramref name="valueConverter"/> equals null then the return value will be null.</returns>
            <remarks>
            <paramref name="valueConverter"/> is passed the current Values of the source IValueProviders. This means
            that implicitly the Value of each source is collected whenever <paramref name="valueConverter"/> is called. To
            prevent this implicit value collection use <see cref="M:Obtics.Values.ValueProvider.Convert``1(Obtics.Values.IValueProvider[],System.Func{Obtics.Values.IValueProvider[],``0})"/>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Cascade``1(Obtics.Values.IValueProvider{Obtics.Values.IValueProvider{``0}})">
            <summary>
            Converts an IValueProvider&lt;IValueProvider&lt;TType&gt;&gt; to an IValueProvider&lt;TType&gt;. The Value property
            of the result represents the Value property of the inner IValueProvider of the source. If the Value property of the
            outer IValueProvider has value null, then te result IValueProvider will have default(TType) as value for its Value property.
            </summary>
            <typeparam name="TType">Type of the Value property of the inner IValueProvider of the source and the type of the Value property of the result.</typeparam>
            <param name="source">The source <see cref="T:Obtics.Values.IValueProvider`1"/> of <see cref="T:Obtics.Values.IValueProvider`1"/>.</param>
            <returns>An IValueProvider&lt;TType&gt; of which the Value property represents the Value property of the inner IValueProvider of the source.</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Cascade``2(Obtics.Values.IValueProvider{``0})">
            <summary>
            Converts an <see cref="T:Obtics.Values.IValueProvider`1"/> of <typeparamref name="TSource"/> to an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <typeparamref name="TType"/>. The elements of the result collection
            will be the elements of the sequence returned by the source <see cref="T:Obtics.Values.IValueProvider`1"/>. If the Value property of the
            outer IValueProvider has value null, then the result collection will be empty.
            </summary>
            <typeparam name="TSource">The type of the source sequence. This type is constrained to an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <typeparamref name="TType"/>.</typeparam>
            <typeparam name="TType">Type of the elements of the sequence returned by <paramref name="source"/> and type of the elements of the result sequence.</typeparam>
            <param name="source">The source <see cref="T:Obtics.Values.IValueProvider`1"/> of <typeparamref name="TSource"/>.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <typeparamref name="TType"/> containing the elements returned by the sequence returned by <paramref name="source"/>, or null when <paramref name="source"/> is null.</returns>
            <remarks>
            The <paramref name="source"/> parameter of this method has two levels of observability. First, on the outer layer, the IValueProvider can 
            change its Value property. In other words; the sequence (<see cref="T:Obtics.Collections.IVersionedEnumerable`1"/>) gets replaced completely. Second, on the inner layer,
            the sequence can alter its contents. 
            
            Cascade merges these two layers into one resulting sequence whose contents will be exactly the contents of the source inner sequence or, if 
            the Value property of the outer IValueProvider is null, will be empty.
            
            Any change events from the outer layer will be translated into 'reset' events for the result sequence. Any change events from the inner
            layer will passed directly to the result sequence.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Cascade``1(Obtics.Values.IValueProvider{Obtics.Collections.IVersionedEnumerable{``0}})">
            <summary>
            Converts an IValueProvider&lt;IEnumerable&lt;TType&gt;&gt; to an IEnumerable&lt;TType&gt; The elements of the result collection
            will be the elements of the IEnumerable&lt;TType&gt; returned by the source IValueProvider. If the Value property of the
            outer IValueProvider has value null, then the result collection will be empty.
            </summary>
            <typeparam name="TType">Type of the elements of the IEnumerable returned by the source IValueProvider and type of the elements of the result collection.</typeparam>
            <param name="source">The source <see cref="T:Obtics.Values.IValueProvider`1"/> of <see cref="T:Obtics.Collections.IVersionedEnumerable`1"/>.</param>
            <returns>An IEnumerable&lt;TType&gt; containing the elements returned by the IEnumerable&lt;TType&gt; returned by the source IValueProvider.</returns>
            <remarks>
            The <paramref name="source"/> parameter of this method has two levels of observability. First, on the outer layer, the IValueProvider can 
            change its Value property. In other words; the sequence (<see cref="T:Obtics.Collections.IVersionedEnumerable`1"/>) gets replaced completely. Second, on the inner layer,
            the sequence can alter its contents. 
            
            Cascade merges these two layers into one resulting sequence whose contents will be exactly the contents of the source inner sequence or, if 
            the Value property of the outer IValueProvider is null, will be empty.
            
            Any change events from the outer layer will be translated into 'reset' events for the result sequence. Any change events from the inner
            layer will passed directly to the result sequence.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Cascade``1(Obtics.Values.IValueProvider{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts an IValueProvider&lt;IEnumerable&lt;TType&gt;&gt; to an IEnumerable&lt;TType&gt; The elements of the result collection
            will be the elements of the IEnumerable&lt;TType&gt; returned by the source IValueProvider. If the Value property of the
            outer IValueProvider has value null, then the result collection will be empty.
            </summary>
            <typeparam name="TType">Type of the elements of the IEnumerable returned by the source IValueProvider and type of the elements of the result collection.</typeparam>
            <param name="source">The source <see cref="T:Obtics.Values.IValueProvider`1"/> of <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</param>
            <returns>An IEnumerable&lt;TType&gt; containing the elements returned by the IEnumerable&lt;TType&gt; returned by the source IValueProvider.</returns>
            <remarks>
            The <paramref name="source"/> parameter of this method has two levels of observability. First, on the outer layer, the IValueProvider can 
            change its Value property. In other words; the sequence (<see cref="T:System.Collections.Generic.IEnumerable`1"/>) gets replaced completely. Second, on the inner layer,
            the sequence can alter its contents. 
            
            Cascade merges these two layers into one resulting sequence whose contents will be exactly the contents of the source inner sequence or, if 
            the Value property of the outer IValueProvider is null, will be empty.
            
            Any change events from the outer layer will be translated into 'reset' events for the result sequence. Any change events from the inner
            layer will passed directly to the result sequence.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Cascade``1(Obtics.Values.IValueProvider{System.Linq.IOrderedEnumerable{``0}})">
            <summary>
            Converts an IValueProvider&lt;IOrderedEnumerable&lt;TType&gt;&gt; to an IEnumerable&lt;TType&gt; The elements of the result collection
            will be the elements of the IEnumerable&lt;TType&gt; returned by the source IValueProvider. If the Value property of the
            outer IValueProvider has value null, then the result collection will be empty.
            </summary>
            <typeparam name="TType">Type of the elements of the IEnumerable returned by the source IValueProvider and type of the elements of the result collection.</typeparam>
            <param name="source">The source <see cref="T:Obtics.Values.IValueProvider`1"/> of <see cref="T:System.Linq.IOrderedEnumerable`1"/>.</param>
            <returns>An IEnumerable&lt;TType&gt; containing the elements returned by the IEnumerable&lt;TType&gt; returned by the source IValueProvider.</returns>
            <remarks>
            The <paramref name="source"/> parameter of this method has two levels of observability. First, on the outer layer, the IValueProvider can 
            change its Value property. In other words; the sequence (<see cref="T:System.Linq.IOrderedEnumerable`1"/>) gets replaced completely. Second, on the inner layer,
            the sequence can alter its contents. 
            
            Cascade merges these two layers into one resulting sequence whose contents will be exactly the contents of the source inner sequence or, if 
            the Value property of the outer IValueProvider is null, will be empty.
            
            Any change events from the outer layer will be translated into 'reset' events for the result sequence. Any change events from the inner
            layer will passed directly to the result sequence.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Cascade``1(Obtics.Values.IValueProvider{Obtics.Collections.IObservableOrderedEnumerable{``0}})">
            <summary>
            Converts an IValueProvider&lt;IObservableOrderedEnumerable&lt;TType&gt;&gt; to an IEnumerable&lt;TType&gt; The elements of the result collection
            will be the elements of the IEnumerable&lt;TType&gt; returned by the source IValueProvider. If the Value property of the
            outer IValueProvider has value null, then the result collection will be empty.
            </summary>
            <typeparam name="TType">Type of the elements of the IEnumerable returned by the source IValueProvider and type of the elements of the result collection.</typeparam>
            <param name="source">The source <see cref="T:Obtics.Values.IValueProvider`1"/> of <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>.</param>
            <returns>An IEnumerable&lt;TType&gt; containing the elements returned by the IEnumerable&lt;TType&gt; returned by the source IValueProvider.</returns>
            <remarks>
            The <paramref name="source"/> parameter of this method has two levels of observability. First, on the outer layer, the IValueProvider can 
            change its Value property. In other words; the sequence (<see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>) gets replaced completely. Second, on the inner layer,
            the sequence can alter its contents. 
            
            Cascade merges these two layers into one resulting sequence whose contents will be exactly the contents of the source inner sequence or, if 
            the Value property of the outer IValueProvider is null, will be empty.
            
            Any change events from the outer layer will be translated into 'reset' events for the result sequence. Any change events from the inner
            layer will passed directly to the result sequence.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Cascade``2(Obtics.Values.IValueProvider{System.Linq.IGrouping{``0,``1}})">
            <summary>
            Converts an <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property provides an <see cref="T:System.Linq.IGrouping`2"/> to an <see cref="T:System.Collections.Generic.IEnumerable`1"/>. The elements of the result sequence
            will be the elements of the grouping returned by the source value provider. If the Value property of the
            source is null, then the result sequence will be empty.
            </summary>
            <typeparam name="TKey">Type of the Key properties of the <see cref="T:System.Linq.IGrouping`2"/> provided by <paramref name="source"/>.</typeparam>
            <typeparam name="TType">Type of the elements of the <see cref="T:System.Linq.IGrouping`2"/> provided by <paramref name="source"/> and type of the elements of the result sequence.</typeparam>
            <param name="source">An <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Linq.IGrouping`2"/> Value property provides the sequence to build the result with.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> containing the elements of the grouping provided by <paramref name="source"/>.</returns>
            <remarks>
            The <paramref name="source"/> parameter of this method has two levels of observability. First, on the outer layer, the IValueProvider can 
            change its Value property. In other words; the sequence (<see cref="T:System.Linq.IGrouping`2"/>) gets replaced completely. Second, on the inner layer,
            the sequence can alter its contents. 
            
            Cascade merges these two layers into one resulting sequence whose contents will be exactly the contents of the source inner sequence or, if 
            the Value property of the outer IValueProvider is null, will be empty.
            
            Any change events from the outer layer will be translated into 'reset' events for the result sequence. Any change events from the inner
            layer will passed directly to the result sequence.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.AsEnumerable``1(Obtics.Values.IValueProvider{``0})">
            <summary>
            Represents an <see cref="T:Obtics.Values.IValueProvider`1"/> as a sequence with exactly one item. This item is equal to the value of the Value property of the source.
            </summary>
            <typeparam name="TSource">The type of the Value of the source and the type of the elements of the result enumerable.</typeparam>
            <param name="source">An <see cref="T:Obtics.Values.IValueProvider`1"/> to take the Value from.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, with the value of the Value property of <paramref name="source"/> as it's one and only element, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.AsEnumerable``1(Obtics.Values.IValueProvider{``0},System.Func{``0,System.Boolean})">
            <summary>
            Represents an <see cref="T:Obtics.Values.IValueProvider`1"/> as an sequence with exactly one item. This item is equal to the value of the Value property of the source.
            </summary>
            <typeparam name="TSource">The type of the Value of the source and the type of the elements of the result enumerable.</typeparam>
            <param name="source">An <see cref="T:Obtics.Values.IValueProvider`1"/> to take the Value from.</param>
            <param name="predicate">A delegate that returns true if the result collection should have a member and false if it should not.</param>
            <returns>an <see cref="T:System.Collections.Generic.IEnumerable`1"/>, with the value of the Value property of <paramref name="source"/> as it's one possible element, or null when <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.ReturnPath``1(Obtics.Values.IValueProvider{``0},System.Action{``0,System.Boolean},Obtics.Values.IValueProvider{System.Boolean})">
            <summary>
            Extends an <see cref="T:Obtics.Values.IValueProvider`1"/> with a value return path and allows control over the <see cref="P:Obtics.Values.IValueProvider.IsReadOnly"/> property.
            </summary>
            <typeparam name="TType">The type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the source and result <see cref="T:Obtics.Values.IValueProvider`1"/>.</typeparam>
            <param name="source">The <see cref="T:Obtics.Values.IValueProvider`1"/> that is going to be extended with a return path.</param>
            <param name="setValueAction">The action that needs to be taken when a client calls the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property setter.</param>
            <param name="isReadOnly">An <see cref="T:Obtics.Values.IValueProvider`1"/> that determines the value of the <see cref="P:Obtics.Values.IValueProvider.IsReadOnly"/> property of the result <see cref="T:Obtics.Values.IValueProvider`1"/>.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, with an implementation for the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property setter and controled value for the <see cref="P:Obtics.Values.IValueProvider.IsReadOnly"/> property, or null when either <paramref name="source"/>, <paramref name="setValueAction"/> or <paramref name="isReadOnly"/> is null.</returns>
            <remarks>The <paramref name="setValueAction"/> delegate is called whenever a client calls the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property setter of the result, regardless of the value of its <see cref="P:Obtics.Values.IValueProvider.IsReadOnly"/> property.
            Any appropriate action needs to be taken by the delegate. Raising an <see cref="T:System.Data.ReadOnlyException"/> would be an appropriate response if <see cref="P:Obtics.Values.IValueProvider.IsReadOnly"/> is true.</remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.ReturnPath``1(Obtics.Values.IValueProvider{``0},System.Action{``0},Obtics.Values.IValueProvider{System.Boolean})">
            <summary>
            Extends an <see cref="T:Obtics.Values.IValueProvider`1"/> with a value return path and allows control over the <see cref="P:Obtics.Values.IValueProvider.IsReadOnly"/> property.
            </summary>
            <typeparam name="TType">The type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the source and result <see cref="T:Obtics.Values.IValueProvider`1"/>.</typeparam>
            <param name="source">The <see cref="T:Obtics.Values.IValueProvider`1"/> that is going to be extended with a return path.</param>
            <param name="setValueAction">The action that needs to be taken when a client calls the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property setter.</param>
            <param name="isReadOnly">An <see cref="T:Obtics.Values.IValueProvider`1"/> that determines the value of the <see cref="P:Obtics.Values.IValueProvider.IsReadOnly"/> property of the result <see cref="T:Obtics.Values.IValueProvider`1"/>.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, with an implementation for the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property setter and controled value for the <see cref="P:Obtics.Values.IValueProvider.IsReadOnly"/> property, or null when either <paramref name="source"/>, <paramref name="setValueAction"/> or <paramref name="isReadOnly"/> is null.</returns>
            <remarks>The <paramref name="setValueAction"/> delegate is called whenever a client calls the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property setter of the result, regardless of the value of its <see cref="P:Obtics.Values.IValueProvider.IsReadOnly"/> property.
            Any appropriate action needs to be taken by the delegate. Raising an <see cref="T:System.Data.ReadOnlyException"/> would be an appropriate response if <see cref="P:Obtics.Values.IValueProvider.IsReadOnly"/> is true.</remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.ReturnPath``1(Obtics.Values.IValueProvider{``0},System.Action{``0})">
            <summary>
            Extends an <see cref="T:Obtics.Values.IValueProvider`1"/> with a value return path.
            </summary>
            <typeparam name="TType">The type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the source and result <see cref="T:Obtics.Values.IValueProvider`1"/>.</typeparam>
            <param name="source">The <see cref="T:Obtics.Values.IValueProvider`1"/> that is going to be extended with a return path.</param>
            <param name="setValueAction">The action that needs to be taken when a client calls the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property setter.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, with an implementation for the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property setter and an <see cref="P:Obtics.Values.IValueProvider.IsReadOnly"/> property whose value will always be false, or null when either <paramref name="source"/> or <paramref name="setValueAction"/> is null.</returns>
            <remarks>The value of the <see cref="P:Obtics.Values.IValueProvider.IsReadOnly"/> property of the result will always be false.</remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.GetValueOrDefault``1(Obtics.Values.IValueProvider{``0})">
            <summary>
            Retrieves the value of the current <see cref="T:Obtics.Values.IValueProvider`1"/> object, or a default value when the object reference is null.
            </summary>
            <typeparam name="TSource">Type of the Value property of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:Obtics.Values.IValueProvider`1"/> whose value to get.</param>
            <returns>The value of <paramref name="source"/> or default(<typeparamref name="TSource"/>) when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.GetValueOrDefault``1(Obtics.Values.IValueProvider{``0},``0)">
            <summary>
            Retrieves the value of the current <see cref="T:Obtics.Values.IValueProvider`1"/> object, or a sprecified default value when the object reference is null.
            </summary>
            <typeparam name="TSource">Type of the Value property of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:Obtics.Values.IValueProvider`1"/> whose value to get.</param>
            <param name="defaultValue">The default value to return when <paramref name="source"/> is null.</param>
            <returns>The value of <paramref name="source"/> or <paramref name="defaultValue"/> when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Dynamic``1(``0)">
            <summary>
            Creates a dynamic <see cref="T:Obtics.Values.IValueProvider`1"/>. An IValueProvider who's Value can be read and set.
            </summary>
            <typeparam name="TType">Type of the <paramref name="value"/> parameter and type of the Value of the returned IValueProvider.</typeparam>
            <param name="value">Initalization value</param>
            <returns>A dynamic <see cref="T:Obtics.Values.IValueProvider`1"/> with inital value as given by parameter <paramref name="value"/>.</returns>
            <remarks>
            Since the returned object is not a static value each returned object is unique. This means that
            <code>Object.Equals(ValueProvider.Dynamic(10),ValueProvider.Dynamic(10))</code>
            will always return false.
            This also means that any transformation pipeline depending on it will be unique.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Dynamic``1">
            <summary>
            Creates a dynamic <see cref="T:Obtics.Values.IValueProvider`1"/> initialized with the default value of <typeparamref name="TType"/>. An IValueProvider who's Value can be read and set.
            </summary>
            <typeparam name="TType">Type of the <paramref name="value"/> parameter and type of the Value of the returned IValueProvider.</typeparam>
            <returns>A dynamic <see cref="T:Obtics.Values.IValueProvider`1"/> with initial value default(<typeparamref name="TType"/>).</returns>
            <remarks>
            Since the returned object is not a static value each returned object is unique. This means that
            <code>Object.Equals(ValueProvider.Dynamic&lt;int&gt;(),ValueProvider.Dynamic&lt;int&gt;())</code>
            will always return false.
            This also means that any transformation pipeline depending on it will be unique.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Static``1(``0)">
            <summary>
            Creates a static (ReadOnly) <see cref="T:Obtics.Values.IValueProvider`1"/> object with Value property set to the passes <paramref name="value"/> parameter. 
            </summary>
            <typeparam name="TType">The type of the Value property of the returned IValueProvider and the type of the <paramref name="value"/> parameter</typeparam>
            <param name="value">The <typeparamref name="TType"/> value the return <see cref="T:Obtics.Values.IValueProvider`1"/> is initialized with.</param>
            <returns>A static (ReadOnly) <see cref="T:Obtics.Values.IValueProvider`1"/> object with Value property set to the passes <paramref name="value"/> parameter.</returns>
            <remarks>
            The following statement will always return true
            <code>EqualityComparer&lt;TType&gt;.Default.Compare(v1,v2) == Object.Equals(ValueProvider.Static(v1),ValueProvider.Static(v2))</code>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ValueProvider.MapFrame``1(Obtics.Values.IValueProvider)">
            <summary>
            This method is for internal use and is not intended to be used from client code.
            </summary>
            <typeparam name="TType"></typeparam>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Coalesce``1(``0,``0)">
            <summary>
            Returns the value of an input parameter or a fallback value if this value is null.
            </summary>
            <typeparam name="TType">Type of <paramref name="parameter"/>, <paramref name="fallback"/> and the Value property of the returned <see cref="T:Obtics.Values.IValueProvider`1"/>.</typeparam>
            <param name="parameter">The value to return if not null.</param>
            <param name="fallback">The fallback value to return when the Value property of <paramref name="parameter"/> is null.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives <paramref name="parameter"/> if not null or <paramref name="fallback"/> otherwise.</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Coalesce``1(Obtics.Values.IValueProvider{``0},``0)">
            <summary>
            Returns the value of an input parameter or a fallback value if this value is null.
            </summary>
            <typeparam name="TType">Type of the Value property of <paramref name="parameter"/>.</typeparam>
            <param name="parameter">AN <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value will be returned.</param>
            <param name="fallback">The fallback value to return when the Value property of <paramref name="parameter"/> is null.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the Value property of <paramref name="parameter"/> or <paramref name="fallback"/> if the Value property is null, or null when <paramref name="parameter"/> is null.</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Coalesce``1(``0,Obtics.Values.IValueProvider{``0})">
            <summary>
            Returns the value of an input parameter or a fallback value if this value is null.
            </summary>
            <typeparam name="TType">Type of <paramref name="parameter"/>, the Value property of <paramref name="fallback"/> and the Value property of the returned <see cref="T:Obtics.Values.IValueProvider`1"/>.</typeparam>
            <param name="parameter">The value to return if not null.</param>
            <param name="fallback">An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value gives the fallback value to return when the Value property of <paramref name="parameter"/> is null.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives <paramref name="parameter"/> if not null or the Value property of <paramref name="fallback"/> otherwise.</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.Coalesce``1(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{``0})">
            <summary>
            Returns the value of an input parameter or a fallback value if this value is null.
            </summary>
            <typeparam name="TType">Type of the Value property of <paramref name="parameter"/>.</typeparam>
            <param name="parameter">An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value will be returned.</param>
            <param name="fallback">An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value gives the fallback value to return when the Value property of <paramref name="parameter"/> is null.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the Value property of <paramref name="parameter"/> or the Value property of <paramref name="fallback"/> if the Value property is null, or null when either <paramref name="parameter"/> or <paramref name="fallback"/> is null.</returns>
        </member>
        <member name="T:Obtics.Values.ValueProvider.DependencyPropertyGetter`1">
            <summary>
            struct that wraps a typed live DependencyObject reference and can retrieve live property values from the refered DependencyObject.
            </summary>
            <typeparam name="TObject">The type of the refered DependencyObject. The type is constrained to be a <see cref="T:System.Windows.DependencyObject"/> or derived class.</typeparam>
        </member>
        <member name="M:Obtics.Values.ValueProvider.DependencyPropertyGetter`1.#ctor(Obtics.Values.IValueProvider{`0})">
            <summary>
            Constructs an <see cref="T:Obtics.Values.ValueProvider.DependencyPropertyGetter`1"/> instance.
            </summary>
            <param name="obj">An <see cref="T:Obtics.Values.IValueProvider`1"/> of TObject that will become the wrapped live DependencyPropertyGetter reference.</param>
        </member>
        <member name="M:Obtics.Values.ValueProvider.DependencyPropertyGetter`1.Get``1(System.Windows.DependencyProperty)">
            <summary>
            Gets the live value of the indicated property from the wrapped live DependencyObject. 
            </summary>
            <typeparam name="TProperty">Type of the property.</typeparam>
            <param name="dependencyProperty">A <see cref="T:System.Windows.DependencyProperty"/> object that indicates the property to retrieve the value from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> of <typeparamref name="TProperty"/> representing the live value of the property indicated by <paramref name="dependencyProperty"/>.</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.DependencyPropertyGetter`1.Get``1(System.String)">
            <summary>
            Gets the live value of the indicated property from the wrapped live DependencyObject. 
            </summary>
            <typeparam name="TProperty">Type of the property.</typeparam>
            <param name="name">The name of the property to retrieve the value from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> of <typeparamref name="TProperty"/> representing the live value of the property indicated by <paramref name="name"/>.</returns>
        </member>
        <member name="T:Obtics.Values.ValueProvider.PropertyGetter`1">
            <summary>
            struct that wraps a typed live object reference and can retrieve live property values from the refered object.
            </summary>
            <typeparam name="TObject">The type of the refered object. This type is constrained to be a reference type.</typeparam>
        </member>
        <member name="M:Obtics.Values.ValueProvider.PropertyGetter`1.#ctor(Obtics.Values.IValueProvider{`0})">
            <summary>
            Constructs an <see cref="T:Obtics.Values.ValueProvider.PropertyGetter`1"/> instance.
            </summary>
            <param name="obj">An <see cref="T:Obtics.Values.IValueProvider`1"/> of TObject that will become the wrapped live object reference.</param>
        </member>
        <member name="M:Obtics.Values.ValueProvider.PropertyGetter`1.Get``1(System.Reflection.PropertyInfo)">
            <summary>
            Gets the live value of the indicated property from the wrapped live object. 
            </summary>
            <typeparam name="TProperty">Type of the property.</typeparam>
            <param name="propInfo">A <see cref="T:System.Reflection.PropertyInfo"/> object that indicates the property to retrieve the value from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> of <typeparamref name="TProperty"/> representing the live value of the property indicated by <paramref name="propInfo"/>.</returns>
        </member>
        <member name="M:Obtics.Values.ValueProvider.PropertyGetter`1.Get``1(System.String)">
            <summary>
            Gets the live value of the indicated property from the wrapped live object. 
            </summary>
            <typeparam name="TProperty">Type of the property.</typeparam>
            <param name="name">The name of the property to retrieve the value from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> of <typeparamref name="TProperty"/> representing the live value of the property indicated by <paramref name="name"/>.</returns>
        </member>
        <member name="T:Obtics.ObservableObjectBase">
            <summary>
            Ultimate base class for Collection and Value transformations.
            </summary>
            <typeparam name="TPrms">The type of the parameters struct.</typeparam>
            <remarks>
            Implements locking and a boolean flags mechanism. 
            </remarks>
        </member>
        <member name="T:Obtics.NCSourcedObjectToVE`2">
            <summary>
            Base class for <see cref="T:Obtics.NCSourcedObjectToVE`2"/> objects that are CollectionTransformations.
            </summary>
            <typeparam name="TOut">Type of the elements of the resulting sequence.</typeparam>
            <typeparam name="TPrms">Type of the paramters structure.</typeparam>
            <remarks>
            VE stands for versioned enumerable.
            </remarks>
        </member>
        <member name="T:Obtics.NCSourcedObject`1">
            <summary>
            Base class for NCObservableObjectBase objects that have INotifyChanged objects (INCEventArgs supliers)
            as sources.
            </summary>
            <typeparam name="TPrms"></typeparam>
        </member>
        <member name="T:Obtics.NCObservableObjectBase`1">
            <summary>
            Base class for objects that are INCEventArgs supliers. It has a scalable mechanism for event consumer
            registration.
            For one consumer it uses a simple reference to that consumer.
            For upto 32 consumers it uses an (upscaling) array of references.
            For 32 consumers and more it uses a hashtable.
            
            Each consumer can register only once with any NCObservableObjectBase instance.
            </summary>
            <typeparam name="TPrms"></typeparam>
        </member>
        <member name="T:Obtics.IReceiveChangeNotification">
            <summary>
            Basic interface for change notification consumer
            </summary>
        </member>
        <member name="M:Obtics.NCSourcedObject`1.GetSource(System.Int32)">
            <summary>
            Gets the source with index <paramref name="index"/>.
            </summary>
            <param name="index"></param>
            <remarks>
            No locking. Overrides should only refer to truly static data.
            
            Sources sequence should start with index 0 continous to the last. Should
            return null when no source can be found for the given index.
            </remarks>
        </member>
        <member name="M:Obtics.NCSourcedObject`1.UpdateNeedSourceChangedListener(System.Boolean,System.Boolean)">
            <summary>
            Gets called to update the HaveSourceCollectionChangedListener property
            </summary>
            <param name="newValue">The new value</param>
            <param name="oldValue">The old value</param>
            <remarks>
            The root implementation of this virtual method actually sets the property.
            
            No locking.. only accessed internaly
            </remarks>
        </member>
        <member name="M:Obtics.NCSourcedObject`1.ProcessSourceChangedNotification(System.Object,Obtics.INCEventArgs)">
            <summary>
            ProcessSourceCollectionChangedNotification abstract method
            </summary>
            <param name="sender">Sender of the event.</param>
            <param name="args">Event arguments.</param>
            <remarks>
            override in derived classes to implement ProcessSourceCollectionChangedNotification functionality
            
            No locking.. only accessed internaly
            </remarks>
        </member>
        <member name="P:Obtics.NCSourcedObject`1.NeedSourceChangedListener">
            <summary>
            True if we need source changed listeners
            </summary>
            <remarks>
            No locking.. only accessed internaly
            
            When this property gets set to true the object immediately registers for change events
            with all sources.
            
            When set to false it immediately unregisters.
            </remarks>
        </member>
        <member name="T:Obtics.Collections.ISequenceOrderQuality`1">
            <summary>
            Typed <see cref="T:Obtics.Collections.ISequenceOrderQuality"/> interface.
            </summary>
            <typeparam name="TType">Type of the sequence elements.</typeparam>
        </member>
        <member name="T:Obtics.Collections.ISequenceOrderQuality">
            <summary>
            Interface that gives information about the ordering quality of a sequence.
            </summary>
            <remarks>
            Usualy sequences ar ordered. Every element in the sequence has a particular index in the sequence
            and can be identified by this index. Element in the sequence are returned in ascending index order
            and the indexes are contiguous.
            
            This index information is extra information and therefore an extra weight to carry when doing transformations. 
            For many transformations this extra index information is less relevant or totally irrelevant.
            
            Sorting and any aggregate that does not depend on the order of elements (Min,Max,Sum,Average,All,Any,Contains,Count,LongCount).
            
            These transformations can request an 'unordered form' of their original sources. If possible this unordered form
            can ignore any order information in the source and therefore be lighter.
            
            The ordered form of a Where clause for example always needs to maintain a mapping with result items and indexes. Adding
            and removing of items from this mapping always require a lot of work on top of the memory overhead.
            Un unordered form can do away with this mapping and therefore consumes less memory and has less overhead. 
            </remarks>
        </member>
        <member name="T:Obtics.Collections.IVersionedEnumerable">
            <summary>
            IEnumerable override that also publishes version information.
            </summary>
            <remarks>
            When a class implements IVersionedEnumerable and also implements collection change notification
            it is required to do this via <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/>. Additionaly the CollectionChanged events need
            to pass an <see cref="T:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs"/> object as event argument.
            </remarks>
        </member>
        <member name="M:Obtics.Collections.IVersionedEnumerable.GetEnumerator">
            <summary>
            GetEnumerator override that returns an <see cref="T:Obtics.Collections.IVersionedEnumerator"/>.
            </summary>
            <returns>An <see cref="T:Obtics.Collections.IVersionedEnumerator"/> for this sequence.</returns>
        </member>
        <member name="P:Obtics.Collections.IVersionedEnumerable.ContentVersion">
            <summary>
            The version of the current content of the sequence.
            </summary>
            <remarks>
            In a multithreaded environment the returned ContentVersion may be outdated the moment it is returned.
            </remarks>
        </member>
        <member name="P:Obtics.Collections.ISequenceOrderQuality.UnorderedForm">
            <summary>
            Returns the unordered form of this sequence.
            </summary>
            <remarks>
            If IsMostUnordered is true this property should return this object. If IsMostUnordered
            is false it should return a different, unordered object.
            </remarks>
        </member>
        <member name="P:Obtics.Collections.ISequenceOrderQuality.IsMostUnordered">
            <summary>
            If this sequence object is unordered.
            </summary>
        </member>
        <member name="T:Obtics.Collections.IVersionedEnumerable`1">
            <summary>
            A typed override of the <see cref="T:Obtics.Collections.IVersionedEnumerable"/> interface.
            </summary>
            <typeparam name="TType">The type of the elements of the sequence.</typeparam>
            <remarks>
            When a class implements IVersionedEnumerable and also implements collection change notification
            it is required to do this via <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/>. Additionaly the CollectionChanged events need
            to pass an <see cref="T:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs"/> object as event argument.
            </remarks>
        </member>
        <member name="M:Obtics.Collections.IVersionedEnumerable`1.GetEnumerator">
            <summary>
            GetEnumerator override that returns an <see cref="T:Obtics.Collections.IVersionedEnumerator`1"/>.
            </summary>
            <returns>An <see cref="T:Obtics.Collections.IVersionedEnumerator`1"/> for this sequence.</returns>
        </member>
        <member name="P:Obtics.Collections.ISequenceOrderQuality`1.UnorderedForm">
            <summary>
            Returns the unordered form of this sequence.
            </summary>
        </member>
        <member name="M:Obtics.NCSourcedObjectToVE`2.System#Collections#Generic#IEnumerable{TOut}#GetEnumerator">
            <summary>
            GetEnumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:Obtics.NCSourcedObjectToVE`2.GetEnumerator">
            <summary>
            GetEnumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:Obtics.NCSourcedObjectToVE`2.ProtectedGetEnumerator">
            <summary>
            GetEnumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:Obtics.Collections.Transformations.PredictingAggregateBase`2">
            <summary>
            Base class for aggregates that can update their result values based on CollectionChange information.
            They only need to know how the collection changes instead of using the entire collection to
            recalculate the value.
            </summary>
            <typeparam name="TOut">The type of the calculated aggregate value.</typeparam>
            <typeparam name="TPrms">The type of the parameters struct.</typeparam>
        </member>
        <member name="T:Obtics.NCSourcedObjectToVP`2">
            <summary>
            Base class for <see cref="T:Obtics.NCSourcedObjectToVE`2"/> objects that are ValueTransformations.
            </summary>
            <typeparam name="TOut">Type of the Value property of the resulting IValueProvider.</typeparam>
            <typeparam name="TPrms">Type of the parameters structure.</typeparam>
            <remarks>
            VP stands for ValueProvider.
            </remarks>
        </member>
        <member name="F:Obtics.NCSourcedObjectToVP`2.ValuePropertyName">
            <summary>
            ValuePropertyName
            </summary>
        </member>
        <member name="P:Obtics.NCSourcedObjectToVP`2.Value">
            <summary>
            Value
            </summary>
        </member>
        <member name="M:Obtics.Collections.Transformations.PredictingAggregateBase`2.ProcessSourceCollectionChangedNotification(System.Object,Obtics.INCollectionChangedEventArgs)">
            <summary>
            Override in derived classes to implement processing of collection change notifications.
            </summary>
            <param name="args"></param>
            <param name="sender"></param>
        </member>
        <member name="T:Obtics.Collections.Transformations.AccumulativeAggregate`3">
            <summary>
            AccumulativeAggregate implementation
            </summary>
            <typeparam name="TIn">Type of the source elements</typeparam>
            <typeparam name="TAcc">Type of the accumumated value</typeparam>
            <typeparam name="TOut">Type of the returned value</typeparam>
        </member>
        <member name="T:Obtics.Collections.Transformations.AggregateBase`3">
            <summary>
            Base class for 'one-pass' aggragates. When the aggregate result needs to be recalculated
            the entire sequence needs to be queried.
            </summary>
            <typeparam name="TIn">Types of the elements of the source sequence.</typeparam>
            <typeparam name="TOut">Type of the result value.</typeparam>
            <typeparam name="TPrms">Type of the 'paramters' struct.</typeparam>
        </member>
        <member name="T:Obtics.Collections.ObservableEnumerable">
            <summary>
            Provides a set of static methods for reactively querying objects that implement <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            In most cases the results of these methods are observable.
            </summary>
            <remarks>
            <para>The methods in this class provide an implementation of the standard query operators for querying data sources that implement <see cref="T:System.Collections.Generic.IEnumerable`1"/>. The standard query operators are general purpose methods that follow the LINQ pattern and enable you to express traversal, filter, and projection operations over data in any .NET-based programming language.</para>
            <para>The majority of the methods in this class are defined as extension methods that extend <see cref="T:System.Collections.Generic.IEnumerable`1"/>. This means they can be called like an instance method on any object that implements <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</para>
            <para>Methods that are used in a query that returns a sequence of values do not consume the target data until the query object is enumerated. This is known as deferred execution.</para>
            <para>Most methods can take either a lambda function that returns an explicit result or a lambda function that returns a dynamic value provider of the result.
            In the first case the result of the method is static in regard to the result of the lambda and in the later case the result of the method will be reactive to updates of the value provider.
            These allows the developer to determine exactly what changes the result should be reactive to.</para>
            <para>The methods of this class can conflict with the methods in <see cref="T:System.Linq.Enumerable"/>. When both the System.Linq and Obtics.Collections namespaces are added
            to the namespace list of your source file, inline query syntax statements on IEnumerables will lead to ambiguity erros. </para>
            <para>There has been chosen not to make use of
            a token type (say IObservableEnumerable) to keep the ObservableEnumerable as interchangeable as possible with the Enumerable methods. An IObservableEnumerable type
            could have been used to disambiguate between <see cref="T:System.Linq.Enumerable"/> methods and <see cref="T:Obtics.Collections.ObservableEnumerable"/> methods, but would have caused
            problems when working with composed sequence types.</para>
            <para>The GroupBy method for example returns an IEnumerable&gt;IGrouping&gt;,&lt;&lt; type of object. Now if we were to use a token type then the result of
            the ObservableEnumerable variation would have been something lige IObservableEnumerable&gt;IObservableGrouping&gt;,&lt;&lt;. The problem is that this type can not be
            converted to IEnumerable&gt;IGrouping&gt;,&lt;&lt; by a simple up-cast. This would prevent the two GroupBy implementations from being interchangable.</para>
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Determines whether a sequence contains a specified element by using the default equality comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence in which to locate a value.</param>
            <param name="value">The value to locate in the sequence.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property will be true if the source sequence contains an element that has the specified value and false otherwise, or null if <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines whether a sequence contains a specified element by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence in which to locate a value.</param>
            <param name="value">The value to locate in the sequence.</param>
            <param name="comparer">An equality comparer to compare values.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property will be true if the source sequence contains an element that has the specified value and false otherwise, or null if either <paramref name="source"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},Obtics.Values.IValueProvider{``0})">
            <summary>
            Determines whether a sequence contains a specified element by using the default equality comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence in which to locate a value.</param>
            <param name="value">A <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the value to locate in the sequence.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property will be true if the source sequence contains an element that has the specified value and false otherwise, or null if either <paramref name="source"/> or <paramref name="value"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},Obtics.Values.IValueProvider{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines whether a sequence contains a specified element by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence in which to locate a value.</param>
            <param name="value">A <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the value to locate in the sequence.</param>
            <param name="comparer">An equality comparer to compare values.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property will be true if the source sequence contains an element that has the specified value and false otherwise, or null if either <paramref name="source"/>, <paramref name="value"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the sequence is empty.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The sequence to return a default value for if it is empty.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains default(<typeparamref name="TSource"/>) if source is empty and <paramref name="source"/> otherwise, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Returns the elements of the specified sequence or the specified value in a singleton collection if the sequence is empty.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The sequence to return the specified value for if it is empty.</param>
            <param name="defaultValue">The value to return if the sequence is empty.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains defaultValue if source is empty and <paramref name="source"/> otherwise, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},Obtics.Values.IValueProvider{``0})">
            <summary>
            Returns the elements of the specified sequence or the specified value in a singleton collection if the sequence is empty.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The sequence to return the specified value for if it is empty.</param>
            <param name="defaultValue">An <see cref="T:Obtics.Values.IValueProvider`1"/> who's Value property will give the value to return if the sequence is empty.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains defaultValue if source is empty and <paramref name="source"/> otherwise, or null when either <paramref name="source"/> or <paramref name="defaultValue"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the last element of a sequence or a default value if no such element can be found.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to return the last element of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property will give the element at the last position in the source sequence or default(<typeparamref name="TSource"/>) if the sequence is empty, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the last element of a sequence that satisfies a given condition or a default value if no such element can be found.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to return an element of.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property will give the last element that satisfies the condition in the source sequence or default(<typeparamref name="TSource"/>) if such an element can not be found, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Boolean}})">
            <summary>
            Returns the last element of a sequence that satisfies a given condition dynamicaly or a default value if no such element can be found.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to return an element of.</param>
            <param name="predicate">A function to test each element for a condition. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whoser boolean Value property indicates if a given element satisfies the condition.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property will give the last element that satisfies the condition in the source sequence or default(<typeparamref name="TSource"/>) if such an element can not be found, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Any``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether a sequence contains any elements.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The sequence to check for emptiness.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property is true if the source sequence contains any elements and false otherwise, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Determines whether any element of a sequence satisfies a condition.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence whose elements to apply the predicate to.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property is true if any elements in the source sequence pass the test in the specified
                predicate and false otherwise, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Boolean}})">
            <summary>
            Determines whether any element of a sequence satisfies a condition dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence whose elements to apply the predicate to.</param>
            <param name="predicate">A function to test each element for a condition. It returns na <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property indicates if the given value satisfies the condition.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property is true if any elements in the source sequence pass the test in the specified
                predicate and false otherwise, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})">
            <summary>
            Correlates the elements of two sequences based on matching keys. The default equality comparer is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first, outer sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second, inner sequence.</typeparam>
            <typeparam name="TKey">The type of the keys return by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from two matching elements.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/>, that are obtained by performing an inner join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,``2},System.Func{``0,``1,``3})">
            <summary>
            Correlates the elements of two sequences based on matching keys dynamicaly. The default equality comparer is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first, outer sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second, inner sequence.</typeparam>
            <typeparam name="TKey">The type of the keys return by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key for the given element.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from two matching elements.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/>, that are obtained by performing an inner join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,Obtics.Values.IValueProvider{``2}},System.Func{``0,``1,``3})">
            <summary>
            Correlates the elements of two sequences based on matching keys dynamicaly. The default equality comparer is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first, outer sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second, inner sequence.</typeparam>
            <typeparam name="TKey">The type of the keys return by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key for the given element.</param>
            <param name="resultSelector">A function to create a result element from two matching elements.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/>, that are obtained by performing an inner join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,Obtics.Values.IValueProvider{``2}},System.Func{``0,``1,``3})">
            <summary>
            Correlates the elements of two sequences based on matching keys dynamicaly. The default equality comparer is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first, outer sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second, inner sequence.</typeparam>
            <typeparam name="TKey">The type of the keys return by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key for the given element.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key for the given element.</param>
            <param name="resultSelector">A function to create a result element from two matching elements.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/>, that are obtained by performing an inner join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,Obtics.Values.IValueProvider{``3}})">
            <summary>
            Correlates the elements of two sequences based on matching keys dynamicaly. The default equality comparer is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first, outer sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second, inner sequence.</typeparam>
            <typeparam name="TKey">The type of the keys return by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from two matching elements. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given elements.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/>, that are obtained by performing an inner join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,``2},System.Func{``0,``1,Obtics.Values.IValueProvider{``3}})">
            <summary>
            Correlates the elements of two sequences based on matching keys dynamicaly. The default equality comparer is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first, outer sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second, inner sequence.</typeparam>
            <typeparam name="TKey">The type of the keys return by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key for the given element.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from two matching elements. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given elements.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/>, that are obtained by performing an inner join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,Obtics.Values.IValueProvider{``2}},System.Func{``0,``1,Obtics.Values.IValueProvider{``3}})">
            <summary>
            Correlates the elements of two sequences based on matching keys dynamicaly. The default equality comparer is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first, outer sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second, inner sequence.</typeparam>
            <typeparam name="TKey">The type of the keys return by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key for the given element.</param>
            <param name="resultSelector">A function to create a result element from two matching elements. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given elements.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/>, that are obtained by performing an inner join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,Obtics.Values.IValueProvider{``2}},System.Func{``0,``1,Obtics.Values.IValueProvider{``3}})">
            <summary>
            Correlates the elements of two sequences based on matching keys dynamicaly. The default equality comparer is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first, outer sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second, inner sequence.</typeparam>
            <typeparam name="TKey">The type of the keys return by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key for the given element.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key for the given element.</param>
            <param name="resultSelector">A function to create a result element from two matching elements. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given elements.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/>, that are obtained by performing an inner join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on matching keys. A given <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first, outer sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second, inner sequence.</typeparam>
            <typeparam name="TKey">The type of the keys return by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from two matching elements.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to hash and compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/>, that are obtained by performing an inner join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on matching keys dynamicaly. A given <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first, outer sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second, inner sequence.</typeparam>
            <typeparam name="TKey">The type of the keys return by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key for the given element.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from two matching elements.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to hash and compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/>, that are obtained by performing an inner join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,Obtics.Values.IValueProvider{``2}},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on matching keys dynamicaly. A given <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first, outer sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second, inner sequence.</typeparam>
            <typeparam name="TKey">The type of the keys return by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key for the given element.</param>
            <param name="resultSelector">A function to create a result element from two matching elements.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to hash and compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/>, that are obtained by performing an inner join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,Obtics.Values.IValueProvider{``2}},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on matching keys dynamicaly. A given <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first, outer sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second, inner sequence.</typeparam>
            <typeparam name="TKey">The type of the keys return by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key for the given element.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key for the given element.</param>
            <param name="resultSelector">A function to create a result element from two matching elements.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to hash and compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/>, that are obtained by performing an inner join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,Obtics.Values.IValueProvider{``3}},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on matching keys dynamicaly. A given <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first, outer sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second, inner sequence.</typeparam>
            <typeparam name="TKey">The type of the keys return by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from two matching elements. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given elements.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to hash and compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/>, that are obtained by performing an inner join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,``2},System.Func{``0,``1,Obtics.Values.IValueProvider{``3}},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on matching keys dynamicaly. A given <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first, outer sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second, inner sequence.</typeparam>
            <typeparam name="TKey">The type of the keys return by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key for the given element.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from two matching elements. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given elements.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to hash and compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/>, that are obtained by performing an inner join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,Obtics.Values.IValueProvider{``2}},System.Func{``0,``1,Obtics.Values.IValueProvider{``3}},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on matching keys dynamicaly. A given <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first, outer sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second, inner sequence.</typeparam>
            <typeparam name="TKey">The type of the keys return by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key for the given element.</param>
            <param name="resultSelector">A function to create a result element from two matching elements. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given elements.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to hash and compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/>, that are obtained by performing an inner join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,Obtics.Values.IValueProvider{``2}},System.Func{``0,``1,Obtics.Values.IValueProvider{``3}},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on matching keys dynamicaly. A given <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first, outer sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second, inner sequence.</typeparam>
            <typeparam name="TKey">The type of the keys return by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key for the given element.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key for the given element.</param>
            <param name="resultSelector">A function to create a result element from two matching elements. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given elements.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to hash and compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has elements of type <typeparamref name="TResult"/>, that are obtained by performing an inner join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Single``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return an element from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the first element in the sequence or default(<typeparamref name="TSource"/>) if no such element is found, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the first element in a sequence that satisfies a specified condition or a default value if no such element is found.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return an element from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the first element in the sequence that passes the test in the specified predicate function or default(<typeparamref name="TSource"/>) if no such element is found, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Boolean}})">
            <summary>
            Returns the first element in a sequence that satisfies a specified condition dynamicaly or a default value if no such element is found.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return an element from.</param>
            <param name="predicate">A function to test each element for a condition. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Boolean"/> Value property indicates if the given element satisfies the condition.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the first element in the sequence that passes the test in the specified predicate function or default(<typeparamref name="TSource"/>) if no such element is found, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return an element from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the first element in the sequence or default(<typeparamref name="TSource"/>) if no such element is found, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the first element in a sequence that satisfies a specified condition or a default value if no such element is found.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return an element from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the first element in the sequence that passes the test in the specified predicate function or default(<typeparamref name="TSource"/>) if no such element is found, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Boolean}})">
            <summary>
            Returns the first element in a sequence that satisfies a specified condition dynamicaly or a default value if no such element is found.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return an element from.</param>
            <param name="predicate">A function to test each element for a condition. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Boolean"/> Value property indicates if the given element satisfies the condition.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the first element in the sequence that passes the test in the specified predicate function or default(<typeparamref name="TSource"/>) if no such element is found, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Sorts the elements of a sequence in ascending order according to a key using the default comparer for the key type.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">Type of the key as returned by <paramref name="keySelector"/>.</typeparam>
            <param name="source">The sequence of values to sort.</param>
            <param name="keySelector">A function to extract a key from an element.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Sorts the elements of a sequence in ascending order according to a key using a given <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">Type of the key as returned by <paramref name="keySelector"/>.</typeparam>
            <param name="source">The sequence of values to sort.</param>
            <param name="keySelector">A function to extract a key from an element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to comparer key values.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted to a key, or null when either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}})">
            <summary>
            Sorts the elements of a sequence in ascending order according to a key dynamicaly using the default comparer for the key type.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">Type of the key as returned by <paramref name="keySelector"/>.</typeparam>
            <param name="source">The sequence of values to sort.</param>
            <param name="keySelector">A function to extract a key from an element. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to order the given element by.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Sorts the elements of a sequence in ascending order according to a key dynamicaly using a given <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">Type of the key as returned by <paramref name="keySelector"/>.</typeparam>
            <param name="source">The sequence of values to sort.</param>
            <param name="keySelector">A function to extract a key from an element. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to order the given element by.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to comparer key values.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted to a key, or null when either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
             <summary>
             Computes the sum of a sequence of nullable <see cref="T:System.Decimal"/> values.
             </summary>
             <param name="source">A sequence of nullable <see cref="T:System.Decimal"/> values to calculate the sum of.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property is the sum of the sequence of values, or null when <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum(System.Collections.Generic.IEnumerable{System.Decimal})">
             <summary>
             Computes the sum of a sequence of <see cref="T:System.Decimal"/> values.
             </summary>
             <param name="source">A sequence of <see cref="T:System.Decimal"/> values to calculate the sum of.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property is the sum of the sequence of values, or null when <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
             <summary>
             Computes the sum of a sequence of nullable <see cref="T:System.Double"/> values.
             </summary>
             <param name="source">A sequence of nullable <see cref="T:System.Double"/> values to calculate the sum of.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum(System.Collections.Generic.IEnumerable{System.Double})">
             <summary>
             Computes the sum of a sequence of <see cref="T:System.Double"/> values.
             </summary>
             <param name="source">A sequence of <see cref="T:System.Double"/> values to calculate the sum of.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
             <summary>
             Computes the sum of a sequence of nullable <see cref="T:System.Single"/> values.
             </summary>
             <param name="source">A sequence of nullable <see cref="T:System.Single"/> values to calculate the sum of.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum(System.Collections.Generic.IEnumerable{System.Single})">
             <summary>
             Computes the sum of a sequence of <see cref="T:System.Single"/> values.
             </summary>
             <param name="source">A sequence of <see cref="T:System.Single"/> values to calculate the sum of.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
             <summary>
             Computes the sum of a sequence of nullable <see cref="T:System.Int32"/> values.
             </summary>
             <param name="source">A sequence of nullable <see cref="T:System.Int32"/> values to calculate the sum of.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum(System.Collections.Generic.IEnumerable{System.Int32})">
             <summary>
             Computes the sum of a sequence of <see cref="T:System.Int32"/> values.
             </summary>
             <param name="source">A sequence of <see cref="T:System.Int32"/> values to calculate the sum of.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
             <summary>
             Computes the sum of a sequence of nullable <see cref="T:System.Int64"/> values.
             </summary>
             <param name="source">A sequence of nullable <see cref="T:System.Int64"/> values to calculate the sum of.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum(System.Collections.Generic.IEnumerable{System.Int64})">
             <summary>
             Computes the sum of a sequence of <see cref="T:System.Int64"/> values.
             </summary>
             <param name="source">A sequence of <see cref="T:System.Int64"/> values to calculate the sum of.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
             <summary>
             Computes the sum of a sequence of nullable <see cref="T:System.Decimal"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Decimal"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
             <summary>
             Computes the sum of a sequence of <see cref="T:System.Decimal"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Decimal"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
             <summary>
             Computes the sum of a sequence of nullable <see cref="T:System.Double"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Double"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
             <summary>
             Computes the sum of a sequence of <see cref="T:System.Double"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Double"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
             <summary>
             Computes the sum of a sequence of nullable <see cref="T:System.Single"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Single"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
             <summary>
             Computes the sum of a sequence of <see cref="T:System.Single"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Single"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
             <summary>
             Computes the sum of a sequence of nullable <see cref="T:System.Int32"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Int32"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.
                 empty or contains only values that are null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
             <summary>
             Computes the sum of a sequence of <see cref="T:System.Int32"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Int32"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
             <summary>
             Computes the sum of a sequence of nullable <see cref="T:System.Int64"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Int64"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
             <summary>
             Computes the sum of a sequence of <see cref="T:System.Int64"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Int64"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>A <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Decimal}}})">
             <summary>
             Computes the sum of a sequence of nullable <see cref="T:System.Decimal"/> values that
                 are obtained dynamicaly by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Decimal"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose nullable <see cref="T:System.Decimal"/> Value property gives the value to add to the total sum for the given element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Decimal}})">
             <summary>
             Computes the sum of a sequence of <see cref="T:System.Decimal"/> values that
                 are obtained dynamicaly by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Decimal"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Decimal"/> Value property gives the value to add to the total sum for the given element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Double}}})">
             <summary>
             Computes the sum of a sequence of nullable <see cref="T:System.Double"/> values that
                 are obtained dynamicaly by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Double"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose nullable <see cref="T:System.Double"/> Value property gives the value to add to the total sum for the given element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Double}})">
             <summary>
             Computes the sum of a sequence of <see cref="T:System.Double"/> values that
                 are obtained dynamicaly by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Double"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Double"/> Value property gives the value to add to the total sum for the given element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Single}}})">
             <summary>
             Computes the sum of a sequence of nullable <see cref="T:System.Single"/> values that
                 are obtained dynamicaly by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Single"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose nullable <see cref="T:System.Single"/> Value property gives the value to add to the total sum for the given element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Single}})">
             <summary>
             Computes the sum of a sequence of <see cref="T:System.Single"/> values that
                 are obtained dynamicaly by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Single"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Single"/> Value property gives the value to add to the total sum for the given element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Int32}}})">
             <summary>
             Computes the sum of a sequence of nullable <see cref="T:System.Int32"/> values that
                 are obtained dynamicaly by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Int32"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose nullable <see cref="T:System.Int32"/> Value property gives the value to add to the total sum for the given element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Int32}})">
             <summary>
             Computes the sum of a sequence of <see cref="T:System.Int32"/> values that
                 are obtained dynamicaly by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Int32"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Int32"/> Value property gives the value to add to the total sum for the given element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Int64}}})">
             <summary>
             Computes the sum of a sequence of nullable <see cref="T:System.Int64"/> values that
                 are obtained dynamicaly by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Int64"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose nullable <see cref="T:System.Int64"/> Value property gives the value to add to the total sum for the given element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Int64}})">
             <summary>
             Computes the sum of a sequence of <see cref="T:System.Int64"/> values that
                 are obtained dynamicaly by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Int64"/> values to calculate the sum of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Int64"/> Value property gives the value to add to the total sum for the given element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the sum of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Concatenates two sequences
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">The first sequence to concatenate.</param>
            <param name="second">The sequence to concatenate to the first sequence.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the concatenated elements of the two input sequences, or null when either <paramref name="first"/> or <paramref name="second"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Concat``1(System.Collections.Generic.IEnumerable{Obtics.Collections.IVersionedEnumerable{``0}})">
            <summary>
            Concatenates all sequences in a sequence of child sequences.
            </summary>
            <typeparam name="TSource">The type of the elements of the child sequences.</typeparam>
            <param name="source">The sequence to concatenate to the child sequences of.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the concatenated elements of the child sequences of the input sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Concat``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Concatenates all sequences in a sequence of child sequences.
            </summary>
            <typeparam name="TSource">The type of the elements of the child sequences.</typeparam>
            <param name="source">The sequence to concatenate to the child sequences of.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the concatenated elements of the child sequences of the input sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Concat``2(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{``0,``1}})">
            <summary>
            Concatenates all elements in a sequence of groupings.
            </summary>
            <typeparam name="TElement">The type of the elements of the grouping-elements of the input sequence.</typeparam>
            <typeparam name="TKey">The type of the keys of the grouping-elements of the input sequence.</typeparam>
            <param name="source">The sequence of groupings to concatenate.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the concatenated elements of the groups, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Concat``1(System.Collections.Generic.IEnumerable{System.Linq.IOrderedEnumerable{``0}})">
            <summary>
            Concatenates all sequences in a sequence of sequences.
            </summary>
            <typeparam name="TSource">The type of the elements of the child sequences.</typeparam>
            <param name="source">The sequence to concatenate to the child sequences of.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the concatenated elements of the child sequences of the input sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Concat``1(System.Collections.Generic.IEnumerable{Obtics.Collections.IObservableOrderedEnumerable{``0}})">
            <summary>
            Concatenates all sequences in a sequence of sequences.
            </summary>
            <typeparam name="TSource">The type of the elements of the child sequences.</typeparam>
            <param name="source">The sequence to concatenate to the child sequences of.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the concatenated elements of the child sequences of the input sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Last``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the last element of a sequence or a default value if no such element can be found.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to return the last element of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property will give the element at the last position in the source sequence or default(<typeparamref name="TSource"/>) if the sequence is empty, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Last``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the last element of a sequence that satisfies a given condition or a default value if no such element can be found.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to return an element of.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property will give the last element that satisfies the condition in the source sequence or default(<typeparamref name="TSource"/>) if such an element can not be found, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Last``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Boolean}})">
            <summary>
            Returns the last element of a sequence that satisfies a given condition dynamicaly or a default value if no such element can be found.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to return an element of.</param>
            <param name="predicate">A function to test each element for a condition. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whoser boolean Value property indicates if a given element satisfies the condition.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property will give the last element that satisfies the condition in the source sequence or default(<typeparamref name="TSource"/>) if such an element can not be found, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether two sequences are equal by comparing the elements by using the default equality comparer for their type.
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">The first sequence to compare.</param>
            <param name="second">The second sequence to compare.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property will be true if the two source sequences are of equal element by element according to the default equality comparer for their type and false otherwise, or null when either <paramref name="first"/> or <paramref name="second"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines whether two sequences are equal by comparing their elements by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">The first sequence to compare.</param>
            <param name="second">The second sequence to compare.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare elements with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property will be true if the two source sequences are of equal element by element according to the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> and false otherwise, or null when either <paramref name="first"/>, <paramref name="second"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns elements from a sequence as long as a specified condition is true.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <param name="source">The sequence to return elements from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the elements from the input sequence that occur before the element at which the test no longer passes, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Boolean}})">
            <summary>
            Returns elements from a sequence as long as a specified condition is true dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <param name="source">The sequence to return elements from.</param>
            <param name="predicate">A function to test each element for a condition. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whos <see cref="T:System.Boolean"/> Value property indicates if the given element satisfies the condition.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the elements from the input sequence that occur before the element at which the test no longer passes, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Returns elements from a sequence as long as a specified condition is true. The element's index is used in the logic of the predicate function.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <param name="source">The sequence to return elements from.</param>
            <param name="predicate">A function to test each element for a condition. The second parameter of the function represents the index of the source element.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements from the input sequence that occur before the element at which the test no longer passes, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,Obtics.Values.IValueProvider{System.Boolean}})">
            <summary>
            Returns elements from a sequence as long as a specified condition is true dynamicaly. The element's index is used in the logic of the predicate function.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <param name="source">The sequence to return elements from.</param>
            <param name="predicate">A function to test each element for a condition. The second parameter of the function represents the index of the source element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whos <see cref="T:System.Boolean"/> Value property indicates if the given element satisfies the condition.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements from the input sequence that occur before the element at which the test no longer passes, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableLookup`2"/> from an sequence according to a specified key selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <param name="source">A sequence to create a lookup from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableLookup`2"/>, that contains keys and values, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableLookup`2"/> from an sequence according to a specified key selector function and key comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <param name="source">A sequence to create a lookup from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to comparer keys.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableLookup`2"/>, that contains keys and values, or null when either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="comparer"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableLookup`2"/> from an sequence according to a specified dynamic key selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <param name="source">A sequence to create a lookup from.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to index the given element by.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableLookup`2"/>, that contains keys and values, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableLookup`2"/> from an sequence according to a specified dynamic key selector function and key comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <param name="source">A sequence to create a lookup from.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to index the given element by.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to comparer keys.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableLookup`2"/>, that contains keys and values, or null when either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="comparer"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableLookup`2"/> from an sequence according to a specified key selector and element selector functions.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector"/>.</typeparam>
            <param name="source">A sequence to create a lookup from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="elementSelector">A transform function to produce a result element value from each element.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableLookup`2"/>, that contains values of type TElement selected from the input sequence, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableLookup`2"/> from an sequence according to a specified key selector function, a comparer, and an element selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector"/>.</typeparam>
            <param name="source">A sequence to create a lookup from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="elementSelector">A transform function to produce a result element value from each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to comparer keys.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableLookup`2"/>, that contains values of type TElement selected from the input sequence, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,``2})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableLookup`2"/> from an sequence according to a specified dynamic key selector and element selector functions.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector"/>.</typeparam>
            <param name="source">A sequence to create a lookup from.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to index the given element by.</param>
            <param name="elementSelector">A transform function to produce a result element value from each element.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableLookup`2"/>, that contains values of type TElement selected from the input sequence, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableLookup`2"/> from an sequence according to a specified dynamic key selector function, a comparer, and an element selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector"/>.</typeparam>
            <param name="source">A sequence to create a lookup from.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to index the given element by.</param>
            <param name="elementSelector">A transform function to produce a result element value from each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to comparer keys.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableLookup`2"/>, that contains values of type TElement selected from the input sequence, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,Obtics.Values.IValueProvider{``2}})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableLookup`2"/> from an sequence according to a specified key selector and dynamic element selector functions.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector"/>.</typeparam>
            <param name="source">A sequence to create a lookup from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="elementSelector">A transform function to produce a result element value from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the result element to project the given element into.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableLookup`2"/>, that contains values of type TElement selected from the input sequence, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableLookup`2"/> from an sequence according to a specified key selector function, a comparer, and a dynamic element selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector"/>.</typeparam>
            <param name="source">A sequence to create a lookup from.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the result element to project the given element into.</param>
            <param name="elementSelector">A transform function to produce a result element value from each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to comparer keys.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableLookup`2"/>, that contains values of type TElement selected from the input sequence, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,Obtics.Values.IValueProvider{``2}})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableLookup`2"/> from an sequence according to a specified dynamic key selector and dynamic element selector functions.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector"/>.</typeparam>
            <param name="source">A sequence to create a lookup from.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to index the given element by.</param>
            <param name="elementSelector">A transform function to produce a result element value from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the result element to project the given element into.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableLookup`2"/>, that contains values of type TElement selected from the input sequence, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableLookup`2"/> from an sequence according to a specified dynamic key selector function, a comparer, and a dynamic element selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector"/>.</typeparam>
            <param name="source">A sequence to create a lookup from.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to index the given element by.</param>
            <param name="elementSelector">A transform function to produce a result element value from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the result element to project the given element into.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to comparer keys.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableLookup`2"/>, that contains values of type TElement selected from the input sequence, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Async``1(System.Collections.Generic.IEnumerable{``0},Obtics.Async.IWorkQueue)">
            <summary>
            Buffers contents of the source <see cref="T:System.Collections.Generic.IEnumerable`1"/> and propagates changes asynchronously using a specified work queue.
            </summary>
            <typeparam name="TType">The type of the elements of the input and result sequences.</typeparam>
            <param name="source">The sequence to buffer.</param>
            <param name="workQueue">The <see cref="T:Obtics.Async.IWorkQueue"/> to use.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that with respect to some asynchronous delay has the same contents as <paramref name="source"/>, or null when either <paramref name="source"/> or <paramref name="workQueue"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Async``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Buffers contents of the source <see cref="T:System.Collections.Generic.IEnumerable`1"/> and propagates changes asynchronously using the default work queue.
            </summary>
            <typeparam name="TType">The type of the elements of the input and result sequences.</typeparam>
            <param name="source">The sequence to buffer.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that with respect to some asynchronous delay has the same contents as <paramref name="source"/>, or null when <paramref name="source"/> is null.</returns>
            <remarks>The default work queue can be configured using the 'DefaultWorkQueueProvider' attribute of the 'Obtics' configuration section.</remarks>
            <seealso cref="P:Obtics.Async.WorkQueue.DefaultWorkQueueProvider"/>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Async``1(System.Collections.Generic.IEnumerable{``0},Obtics.Async.IWorkQueue,System.Int32)">
            <summary>
            Buffers contents of the source <see cref="T:System.Collections.Generic.IEnumerable`1"/> and propagates changes asynchronously using a specified work queue.
            </summary>
            <typeparam name="TType">The type of the elements of the input and result sequences.</typeparam>
            <param name="source">The sequence to buffer.</param>
            <param name="workQueue">The <see cref="T:Obtics.Async.IWorkQueue"/> to use.</param>
            <param name="dropOffPercentage">Percentage of the total sequence size that if the total sum of changes in the queue is greater than that ammount it will be compresed into 1 reset event.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that with respect to some asynchronous delay has the same contents as <paramref name="source"/>, or null when either <paramref name="source"/> or <paramref name="workQueue"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Async``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Buffers contents of the source <see cref="T:System.Collections.Generic.IEnumerable`1"/> and propagates changes asynchronously using the default work queue.
            </summary>
            <typeparam name="TType">The type of the elements of the input and result sequences.</typeparam>
            <param name="source">The sequence to buffer.</param>
            <param name="dropOffPercentage">Percentage of the total sequence size that if the total sum of changes in the queue is greater than that ammount it will be compresed into 1 reset event.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that with respect to some asynchronous delay has the same contents as <paramref name="source"/>, or null when <paramref name="source"/> is null.</returns>
            <remarks>The default work queue can be configured using the 'DefaultWorkQueueProvider' attribute of the 'Obtics' configuration section.</remarks>
            <seealso cref="P:Obtics.Async.WorkQueue.DefaultWorkQueueProvider"/>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Projects each element of a sequence into a new form.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TResult">The type of the value returned by selector.</typeparam>
            <param name="source">A sequence of values to invoke a transform function on.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the transform function on each element of source, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Select``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``0,``1,``2})">
            <summary>
            Projects each element of a sequence into a new form by incorporating an extra value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TValue">The type of the extra value.</typeparam>
            <typeparam name="TResult">The type of the value returned by selector.</typeparam>
            <param name="source">A sequence of values to invoke a transform function on.</param>
            <param name="value">A value to specialize the transformation function with.</param>
            <param name="selector">A transform function to apply to each element. The second parameter receives the given extra value.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the transform function on each element of source, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Select``4(System.Collections.Generic.IEnumerable{``0},``1,``2,System.Func{``0,``1,``2,``3})">
            <summary>
            Projects each element of a sequence into a new form by incorporating two extra values.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TValue1">The type of the first extra value.</typeparam>
            <typeparam name="TValue2">The type of the second extra value.</typeparam>
            <typeparam name="TResult">The type of the value returned by selector.</typeparam>
            <param name="source">A sequence of values to invoke a transform function on.</param>
            <param name="value1">The first value to specialize the transformation function with.</param>
            <param name="value2">The second value to specialize the transformation function with.</param>
            <param name="selector">A transform function to apply to each element. The second and third parameters receives the given first and second extra value respecively.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the transform function on each element of source, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Select``5(System.Collections.Generic.IEnumerable{``0},``1,``2,``3,System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Projects each element of a sequence into a new form by incorporating three extra values.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TValue1">The type of the first extra value.</typeparam>
            <typeparam name="TValue2">The type of the second extra value.</typeparam>
            <typeparam name="TValue3">The type of the third extra value.</typeparam>
            <typeparam name="TResult">The type of the value returned by selector.</typeparam>
            <param name="source">A sequence of values to invoke a transform function on.</param>
            <param name="value1">The first value to specialize the transformation function with.</param>
            <param name="value2">The second value to specialize the transformation function with.</param>
            <param name="value3">The third value to specialize the transformation function with.</param>
            <param name="selector">A transform function to apply to each element. The second, third and fourth parameters receives the given first, second and third extra value respecively.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the transform function on each element of source, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}})">
            <summary>
            Projects each element of a sequence into a new form dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TResult">The type of the value returned by selector.</typeparam>
            <param name="source">A sequence of values to invoke a transform function on.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result of the projection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the transform function on each element of source, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Select``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``0,``1,Obtics.Values.IValueProvider{``2}})">
            <summary>
            Projects each element of a sequence into a new form dynamicaly by incorporating an extra value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TValue">The type of the extra value.</typeparam>
            <typeparam name="TResult">The type of the value returned by selector.</typeparam>
            <param name="source">A sequence of values to invoke a transform function on.</param>
            <param name="value">A value to specialize the transformation function with.</param>
            <param name="selector">A transform function to apply to each element. The second parameter receives the given extra value. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result of the projection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the transform function on each element of source, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Select``4(System.Collections.Generic.IEnumerable{``0},``1,``2,System.Func{``0,``1,``2,Obtics.Values.IValueProvider{``3}})">
            <summary>
            Projects each element of a sequence into a new form dynamicaly by incorporating two extra values.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TValue1">The type of the first extra value.</typeparam>
            <typeparam name="TValue2">The type of the second extra value.</typeparam>
            <typeparam name="TResult">The type of the value returned by selector.</typeparam>
            <param name="source">A sequence of values to invoke a transform function on.</param>
            <param name="value1">The first value to specialize the transformation function with.</param>
            <param name="value2">The second value to specialize the transformation function with.</param>
            <param name="selector">A transform function to apply to each element. The second and third parameters receives the given first and second extra value respecively. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result of the projection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the transform function on each element of source, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Select``5(System.Collections.Generic.IEnumerable{``0},``1,``2,``3,System.Func{``0,``1,``2,``3,Obtics.Values.IValueProvider{``4}})">
            <summary>
            Projects each element of a sequence into a new form dynamicaly by incorporating three extra values.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TValue1">The type of the first extra value.</typeparam>
            <typeparam name="TValue2">The type of the second extra value.</typeparam>
            <typeparam name="TValue3">The type of the third extra value.</typeparam>
            <typeparam name="TResult">The type of the value returned by selector.</typeparam>
            <param name="source">A sequence of values to invoke a transform function on.</param>
            <param name="value1">The first value to specialize the transformation function with.</param>
            <param name="value2">The second value to specialize the transformation function with.</param>
            <param name="value3">The third value to specialize the transformation function with.</param>
            <param name="selector">A transform function to apply to each element. The second, third and fourth parameters receives the given first, second and third extra value respecively. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result of the projection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the transform function on each element of source, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})">
            <summary>
            Projects each element of a sequence into a new form by incorporating the element's index.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TResult">The type of the value returned by selector.</typeparam>
            <param name="source">A sequence of values to invoke a transform function on.</param>
            <param name="selector">A transform function to apply to each element. The second parameter is the index of the element in the sequence.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the transform function on each element of source, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Select``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``0,System.Int32,``1,``2})">
            <summary>
            Projects each element of a sequence into a new form by incorporating the element's index and an extra value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TValue">The type of the extra value.</typeparam>
            <typeparam name="TResult">The type of the value returned by selector.</typeparam>
            <param name="source">A sequence of values to invoke a transform function on.</param>
            <param name="value">A value to specialize the transformation function with.</param>
            <param name="selector">A transform function to apply to each element. The second parameter is the index of the element in the sequence and the third parameter receives the given extra value.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the transform function on each element of source, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Select``4(System.Collections.Generic.IEnumerable{``0},``1,``2,System.Func{``0,System.Int32,``1,``2,``3})">
            <summary>
            Projects each element of a sequence into a new form by incorporating the element's index and two extra values.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TValue1">The type of the first extra value.</typeparam>
            <typeparam name="TValue2">The type of the second extra value.</typeparam>
            <typeparam name="TResult">The type of the value returned by selector.</typeparam>
            <param name="source">A sequence of values to invoke a transform function on.</param>
            <param name="value1">The first value to specialize the transformation function with.</param>
            <param name="value2">The second value to specialize the transformation function with.</param>
            <param name="selector">A transform function to apply to each element. The second parameter is the index of the element in the sequence and the third and fourth parameters receive the given first and second extra values respectively.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the transform function on each element of source, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,Obtics.Values.IValueProvider{``1}})">
            <summary>
            Projects each element of a sequence into a new form dynamicaly by incorporating the element's index.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TResult">The type of the value returned by selector.</typeparam>
            <param name="source">A sequence of values to invoke a transform function on.</param>
            <param name="selector">A transform function to apply to each element. The second parameter is the index of the element in the sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result of the projection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the transform function on each element of source, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Select``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``0,System.Int32,``1,Obtics.Values.IValueProvider{``2}})">
            <summary>
            Projects each element of a sequence into a new form dynamicaly by incorporating the element's index and an extra value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TValue">The type of the extra value.</typeparam>
            <typeparam name="TResult">The type of the value returned by selector.</typeparam>
            <param name="source">A sequence of values to invoke a transform function on.</param>
            <param name="value">A value to specialize the transformation function with.</param>
            <param name="selector">A transform function to apply to each element. The second parameter is the index of the element in the sequence and the third parameter receives the given extra value. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result of the projection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the transform function on each element of source, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Select``4(System.Collections.Generic.IEnumerable{``0},``1,``2,System.Func{``0,System.Int32,``1,``2,Obtics.Values.IValueProvider{``3}})">
            <summary>
            Projects each element of a sequence into a new form dynamicaly by incorporating the element's index and two extra values.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TValue1">The type of the first extra value.</typeparam>
            <typeparam name="TValue2">The type of the second extra value.</typeparam>
            <typeparam name="TResult">The type of the value returned by selector.</typeparam>
            <param name="source">A sequence of values to invoke a transform function on.</param>
            <param name="value1">The first value to specialize the transformation function with.</param>
            <param name="value2">The second value to specialize the transformation function with.</param>
            <param name="selector">A transform function to apply to each element. The second parameter is the index of the element in the sequence and the third and fourth parameters receive the given first and second extra values respectively. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result of the projection.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the transform function on each element of source, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Removes duplicates from a sequence. Equality is determined using the default <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence</typeparam>
            <param name="source">The seqeuence to remove duplicates from</param>
            <returns>The sequence with all duplicates removed</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Removes duplicates from a sequence. Equality is determined using a given <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> object.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence.</typeparam>
            <param name="source">The seqeuence to remove duplicates from.</param>
            <param name="comparer">Equality comparer that determines if two items are equal and therefore are duplicates.</param>
            <returns>The sequence with all duplicates removed</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.First``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the first element of a sequence.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return an element from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the first element in the sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the first element in a sequence that satisfies a specified condition.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return an element from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the first element in the sequence that passes the test in the specified predicate function, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Boolean}})">
            <summary>
            Returns the first element in a sequence that satisfies a specified condition dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return an element from.</param>
            <param name="predicate">A function to test each element for a condition. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose boolean Value property indicates if the given element satisfies the condition.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the first element in the sequence that passes the test in the specified predicate function, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.OfType``1(System.Collections.IEnumerable)">
            <summary>
            Filters the elements of an <see cref="T:System.Collections.IEnumerable"/> based on a specified type.
            </summary>
            <typeparam name="TResult">The type to filter the elements of the sequence on.</typeparam>
            <param name="source">The sequence to filter.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, containing elements from the source sequence, or null if <paramref name="source"/> is null.</returns>
            <remarks>
            No true casting is performed. The elements must be instances of or instances of types derived from the requested type to pass through the filter.
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.OfType``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Casts the elements of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> up to a specified base type.
            </summary>
            <typeparam name="TResult">The type to cast the elements of the sequence up to.</typeparam>
            <typeparam name="TSource">The type of the sequence elements. This type is constrained to <typeparamref name="TSource"/> or types derived of <typeparamref name="TSource"/>.</typeparam>
            <param name="source">The sequence to filter.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, containing elements from the source sequence, or null if <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Inverts the order of the elements in a sequence.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to reverse.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements correspond to those of the input sequence in reverse order, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.AsEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the input typed as <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="TType">The type of the elements of source</typeparam>
            <param name="source">The sequence to type as <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</param>
            <returns>The input sequence typed as <see cref="T:System.Collections.Generic.IEnumerable`1"/>, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Produces the set difference of two sequences by using the default equality comparer to compare values.
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements that are not also in second will be returned.</param>
            <param name="second">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements that also occur in the first sequence will cause those elements to be removed from the returned sequence.</param>
            <returns>A sequence that contains the set difference of the elements of two sequences.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Produces the set difference of two sequences by using the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare values.
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements that are not also in second will be returned.</param>
            <param name="second">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements that also occur in the first sequence will cause those elements to be removed from the returned sequence.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare values.</param>
            <returns>A sequence that contains the set difference of the elements of two sequences.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return an element from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the first element in the sequence or default(<typeparamref name="TSource"/>) if no such element is found, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the first element in a sequence that satisfies a specified condition or a default value if no such element is found.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return an element from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the first element in the sequence that passes the test in the specified predicate function or default(<typeparamref name="TSource"/>) if no such element is found, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Boolean}})">
            <summary>
            Returns the first element in a sequence that satisfies a specified condition or a default value if no such element is found.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return an element from.</param>
            <param name="predicate">A function to test each element for a condition. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose boolean Value property indicates if the given element satisfies the condition.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the first element in the sequence that passes the test in the specified predicate function or default(<typeparamref name="TSource"/>) if no such element is found, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ThenByDescending``2(Obtics.Collections.IObservableOrderedEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in descending order according to a key.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="source">An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/> that contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted according to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ThenByDescending``2(Obtics.Collections.IObservableOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in descending order by using a given comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="source">An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/> that contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> used to compare key values.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted according to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ThenByDescending``2(Obtics.Collections.IObservableOrderedEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in descending order according to a key dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="source">An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/> that contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to order the given element by.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted according to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ThenByDescending``2(Obtics.Collections.IObservableOrderedEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in descending order dynamicaly by using a given comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="source">An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/> that contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> used to compare key values. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to order the given element by.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted according to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in descending order according to a key.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="source">An <see cref="T:System.Linq.IOrderedEnumerable`1"/> that contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1"/>, whose elements are sorted according to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
            <remarks>The result of this method will only be reactive and observable if source is in fact an <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>.</remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in descending order by using a given comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="source">An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/> that contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> used to compare key values.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted according to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
            <remarks>The result of this method will only be reactive and observable if source is in fact an <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>.</remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in descending order according to a key dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="source">An <see cref="T:System.Linq.IOrderedEnumerable`1"/> that contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to order the given element by.</param>
            <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1"/>, whose elements are sorted according to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
            <remarks>The result of this method will only be reactive and observable if source is in fact an <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>.</remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in descending order dynamicaly by using a given comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="source">An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/> that contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to order the given element by.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> used to compare key values.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted according to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
            <remarks>The result of this method will only be reactive and observable if source is in fact an <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>.</remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Unordered(Obtics.Collections.IVersionedEnumerable)">
            <summary>
            Gives an unordered form of the current sequence. This may be the same sequence.
            </summary>
            <param name="enumerable"></param>
            <returns>The most unordered form of the given sequence.</returns>
            <remarks>
            Of the given result: sequence.Unordered().IsMostUnordered() should return true;
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Unordered``1(Obtics.Collections.IVersionedEnumerable{``0})">
            <summary>
            Gives an unordered form of the current sequence. This may be the same sequence.
            </summary>
            <typeparam name="TElement">Type of the elements of the sequence.</typeparam>
            <param name="enumerable"></param>
            <returns>The most unordered form of the given sequence.</returns>
            <remarks>
            Of the given result: sequence.Unordered().IsMostUnordered() should return true;
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.IsMostUnordered(Obtics.Collections.IVersionedEnumerable)">
            <summary>
            Indicates if the give sequence is in it's most unordered form or not.
            </summary>
            <param name="enumerable"></param>
            <returns>boolean indicating that the current sequence is the most unordered that can be found.</returns>
            <remarks>
            Sequences that implement ISequenceOrderQuality are queried explicitly
            if they are most unordered or not. Any other sequences are regarded as
            'MostUnordered', meaning that there is no form that is less ordered than
            the given sequence.
            
            An unordered sequence has the potential to be cheaper since less information needs to be carried.
            
            Ordered sequences are valid input for unordered transformations. The other way
            arroung is not true.
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.PatchedUnordered``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Shorthand for .Patched().Unordered()
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Patched``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts the given sequence to a patched sequence that uses the internal event mechanism.
            </summary>
            <typeparam name="TElement">Type of the elements of the sequence.</typeparam>
            <param name="source">The source sequence to convert.</param>
            <returns></returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Patched(System.Collections.IEnumerable)">
            <summary>
            Converts an <see cref="T:System.Collections.IEnumerable"/> sequence to an <see cref="T:Obtics.Collections.IVersionedEnumerable"/> and / or
            an <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> to an <see cref="T:Obtics.INotifyChanged"/>.
            </summary>
            <param name="source"></param>
            <returns></returns>
            <remarks>
            The result needs to insert change order numbers. In a single threaded environment this is easy.
            We just make sure that our patch object is the ONLY obtics object listeningfor changes on the source.
            That means we can never get out of sync and we can just count the change events.
            
            In a multithreaded environment it is a little bit more complicated. New change events may arrive when our
            patch obect is still processing the last event. Sequence and change events may therefore go out of sync.
            We will need to maintain a snapshot copy of the contents of our source.
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IList`1"/> from a sequence.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The sequence to create a <see cref="T:System.Collections.Generic.IList`1"/> from.</param>
            <returns>A <see cref="T:System.Collections.Generic.IList`1"/> that contains elements from the input sequence.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns the element at a specified index in a sequence or a default value if the index is out of range.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return an element from.</param>
            <param name="index">The zero-based index of the element to retrieve.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the element at the specified position in the source sequence or null if <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},Obtics.Values.IValueProvider{System.Int32})">
            <summary>
            Returns the element at a specified index in a sequence or a default value if the index is out of range.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return an element from.</param>
            <param name="index">An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the zero-based index of the element to retrieve.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the element at the specified position in the source sequence or null if <paramref name="source"/> or <paramref name="index"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})">
            <summary>
            Correlates the elements of two sequences based on equality of keys and groups the results. The default equality comparer is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements of type <typeparamref name="TResult"/> that are obtained by performing a grouped join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})">
            <summary>
            Correlates the elements of two sequences based on equality of keys dynamicaly and groups the results. The default equality comparer is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to join by for the given element.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements of type <typeparamref name="TResult"/> that are obtained by performing a grouped join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,Obtics.Values.IValueProvider{``2}},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})">
            <summary>
            Correlates the elements of two sequences based on equality of keys dynamicaly and groups the results. The default equality comparer is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to join by for the given element.</param>
            <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements of type <typeparamref name="TResult"/> that are obtained by performing a grouped join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,Obtics.Values.IValueProvider{``2}},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})">
            <summary>
            Correlates the elements of two sequences based on equality of keys dynamicaly and groups the results. The default equality comparer is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to join by for the given element.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to join by for the given element.</param>
            <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements of type <typeparamref name="TResult"/> that are obtained by performing a grouped join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},Obtics.Values.IValueProvider{``3}})">
            <summary>
            Correlates the elements of two sequences based on equality of keys and groups the results dynamicaly. The default equality comparer is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence. It resturns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the grouping.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements of type <typeparamref name="TResult"/> that are obtained by performing a grouped join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},Obtics.Values.IValueProvider{``3}})">
            <summary>
            Correlates the elements of two sequences based on equality of keys dynamicaly and groups the results dynamicaly. The default equality comparer is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to join by for the given element.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence. It resturns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the grouping.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements of type <typeparamref name="TResult"/> that are obtained by performing a grouped join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,Obtics.Values.IValueProvider{``2}},System.Func{``0,System.Collections.Generic.IEnumerable{``1},Obtics.Values.IValueProvider{``3}})">
            <summary>
            Correlates the elements of two sequences based on equality of keys dynamicaly and groups the results dynamicaly. The default equality comparer is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to join by for the given element.</param>
            <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence. It resturns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the grouping.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements of type <typeparamref name="TResult"/> that are obtained by performing a grouped join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,Obtics.Values.IValueProvider{``2}},System.Func{``0,System.Collections.Generic.IEnumerable{``1},Obtics.Values.IValueProvider{``3}})">
            <summary>
            Correlates the elements of two sequences based on equality of keys dynamicaly and groups the results dynamicaly. The default equality comparer is used to compare keys.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to join by for the given element.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to join by for the given element.</param>
            <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence. It resturns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the grouping.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements of type <typeparamref name="TResult"/> that are obtained by performing a grouped join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on equality of keys and groups the results. Key values are compared by using a specified comparer.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements of type <typeparamref name="TResult"/> that are obtained by performing a grouped join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on equality of keys dynamicaly and groups the results. Key values are compared by using a specified comparer.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to join by for the given element.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements of type <typeparamref name="TResult"/> that are obtained by performing a grouped join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,Obtics.Values.IValueProvider{``2}},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on equality of keys dynamicaly and groups the results. Key values are compared by using a specified comparer.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to join by for the given element.</param>
            <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements of type <typeparamref name="TResult"/> that are obtained by performing a grouped join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,Obtics.Values.IValueProvider{``2}},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on equality of keys dynamicaly and groups the results. Key values are compared by using a specified comparer.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to join by for the given element.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to join by for the given element.</param>
            <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements of type <typeparamref name="TResult"/> that are obtained by performing a grouped join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},Obtics.Values.IValueProvider{``3}},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on equality of keys and groups the results dynamicaly. Key values are compared by using a specified comparer.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence. It resturns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the grouping.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements of type <typeparamref name="TResult"/> that are obtained by performing a grouped join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},Obtics.Values.IValueProvider{``3}},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on equality of keys dynamicaly and groups the results dynamicaly. Key values are compared by using a specified comparer.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to join by for the given element.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
            <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence. It resturns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the grouping.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements of type <typeparamref name="TResult"/> that are obtained by performing a grouped join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,Obtics.Values.IValueProvider{``2}},System.Func{``0,System.Collections.Generic.IEnumerable{``1},Obtics.Values.IValueProvider{``3}},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on equality of keys dynamicaly and groups the results dynamicaly. Key values are compared by using a specified comparer.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to join by for the given element.</param>
            <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence. It resturns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the grouping.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements of type <typeparamref name="TResult"/> that are obtained by performing a grouped join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,Obtics.Values.IValueProvider{``2}},System.Func{``0,System.Collections.Generic.IEnumerable{``1},Obtics.Values.IValueProvider{``3}},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on equality of keys dynamicaly and groups the results dynamicaly. Key values are compared by using a specified comparer.
            </summary>
            <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
            <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="outer">The first sequence to join.</param>
            <param name="inner">The sequence to join to the first sequence.</param>
            <param name="outerKeySelector">A function to extract the join key from each element of the first sequence. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to join by for the given element.</param>
            <param name="innerKeySelector">A function to extract the join key from each element of the second sequence. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to join by for the given element.</param>
            <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence. It resturns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the grouping.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements of type <typeparamref name="TResult"/> that are obtained by performing a grouped join on two sequences, or null when either <paramref name="outer"/>, <paramref name="inner"/>, <paramref name="outerKeySelector"/>, <paramref name="innerKeySelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Sorts the elements of a sequence in descending order according to a key using the default comparer for the key type.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">Type of the key as returned by <paramref name="keySelector"/>.</typeparam>
            <param name="source">The sequence of values to sort.</param>
            <param name="keySelector">A function to extract a key from an element.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Sorts the elements of a sequence in descending order according to a key using a given <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">Type of the key as returned by <paramref name="keySelector"/>.</typeparam>
            <param name="source">The sequence of values to sort.</param>
            <param name="keySelector">A function to extract a key from an element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to comparer key values.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted to a key, or null when either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}})">
            <summary>
            Sorts the elements of a sequence in descending order according to a key dynamicaly using the default comparer for the key type.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">Type of the key as returned by <paramref name="keySelector"/>.</typeparam>
            <param name="source">The sequence of values to sort.</param>
            <param name="keySelector">A function to extract a key from an element. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to order the given element by.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Sorts the elements of a sequence in descending order according to a key dynamicaly using a given <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">Type of the key as returned by <paramref name="keySelector"/>.</typeparam>
            <param name="source">The sequence of values to sort.</param>
            <param name="keySelector">A function to extract a key from an element. This returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to order the given element by.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to comparer key values.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted to a key, or null when either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Aggregate``1(System.Collections.IEnumerable,System.Func{``0})">
            <summary>
            Returns the value of a parameterless function when a sequence changes.
            </summary>
            <typeparam name="TResult">The type of the result of <paramref name="func"/> and the type of the Value property of the result.</typeparam>
            <param name="source">The sequence to monitor for changes.</param>
            <param name="func">A function whose result will be returned.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property will give the result of <paramref name="func"/> or null when either <paramref name="source"/> or <paramref name="func"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0},``1})">
            <summary>
            Applies an accumulator function over a sequence.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TResult">The type of the resulting value.</typeparam>
            <param name="source">The sequence to aggregate over.</param>
            <param name="func">An accumulator function to be invoked on the entire sequence.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property will give the result of <paramref name="func"/> or null when either <paramref name="source"/> or <paramref name="func"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})">
            <summary>
            Applies an accumulator function over a sequence.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">An IEnumerable&lt;T&gt; to aggregate over.</param>
            <param name="func">An accumulator function to be invoked on each element.</param>
            <returns>The final accumulator value.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})">
            <summary>
            Applies an accumulator function over a sequence. The specified seed value
                is used as the initial accumulator value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
            <param name="source">The IEnumerable&lt;T&gt; to aggregate over.</param>
            <param name="seed">The initial accumulator value.</param>
            <param name="func">An accumulator function to be invoked on each element.</param>
            <returns>The final accumulator value.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})">
            <summary>
            Applies an accumulator function over a sequence. The specified seed value
                is used as the initial accumulator value, and the specified function is used
                to select the result value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
            <typeparam name="TResult">The type of the resulting value.</typeparam>
            <param name="source">The IObservableEnumerable&lt;T&gt; to aggregate over.</param>
            <param name="seed">The initial accumulator value.</param>
            <param name="func">An accumulator function to be invoked on each element.</param>
            <param name="resultSelector">A function to transform the final accumulator value into the result value.</param>
            <returns>The transformed final accumulator value.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,Obtics.Values.IValueProvider{``2}})">
            <summary>
            Applies an accumulator function over a sequence. The specified seed value
                is used as the initial accumulator value, and the specified function is used
                to select the result value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
            <typeparam name="TResult">The type of the resulting value.</typeparam>
            <param name="source">The IObservableEnumerable&lt;T&gt; to aggregate over.</param>
            <param name="seed">The initial accumulator value.</param>
            <param name="func">An accumulator function to be invoked on each element.</param>
            <param name="resultSelector">A function to transform the final accumulator value into the result value.</param>
            <returns>The transformed final accumulator value.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TKey">The type of the key returned by keySelector.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <returns>A sequence of <see cref="T:System.Linq.IGrouping`2"/>, where each <see cref="T:System.Linq.IGrouping`2"/> object contains a sequence of objects and a key, or null if either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TKey">The type of the key returned by keySelector.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. This method returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element with.</param>
            <returns>An sequence of <see cref="T:System.Linq.IGrouping`2"/>, where each <see cref="T:System.Linq.IGrouping`2"/> object contains a sequence of objects and a key, or null if either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TKey">The type of the key returned by keySelector.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="resultSelector">A function to create a result value from each group.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and creates a result value from each group and its key.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TKey">The type of the key returned by keySelector.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element by.</param>
            <param name="resultSelector">A function to create a result value from each group.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},Obtics.Values.IValueProvider{``2}})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TKey">The type of the key returned by keySelector.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="resultSelector">A function to create a result value from each group. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given group.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``1,System.Collections.Generic.IEnumerable{``0},Obtics.Values.IValueProvider{``2}})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and creates a result value from each group and its key dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TKey">The type of the key returned by keySelector.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element by.</param>
            <param name="resultSelector">A function to create a result value from each group. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given group.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and projects the elements for each group by using a specified function.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>.</param>
            <returns>An IEnumerable&lt;<see cref="T:System.Linq.IGrouping`2"/>&gt;,where each <see cref="T:System.Linq.IGrouping`2"/> object contains a collection of objects of type <typeparamref name="TElement"/> and a key, or null when either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="elementSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,``2})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and projects the elements for each group by using a specified function.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element by.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>.</param>
            <returns>An IEnumerable&lt;<see cref="T:System.Linq.IGrouping`2"/>&gt;,where each <see cref="T:System.Linq.IGrouping`2"/> object contains a collection of objects of type <typeparamref name="TElement"/> and a key, or null when either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="elementSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,Obtics.Values.IValueProvider{``2}})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and projects the elements for each group by using a specified function dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the projection of the given source element.</param>
            <returns>An IEnumerable&lt;<see cref="T:System.Linq.IGrouping`2"/>&gt;,where each <see cref="T:System.Linq.IGrouping`2"/> object contains a collection of objects of type <typeparamref name="TElement"/> and a key, or null when either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="elementSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,Obtics.Values.IValueProvider{``2}})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and projects the elements for each group by using a specified function dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element by.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the projection of the given source element.</param>
            <returns>An IEnumerable&lt;<see cref="T:System.Linq.IGrouping`2"/>&gt;,where each <see cref="T:System.Linq.IGrouping`2"/> object contains a collection of objects of type <typeparamref name="TElement"/> and a key, or null when either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="elementSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. The elements of each group are projected by using a specified function.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>.</param>
            <param name="resultSelector">A function to create a result value from each group.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and creates a result value from each group and its key. The elements of each group are projected by using a specified function.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element by.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>.</param>
            <param name="resultSelector">A function to create a result value from each group.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. The elements of each group are projected by using a specified function dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the projection of the given source element.</param>
            <param name="resultSelector">A function to create a result value from each group.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and creates a result value from each group and its key. The elements of each group are projected by using a specified function dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element by.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the projection of the given source element.</param>
            <param name="resultSelector">A function to create a result value from each group.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},Obtics.Values.IValueProvider{``3}})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key dynamicaly. The elements of each group are projected by using a specified function.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>.</param>
            <param name="resultSelector">A function to create a result value from each group. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given group.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},Obtics.Values.IValueProvider{``3}})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and creates a result value from each group and its key dynamicaly. The elements of each group are projected by using a specified function.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element by.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>.</param>
            <param name="resultSelector">A function to create a result value from each group. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given group.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,System.Collections.Generic.IEnumerable{``2},Obtics.Values.IValueProvider{``3}})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key dynamicaly. The elements of each group are projected by using a specified function dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the projection of the given source element.</param>
            <param name="resultSelector">A function to create a result value from each group. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given group.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,System.Collections.Generic.IEnumerable{``2},Obtics.Values.IValueProvider{``3}})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and creates a result value from each group and its key dynamicaly. The elements of each group are projected by using a specified function dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element by.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the projection of the given source element.</param>
            <param name="resultSelector">A function to create a result value from each group. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given group.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and compares the keys by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TKey">The type of the key returned by keySelector.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>A sequence of <see cref="T:System.Linq.IGrouping`2"/>, where each <see cref="T:System.Linq.IGrouping`2"/> object contains a sequence of objects and a key, or null if either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and compares the keys by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TKey">The type of the key returned by keySelector.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. This method returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element with.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>An sequence of <see cref="T:System.Linq.IGrouping`2"/>, where each <see cref="T:System.Linq.IGrouping`2"/> object contains a sequence of objects and a key, or null if either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. The keys are compared by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TKey">The type of the key returned by keySelector.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="resultSelector">A function to create a result value from each group.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>,<paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and creates a result value from each group and its key. The keys are compared by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TKey">The type of the key returned by keySelector.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element by.</param>
            <param name="resultSelector">A function to create a result value from each group.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>,<paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},Obtics.Values.IValueProvider{``2}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key dynamicaly. The keys are compared by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TKey">The type of the key returned by keySelector.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="resultSelector">A function to create a result value from each group. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given group.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>,<paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``1,System.Collections.Generic.IEnumerable{``0},Obtics.Values.IValueProvider{``2}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and creates a result value from each group and its key dynamicaly. The keys are compared by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TKey">The type of the key returned by keySelector.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element by.</param>
            <param name="resultSelector">A function to create a result value from each group. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given group.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>,<paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and projects the elements for each group by using a specified function. The keys are compared by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>An IEnumerable&lt;<see cref="T:System.Linq.IGrouping`2"/>&gt;,where each <see cref="T:System.Linq.IGrouping`2"/> object contains a collection of objects of type <typeparamref name="TElement"/> and a key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and projects the elements for each group by using a specified function. The keys are compared by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element by.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>An IEnumerable&lt;<see cref="T:System.Linq.IGrouping`2"/>&gt;,where each <see cref="T:System.Linq.IGrouping`2"/> object contains a collection of objects of type <typeparamref name="TElement"/> and a key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and projects the elements for each group by using a specified function dynamicaly. The keys are compared by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the projection of the given source element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>An IEnumerable&lt;<see cref="T:System.Linq.IGrouping`2"/>&gt;,where each <see cref="T:System.Linq.IGrouping`2"/> object contains a collection of objects of type <typeparamref name="TElement"/> and a key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and projects the elements for each group by using a specified function dynamicaly. The keys are compared by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element by.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the projection of the given source element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>An IEnumerable&lt;<see cref="T:System.Linq.IGrouping`2"/>&gt;,where each <see cref="T:System.Linq.IGrouping`2"/> object contains a collection of objects of type <typeparamref name="TElement"/> and a key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. The elements of each group are projected by using a specified function. The keys are compared by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>.</param>
            <param name="resultSelector">A function to create a result value from each group.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and creates a result value from each group and its key. The elements of each group are projected by using a specified function. The keys are compared by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element by.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>.</param>
            <param name="resultSelector">A function to create a result value from each group.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. The elements of each group are projected by using a specified function dynamicaly. The keys are compared by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the projection of the given source element.</param>
            <param name="resultSelector">A function to create a result value from each group.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and creates a result value from each group and its key. The elements of each group are projected by using a specified function dynamicaly. The keys are compared by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element by.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the projection of the given source element.</param>
            <param name="resultSelector">A function to create a result value from each group.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},Obtics.Values.IValueProvider{``3}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key dynamicaly. The elements of each group are projected by using a specified function. The keys are compared by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>.</param>
            <param name="resultSelector">A function to create a result value from each group. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given group.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},Obtics.Values.IValueProvider{``3}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and creates a result value from each group and its key dynamicaly. The elements of each group are projected by using a specified function. The keys are compared by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element by.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>.</param>
            <param name="resultSelector">A function to create a result value from each group. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given group.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,System.Collections.Generic.IEnumerable{``2},Obtics.Values.IValueProvider{``3}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key dynamicaly. The elements of each group are projected by using a specified function dynamicaly. The keys are compared by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the projection of the given source element.</param>
            <param name="resultSelector">A function to create a result value from each group. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given group.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Func{``1,System.Collections.Generic.IEnumerable{``2},Obtics.Values.IValueProvider{``3}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function dynamicaly and creates a result value from each group and its key dynamicaly. The elements of each group are projected by using a specified function dynamicaly. The keys are compared by using a specified comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
            <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2"/>.</typeparam>
            <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose elements to group.</param>
            <param name="keySelector">A function to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to group the given element by.</param>
            <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2"/>. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the projection of the given source element.</param>
            <param name="resultSelector">A function to create a result value from each group. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given group.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.</param>
            <returns>A sequence of elements of type <typeparamref name="TResult"/>, where each element represents a projection over a group and its key, or null when either <paramref name="source"/>, <paramref name="keySelector"/>, <paramref name="elementSelector"/>, <paramref name="resultSelector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gives the number of items in a sequence as a <see cref="T:System.Int64"/> value.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence</typeparam>
            <param name="source">The sequence to count the number of items of</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the number of items in the sequence, or null if <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Gives the number of items in a sequence that satisfy a given predicate as a <see cref="T:System.Int64"/> value.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence</typeparam>
            <param name="source">The sequence to count the number of items of</param>
            <param name="predicate">The predicate to test the individual items with</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the number of items in the sequence that match the predicate, or null if either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Boolean}})">
            <summary>
            Gives the number of items in a sequence that satisfy a given predicate dynamicaly as a <see cref="T:System.Int64"/> value.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence</typeparam>
            <param name="source">The sequence to count the number of items of</param>
            <param name="predicate">The predicate to test the individual items with. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose boolean Value property indicates if a given element satisfies the predicate.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the number of items in the sequence that match the predicate, or null if either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableDictionary`2"/> from an sequence according to a specified key selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <param name="source">A sequence to create a dictionary from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableDictionary`2"/>, that contains keys and values, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableDictionary`2"/> from an sequence according to a specified key selector function and key comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <param name="source">A sequence to create a dictionary from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to comparer keys.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableDictionary`2"/>, that contains keys and values, or null when either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="comparer"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableDictionary`2"/> from an sequence according to a specified dynamic key selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <param name="source">A sequence to create a dictionary from.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to index the given element by.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableDictionary`2"/>, that contains keys and values, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableDictionary`2"/> from an sequence according to a specified dynamic key selector function and key comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <param name="source">A sequence to create a dictionary from.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to index the given element by.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to comparer keys.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableDictionary`2"/>, that contains keys and values, or null when either <paramref name="source"/>, <paramref name="keySelector"/> or <paramref name="comparer"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableDictionary`2"/> from an sequence according to a specified key selector and element selector functions.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector"/>.</typeparam>
            <param name="source">A sequence to create a dictionary from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="elementSelector">A transform function to produce a result element value from each element.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableDictionary`2"/>, that contains values of type TElement selected from the input sequence, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableDictionary`2"/> from an sequence according to a specified key selector function, a comparer, and an element selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector"/>.</typeparam>
            <param name="source">A sequence to create a dictionary from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="elementSelector">A transform function to produce a result element value from each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to comparer keys.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableDictionary`2"/>, that contains values of type TElement selected from the input sequence, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,``2})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableDictionary`2"/> from an sequence according to a specified dynamic key selector and element selector functions.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector"/>.</typeparam>
            <param name="source">A sequence to create a dictionary from.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to index the given element by.</param>
            <param name="elementSelector">A transform function to produce a result element value from each element.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableDictionary`2"/>, that contains values of type TElement selected from the input sequence, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableDictionary`2"/> from an sequence according to a specified dynamic key selector function, a comparer, and an element selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector"/>.</typeparam>
            <param name="source">A sequence to create a dictionary from.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to index the given element by.</param>
            <param name="elementSelector">A transform function to produce a result element value from each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to comparer keys.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableDictionary`2"/>, that contains values of type TElement selected from the input sequence, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,Obtics.Values.IValueProvider{``2}})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableDictionary`2"/> from an sequence according to a specified key selector and dynamic element selector functions.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector"/>.</typeparam>
            <param name="source">A sequence to create a dictionary from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="elementSelector">A transform function to produce a result element value from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the result element to project the given element into.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableDictionary`2"/>, that contains values of type TElement selected from the input sequence, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableDictionary`2"/> from an sequence according to a specified key selector function, a comparer, and a dynamic element selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector"/>.</typeparam>
            <param name="source">A sequence to create a dictionary from.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the result element to project the given element into.</param>
            <param name="elementSelector">A transform function to produce a result element value from each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to comparer keys.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableDictionary`2"/>, that contains values of type TElement selected from the input sequence, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,Obtics.Values.IValueProvider{``2}})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableDictionary`2"/> from an sequence according to a specified dynamic key selector and dynamic element selector functions.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector"/>.</typeparam>
            <param name="source">A sequence to create a dictionary from.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to index the given element by.</param>
            <param name="elementSelector">A transform function to produce a result element value from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the result element to project the given element into.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableDictionary`2"/>, that contains values of type TElement selected from the input sequence, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Func{``0,Obtics.Values.IValueProvider{``2}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates an <see cref="T:Obtics.Collections.IObservableDictionary`2"/> from an sequence according to a specified dynamic key selector function, a comparer, and a dynamic element selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the keys</typeparam>
            <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector"/>.</typeparam>
            <param name="source">A sequence to create a dictionary from.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to index the given element by.</param>
            <param name="elementSelector">A transform function to produce a result element value from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TElement"/> Value property gives the result element to project the given element into.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to comparer keys.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableDictionary`2"/>, that contains values of type TElement selected from the input sequence, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Produces the set union of two sequences by using the default equality comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">A sequence whose distinct elements form the first set for the union.</param>
            <param name="second">A sequence whose distinct elements form the second set for the union.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the elements from both input sequences, excluding duplicates, or null if either <paramref name="first"/> or <paramref name="second"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Produces the set union of two sequences by using a given <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">A sequence whose distinct elements form the first set for the union.</param>
            <param name="second">A sequence whose distinct elements form the second set for the union.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare values.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the elements from both input sequences, excluding duplicates, or null if either <paramref name="first"/>, <paramref name="second"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1"/> and flattens the resulting sequences into one sequence.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TResult">The type of the elements of the sequence returned by selector.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the one-to-many transform function on each element of the input sequence, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1"/> and flattens the resulting sequences into one sequence. The index of each source element is used in the projected form of that element.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TResult">The type of the elements of the sequence returned by selector.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="selector">A transform function to apply to each element. The second parameter of the function represents the index of the source element.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the one-to-many transform function on each element of the input sequence, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
            Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1"/> dynamicaly and flattens the resulting sequences into one sequence.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TResult">The type of the elements of the sequence returned by selector.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Collections.Generic.IEnumerable`1"/> Value property gives the sequence the given element is projected into.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the one-to-many transform function on each element of the input sequence, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,Obtics.Values.IValueProvider{System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
            Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1"/> dynamicaly and flattens the resulting sequences into one sequence. The index of each source element is used in the projected form of that element.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TResult">The type of the elements of the sequence returned by selector.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="selector">A transform function to apply to each element. The second parameter of the function represents the index of the source element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Collections.Generic.IEnumerable`1"/> Value property gives the sequence the given element is projected into.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the one-to-many transform function on each element of the input sequence, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
            <summary>
            Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1"/>, flattens the resulting sequences into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TCollection">The type of the intermediate elements collected by collectionSelector.</typeparam>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input sequence.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate sequence.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of source and then mapping each of those sequence elements and their corresponding source element to a result element, or null when either <paramref name="source"/>, <paramref name="collectionSelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
            <summary>
            Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1"/>, flattens the resulting sequences into one sequence, and invokes a result selector function on each element therein.  The index of each source element is used in the projected form of that element.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TCollection">The type of the intermediate elements collected by collectionSelector.</typeparam>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input sequence. The second parameter of the function represents the index of the source element.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate sequence.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of source and then mapping each of those sequence elements and their corresponding source element to a result element, or null when either <paramref name="source"/>, <paramref name="collectionSelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,Obtics.Values.IValueProvider{``2}})">
            <summary>
            Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1"/>, flattens the resulting sequences into one sequence, and invokes a result selector function on each element therein dynamicaly.  The index of each source element is used in the projected form of that element.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TCollection">The type of the intermediate elements collected by collectionSelector.</typeparam>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input sequence. The second parameter of the function represents the index of the source element.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given projected element.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of source and then mapping each of those sequence elements and their corresponding source element to a result element, or null when either <paramref name="source"/>, <paramref name="collectionSelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,Obtics.Values.IValueProvider{``2}})">
            <summary>
            Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1"/>, flattens the resulting sequences into one sequence, and invokes a result selector function on each element therein dynamicaly.  The index of each source element is used in the projected form of that element.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TCollection">The type of the intermediate elements collected by collectionSelector.</typeparam>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input sequence. The second parameter of the function represents the index of the source element.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given projected element.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of source and then mapping each of those sequence elements and their corresponding source element to a result element, or null when either <paramref name="source"/>, <paramref name="collectionSelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Collections.Generic.IEnumerable{``1}}},System.Func{``0,``1,``2})">
            <summary>
            Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1"/> dynamicaly, flattens the resulting sequences into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TCollection">The type of the intermediate elements collected by collectionSelector.</typeparam>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Collections.Generic.IEnumerable`1"/> Value property gives the sequence the given element is projected into.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate sequence.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of source and then mapping each of those sequence elements and their corresponding source element to a result element, or null when either <paramref name="source"/>, <paramref name="collectionSelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,Obtics.Values.IValueProvider{System.Collections.Generic.IEnumerable{``1}}},System.Func{``0,``1,``2})">
            <summary>
            Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1"/> dynamicaly, flattens the resulting sequences into one sequence, and invokes a result selector function on each element therein.  The index of each source element is used in the projected form of that element.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TCollection">The type of the intermediate elements collected by collectionSelector.</typeparam>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input sequence. The second parameter of the function represents the index of the source element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Collections.Generic.IEnumerable`1"/> Value property gives the sequence the given element is projected into.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate sequence.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of source and then mapping each of those sequence elements and their corresponding source element to a result element, or null when either <paramref name="source"/>, <paramref name="collectionSelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Collections.Generic.IEnumerable{``1}}},System.Func{``0,``1,Obtics.Values.IValueProvider{``2}})">
            <summary>
            Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1"/> dynamicaly, flattens the resulting sequences into one sequence, and invokes a result selector function dynamicaly on each element therein.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TCollection">The type of the intermediate elements collected by collectionSelector.</typeparam>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Collections.Generic.IEnumerable`1"/> Value property gives the sequence the given element is projected into.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given projected element.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of source and then mapping each of those sequence elements and their corresponding source element to a result element, or null when either <paramref name="source"/>, <paramref name="collectionSelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,Obtics.Values.IValueProvider{System.Collections.Generic.IEnumerable{``1}}},System.Func{``0,``1,Obtics.Values.IValueProvider{``2}})">
            <summary>
            Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1"/> dynamicaly, flattens the resulting sequences into one sequence, and invokes a result selector function dynamicaly on each element therein.  The index of each source element is used in the projected form of that element.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TCollection">The type of the intermediate elements collected by collectionSelector.</typeparam>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input sequence. The second parameter of the function represents the index of the source element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Collections.Generic.IEnumerable`1"/> Value property gives the sequence the given element is projected into.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate sequence. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TResult"/> Value property gives the result for the given projected element.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of source and then mapping each of those sequence elements and their corresponding source element to a result element, or null when either <paramref name="source"/>, <paramref name="collectionSelector"/> or <paramref name="resultSelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Bypasses a specified number of elements in a sequence and then returns the remaining elements.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence to return elements from.</param>
            <param name="count">The number of elements to skip before returning the remaining elements.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the elements that occur after the specified index in the input sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Skip``1(System.Collections.Generic.IEnumerable{``0},Obtics.Values.IValueProvider{System.Int32})">
            <summary>
            Bypasses a variable number of elements in a sequence and then returns the remaining elements.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence to return elements from.</param>
            <param name="count">An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the number of elements to skip before returning the remaining elements.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the elements that occur after the specified index in the input sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Repeat``1(Obtics.Values.IValueProvider{``0},Obtics.Values.IValueProvider{System.Int32})">
            <summary>
            Generates a sequence that contains one repeated value.
            </summary>
            <typeparam name="TResult">The type of the value to be repeated in the result sequence.</typeparam>
            <param name="element">An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the value to be repeated.</param>
            <param name="count">An <see cref="T:Obtics.Values.IValueProvider`1"/> of <see cref="T:System.Int32"/> whose value gives the number of times to repeat the value in the generated sequence.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains a repeated value, or null when either <paramref name="element"/> or <paramref name="count"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Repeat``1(``0,Obtics.Values.IValueProvider{System.Int32})">
            <summary>
            Generates a sequence that contains one repeated value.
            </summary>
            <typeparam name="TResult">The type of the value to be repeated in the result sequence.</typeparam>
            <param name="element">The value to be repeated.</param>
            <param name="count">An <see cref="T:Obtics.Values.IValueProvider`1"/> of <see cref="T:System.Int32"/> whose value gives the number of times to repeat the value in the generated sequence.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains a repeated value, or null when <paramref name="count"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Repeat``1(Obtics.Values.IValueProvider{``0},System.Int32)">
            <summary>
            Generates a sequence that contains one repeated value.
            </summary>
            <typeparam name="TResult">The type of the value to be repeated in the result sequence.</typeparam>
            <param name="element">An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the value to be repeated.</param>
            <param name="count">The number of times to repeat the value in the generated sequence.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains a repeated value, or null when <paramref name="element"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Repeat``1(``0,System.Int32)">
            <summary>
            Generates a sequence that contains one repeated value.
            </summary>
            <typeparam name="TResult">The type of the value to be repeated in the result sequence.</typeparam>
            <param name="element">The value to be repeated.</param>
            <param name="count">The number of times to repeat the value in the generated sequence.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains a repeated value.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
             <summary>
             Computes the average of a sequence of nullable <see cref="T:System.Decimal"/> values.
             </summary>
             <param name="source">A sequence of nullable <see cref="T:System.Decimal"/> values to calculate the average of.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average(System.Collections.Generic.IEnumerable{System.Decimal})">
             <summary>
             Computes the average of a sequence of <see cref="T:System.Decimal"/> values.
             </summary>
             <param name="source">A sequence of <see cref="T:System.Decimal"/> values to calculate the average of.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
             <summary>
             Computes the average of a sequence of nullable <see cref="T:System.Double"/> values.
             </summary>
             <param name="source">A sequence of nullable <see cref="T:System.Double"/> values to calculate the average of.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average(System.Collections.Generic.IEnumerable{System.Double})">
             <summary>
             Computes the average of a sequence of <see cref="T:System.Double"/> values.
             </summary>
             <param name="source">A sequence of <see cref="T:System.Double"/> values to calculate the average of.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
             <summary>
             Computes the average of a sequence of nullable <see cref="T:System.Single"/> values.
             </summary>
             <param name="source">A sequence of nullable <see cref="T:System.Single"/> values to calculate the average of.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average(System.Collections.Generic.IEnumerable{System.Single})">
             <summary>
             Computes the average of a sequence of <see cref="T:System.Single"/> values.
             </summary>
             <param name="source">A sequence of <see cref="T:System.Single"/> values to calculate the average of.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
             <summary>
             Computes the average of a sequence of nullable <see cref="T:System.Int32"/> values.
             </summary>
             <param name="source">A sequence of nullable <see cref="T:System.Int32"/> values to calculate the average of.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average(System.Collections.Generic.IEnumerable{System.Int32})">
             <summary>
             Computes the average of a sequence of <see cref="T:System.Int32"/> values.
             </summary>
             <param name="source">A sequence of <see cref="T:System.Int32"/> values to calculate the average of.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
             <summary>
             Computes the average of a sequence of nullable <see cref="T:System.Int64"/> values.
             </summary>
             <param name="source">A sequence of nullable <see cref="T:System.Int64"/> values to calculate the average of.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average(System.Collections.Generic.IEnumerable{System.Int64})">
             <summary>
             Computes the average of a sequence of <see cref="T:System.Int64"/> values.
             </summary>
             <param name="source">A sequence of <see cref="T:System.Int64"/> values to calculate the average of.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if <paramref name="source"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
             <summary>
             Computes the average of a sequence of nullable <see cref="T:System.Decimal"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Decimal"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
             <summary>
             Computes the average of a sequence of <see cref="T:System.Decimal"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Decimal"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
             <summary>
             Computes the average of a sequence of nullable <see cref="T:System.Double"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Double"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
             <summary>
             Computes the average of a sequence of <see cref="T:System.Double"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Double"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
             <summary>
             Computes the average of a sequence of nullable <see cref="T:System.Single"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Single"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
             <summary>
             Computes the average of a sequence of <see cref="T:System.Single"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Single"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
             <summary>
             Computes the average of a sequence of nullable <see cref="T:System.Int32"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Int32"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
             <summary>
             Computes the average of a sequence of <see cref="T:System.Int32"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Int32"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
             <summary>
             Computes the average of a sequence of nullable <see cref="T:System.Int64"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Int64"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
             <summary>
             Computes the average of a sequence of <see cref="T:System.Int64"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Int64"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Decimal}}})">
             <summary>
             Computes the average of a sequence of dynamic nullable <see cref="T:System.Decimal"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Decimal"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the nullable <see cref="T:System.Decimal"/> to assimilate in the average.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Decimal}})">
             <summary>
             Computes the average of a sequence of dynamic <see cref="T:System.Decimal"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Decimal"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the <see cref="T:System.Decimal"/> to assimilate in the average.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Double}}})">
             <summary>
             Computes the average of a sequence of dynamic nullable <see cref="T:System.Double"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Double"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the nullable <see cref="T:System.Double"/> to assimilate in the average.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Double}})">
             <summary>
             Computes the average of a sequence of dynamic <see cref="T:System.Double"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Double"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the <see cref="T:System.Double"/> to assimilate in the average.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Single}}})">
             <summary>
             Computes the average of a sequence of dynamic nullable <see cref="T:System.Single"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Single"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the nullable <see cref="T:System.Single"/> to assimilate in the average.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Single}})">
             <summary>
             Computes the average of a sequence of dynamic <see cref="T:System.Single"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Single"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the <see cref="T:System.Single"/> to assimilate in the average.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Int32}}})">
             <summary>
             Computes the average of a sequence of dynamic nullable <see cref="T:System.Int32"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Int32"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the nullable <see cref="T:System.Int32"/> to assimilate in the average.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Int32}})">
             <summary>
             Computes the average of a sequence of dynamic <see cref="T:System.Int32"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Int32"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the <see cref="T:System.Int32"/> to assimilate in the average.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Int64}}})">
             <summary>
             Computes the average of a sequence of dynamic nullable <see cref="T:System.Int64"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of nullable <see cref="T:System.Int64"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the nullable <see cref="T:System.Int64"/> to assimilate in the average.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Int64}})">
             <summary>
             Computes the average of a sequence of dynamic <see cref="T:System.Int64"/> values that
                 are obtained by invoking a transform function on each element of the input
                 sequence.
             </summary>
             <typeparam name="TSource">Type of the elements of <paramref name="source"/>.</typeparam>
             <param name="source">A sequence of <see cref="T:System.Int64"/> values to calculate the average of.</param>
             <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the <see cref="T:System.Int64"/> to assimilate in the average.</param>
             <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value is the average of the sequence of values, or null if either <paramref name="source"/> or <paramref name="selector"/> is null.
            </returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns the element at a specified index in a sequence.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return an element from.</param>
            <param name="index">The zero-based index of the element to retrieve.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the element at the specified position in the source sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},Obtics.Values.IValueProvider{System.Int32})">
            <summary>
            Returns the element at a specified index in a sequence.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return an element from.</param>
            <param name="index">An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives the zero-based index of the element to retrieve.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the element at the specified position in the source sequence, or null when <paramref name="source"/> or <paramref name="index"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an array from a sequence.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <param name="source">A sequence to create an Array from.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives an array that contains the elements from the input sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
            <summary>
            Returns the maximum value in a sequence of nullable <see cref="T:System.Decimal"/> values.
            </summary>
            <param name="source">A sequence of nullable <see cref="T:System.Decimal"/> values to determine the maximum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Decimal"/> that corresponds to the maximum value in the sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max(System.Collections.Generic.IEnumerable{System.Decimal})">
            <summary>
            Returns the maximum value in a sequence of <see cref="T:System.Decimal"/> values.
            </summary>
            <param name="source">A sequence of <see cref="T:System.Decimal"/> values to determine the maximum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Decimal"/> that corresponds to the maximum value in the sequence, or null when <paramref name="source"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Decimal"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
            <summary>
            Returns the maximum value in a sequence of nullable <see cref="T:System.Double"/> values.
            </summary>
            <param name="source">A sequence of nullable <see cref="T:System.Double"/> values to determine the maximum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Double"/> that corresponds to the maximum value in the sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the maximum value in a sequence of <see cref="T:System.Double"/> values.
            </summary>
            <param name="source">A sequence of <see cref="T:System.Double"/> values to determine the maximum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Double"/> that corresponds to the maximum value in the sequence, or null when <paramref name="source"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Double"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
            <summary>
            Returns the maximum value in a sequence of nullable <see cref="T:System.Single"/> values.
            </summary>
            <param name="source">A sequence of nullable <see cref="T:System.Single"/> values to determine the maximum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Single"/> that corresponds to the maximum value in the sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Returns the maximum value in a sequence of <see cref="T:System.Single"/> values.
            </summary>
            <param name="source">A sequence of <see cref="T:System.Single"/> values to determine the maximum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Single"/> that corresponds to the maximum value in the sequence, or null when <paramref name="source"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Single"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
            <summary>
            Returns the maximum value in a sequence of nullable <see cref="T:System.Int32"/> values.
            </summary>
            <param name="source">A sequence of nullable <see cref="T:System.Int32"/> values to determine the maximum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Int32"/> that corresponds to the maximum value in the sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Returns the maximum value in a sequence of <see cref="T:System.Int32"/> values.
            </summary>
            <param name="source">A sequence of <see cref="T:System.Int32"/> values to determine the maximum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Int32"/> that corresponds to the maximum value in the sequence, or null when <paramref name="source"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Int32"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Returns the maximum value in a sequence of nullable <see cref="T:System.Int64"/> values.
            </summary>
            <param name="source">A sequence of nullable <see cref="T:System.Int64"/> values to determine the maximum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Int64"/> that corresponds to the maximum value in the sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Returns the maximum value in a sequence of <see cref="T:System.Int64"/> values.
            </summary>
            <param name="source">A sequence of <see cref="T:System.Int64"/> values to determine the maximum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Int64"/> that corresponds to the maximum value in the sequence, or null when <paramref name="source"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Int64"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the maximum value in a sequence.
            </summary>
            <typeparam name="TOut">Type of the elements of the sequence.</typeparam>
            <param name="source">A sequence to determine the maximum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the maximum value in the sequence or default(<typeparamref name="TOut"/>) if the source sequence is empty, or null when <paramref name="source"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<typeparamref name="TOut"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequences. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns the maximum value in a sequence using a given <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
            <typeparam name="TOut">Type of the elements of the sequence.</typeparam>
            <param name="source">A sequence to determine the maximum value of.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to compare elements of the source sequence.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the maximum value in the sequence or default(<typeparamref name="TOut"/>) if the source sequence is empty, or null when either <paramref name="source"/> or <paramref name="comparer"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<typeparamref name="TOut"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0},``0)">
            <summary>
            Returns the maximum value in a sequence using a given <see cref="T:System.Collections.Generic.IComparer`1"/> or a fallback value if the source is empty.
            </summary>
            <typeparam name="TOut">Type of the elements of the sequence.</typeparam>
            <param name="source">A sequence to determine the maximum value of.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to compare elements of the source sequence.</param>
            <param name="fallback">The value to return when the sequence is empty.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the maximum value in the sequence or <paramref name="fallback"/> if the source sequence is empty, or null when either <paramref name="source"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the maximum nullable <see cref="T:System.Decimal"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Decimal"/> that corresponds to the maximum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the maximum nullable <see cref="T:System.Decimal"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Decimal"/> that corresponds to the maximum value returned by <paramref name="selector"/> or default(<see cref="T:System.Decimal"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Decimal"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the maximum nullable <see cref="T:System.Double"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Double"/> that corresponds to the maximum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the maximum nullable <see cref="T:System.Double"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Double"/> that corresponds to the maximum value returned by <paramref name="selector"/> or default(<see cref="T:System.Double"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Double"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the maximum nullable <see cref="T:System.Single"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Single"/> that corresponds to the maximum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the maximum nullable <see cref="T:System.Single"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Single"/> that corresponds to the maximum value returned by <paramref name="selector"/> or default(<see cref="T:System.Single"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Single"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the maximum nullable <see cref="T:System.Int32"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Int32"/> that corresponds to the maximum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the maximum nullable <see cref="T:System.Int32"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Int32"/> that corresponds to the maximum value returned by <paramref name="selector"/> or default(<see cref="T:System.Int32"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Int32"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the maximum nullable <see cref="T:System.Int64"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Int64"/> that corresponds to the maximum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the maximum nullable <see cref="T:System.Int64"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Int64"/> that corresponds to the maximum value returned by <paramref name="selector"/> or default(<see cref="T:System.Int64"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Int64"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the maximum result.
            </summary>
            <typeparam name="TOut">Type of the result of the function.</typeparam>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the maximum value return by <paramref name="selector"/> or default(<typeparamref name="TOut"/>) if the source sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<typeparamref name="TOut"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the maximum result determined by using a given <see cref="T:System.Collections.Generic.IComparer`1"/> to compare result values.
            </summary>
            <typeparam name="TOut">Type of the result of the function.</typeparam>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to compare the result values of <paramref name="selector"/>.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the maximum value return by <paramref name="selector"/> or default(<typeparamref name="TOut"/>) if the source sequence is empty, or null when either <paramref name="source"/>, <paramref name="selector"/> or <paramref name="comparer"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<typeparamref name="TOut"/>).
            This may be a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},``1)">
            <summary>
            Invokes a transform function on each element of a sequence and returns the maximum result determined by using a given <see cref="T:System.Collections.Generic.IComparer`1"/> to compare result values or returns a fallback value if the sequence is empty.
            </summary>
            <typeparam name="TOut">Type of the result of the function.</typeparam>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to compare the result values of <paramref name="selector"/>.</param>
            <param name="fallback">A <typeparamref name="TOut"/> value to return when the sequence is empty.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the maximum value return by <paramref name="selector"/> or <paramref name="fallback"/> if the source sequence is empty, or null when either <paramref name="source"/>, <paramref name="selector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Decimal}}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the maximum nullable <see cref="T:System.Decimal"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose nullable <see cref="T:System.Decimal"/> Value property gives the value to determine the maximum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Decimal"/> that corresponds to the maximum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Decimal}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the maximum nullable <see cref="T:System.Decimal"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Decimal"/> Value property gives the value to determine the maximum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Decimal"/> that corresponds to the maximum value returned by <paramref name="selector"/> or default(<see cref="T:System.Decimal"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Decimal"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Double}}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the maximum nullable <see cref="T:System.Double"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose nullable <see cref="T:System.Double"/> Value property gives the value to determine the maximum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Double"/> that corresponds to the maximum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Double}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the maximum nullable <see cref="T:System.Double"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Double"/> Value property gives the value to determine the maximum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Double"/> that corresponds to the maximum value returned by <paramref name="selector"/> or default(<see cref="T:System.Double"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Double"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Single}}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the maximum nullable <see cref="T:System.Single"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose nullable <see cref="T:System.Single"/> Value property gives the value to determine the maximum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Single"/> that corresponds to the maximum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Single}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the maximum nullable <see cref="T:System.Single"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Single"/> Value property gives the value to determine the maximum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Single"/> that corresponds to the maximum value returned by <paramref name="selector"/> or default(<see cref="T:System.Single"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Single"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Int32}}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the maximum nullable <see cref="T:System.Int32"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose nullable <see cref="T:System.Int32"/> Value property gives the value to determine the maximum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Int32"/> that corresponds to the maximum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Int32}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the maximum nullable <see cref="T:System.Int32"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Int32"/> Value property gives the value to determine the maximum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Int32"/> that corresponds to the maximum value returned by <paramref name="selector"/> or default(<see cref="T:System.Int32"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Int32"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Int64}}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the maximum nullable <see cref="T:System.Int64"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose nullable <see cref="T:System.Int64"/> Value property gives the value to determine the maximum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Int64"/> that corresponds to the maximum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Int64}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the maximum nullable <see cref="T:System.Int64"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Int64"/> Value property gives the value to determine the maximum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Int64"/> that corresponds to the maximum value returned by <paramref name="selector"/> or default(<see cref="T:System.Int64"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Int64"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the maximum result.
            </summary>
            <typeparam name="TOut">Type of the result of the function.</typeparam>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TOut"/> Value property gives the value to determine the maximum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the maximum value return by <paramref name="selector"/> or default(<typeparamref name="TOut"/>) if the source sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<typeparamref name="TOut"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the maximum result determined by using a given <see cref="T:System.Collections.Generic.IComparer`1"/> to compare result values.
            </summary>
            <typeparam name="TOut">Type of the result of the function.</typeparam>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TOut"/> Value property gives the value to determine the maximum with.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to compare the result values of <paramref name="selector"/>.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the maximum value return by <paramref name="selector"/> or default(<typeparamref name="TOut"/>) if the source sequence is empty, or null when either <paramref name="source"/>, <paramref name="selector"/> or <paramref name="comparer"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<typeparamref name="TOut"/>).
            This may be a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Collections.Generic.IComparer{``1},``1)">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the maximum result determined by using a given <see cref="T:System.Collections.Generic.IComparer`1"/> to compare result values or returns a fallback value if the sequence is empty.
            </summary>
            <typeparam name="TOut">Type of the result of the function.</typeparam>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TOut"/> Value property gives the value to determine the maximum with.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to compare the result values of <paramref name="selector"/>.</param>
            <param name="fallback">A <typeparamref name="TOut"/> value to return when the sequence is empty.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the maximum value return by <paramref name="selector"/> or <paramref name="fallback"/> if the source sequence is empty, or null when either <paramref name="source"/>, <paramref name="selector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Static``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an unchanging shallow copy of a sequence as it is the moment the method is invoked.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <param name="source">The source to create a copy of.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the same elements as <paramref name="source"/> at the moment this method was invoked, or null when source is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Static``1(``0[])">
            <summary>
            Creates a static sequence from a number of given elements or an array of element
            </summary>
            <typeparam name="TSource">Type of the sequence elements.</typeparam>
            <param name="source">The (array of) elements to create the sequence with.</param>
            <returns>A static sequence.</returns>
            <remarks>
            The sequence returned by this method differs from an array in that two of these sequence instances
            will be equal if all elements one for one are equal. Two different array instances are never equal.
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Range(System.Int32,System.Int32)">
            <summary>
            Generates a sequence of integral numbers within a specified range.
            </summary>
            <param name="start">The value of the first integer in the sequence.</param>
            <param name="count">The number of sequential integers to generate.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Int32"/> that contains a range of sequential integral numbers.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Range(Obtics.Values.IValueProvider{System.Int32},System.Int32)">
            <summary>
            Generates a sequence of integral numbers within a specified range.
            </summary>
            <param name="start">An <see cref="T:Obtics.Values.IValueProvider`1"/> of <see cref="T:System.Int32"/> whose value gives the first integer in the sequence.</param>
            <param name="count">The number of sequential integers to generate.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Int32"/> that contains a range of sequential integral numbers, or null when <paramref name="start"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Range(System.Int32,Obtics.Values.IValueProvider{System.Int32})">
            <summary>
            Generates a sequence of integral numbers within a specified range.
            </summary>
            <param name="start">The value of the first integer in the sequence.</param>
            <param name="count">An <see cref="T:Obtics.Values.IValueProvider`1"/> of <see cref="T:System.Int32"/> whose value gives the number of sequential integers to generate.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Int32"/> that contains a range of sequential integral numbers, or null when <paramref name="count"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Range(Obtics.Values.IValueProvider{System.Int32},Obtics.Values.IValueProvider{System.Int32})">
            <summary>
            Generates a sequence of integral numbers within a specified range.
            </summary>
            <param name="start">An <see cref="T:Obtics.Values.IValueProvider`1"/> of <see cref="T:System.Int32"/> whose value gives the first integer in the sequence.</param>
            <param name="count">An <see cref="T:Obtics.Values.IValueProvider`1"/> of <see cref="T:System.Int32"/> whose value gives the number of sequential integers to generate.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Int32"/> that contains a range of sequential integral numbers, or null when either <paramref name="start"/> or <paramref name="count"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Determines if all elements of a sequence satisfy a condition.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence that contains the elements to apply the predicate to.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property is true if every element of the source sequence passes the test in the specified predicate or if the sequence is empty and false otherwise, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Boolean}})">
            <summary>
            Determines if all elements of a sequence satisfy a condition dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence that contains the elements to apply the predicate to.</param>
            <param name="predicate">A function to test each element for a condition. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property indicates if an elements satisfies the condition.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property is true if every element of the source sequence passes the test in the specified predicate or if the sequence is empty and false otherwise, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
            <summary>
            Returns the minimum value in a sequence of nullable <see cref="T:System.Decimal"/> values.
            </summary>
            <param name="source">A sequence of nullable <see cref="T:System.Decimal"/> values to determine the minimum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Decimal"/> that corresponds to the minimum value in the sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min(System.Collections.Generic.IEnumerable{System.Decimal})">
            <summary>
            Returns the minimum value in a sequence of <see cref="T:System.Decimal"/> values.
            </summary>
            <param name="source">A sequence of <see cref="T:System.Decimal"/> values to determine the minimum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Decimal"/> that corresponds to the minimum value in the sequence, or null when <paramref name="source"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Decimal"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
            <summary>
            Returns the minimum value in a sequence of nullable <see cref="T:System.Double"/> values.
            </summary>
            <param name="source">A sequence of nullable <see cref="T:System.Double"/> values to determine the minimum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Double"/> that corresponds to the minimum value in the sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the minimum value in a sequence of <see cref="T:System.Double"/> values.
            </summary>
            <param name="source">A sequence of <see cref="T:System.Double"/> values to determine the minimum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Double"/> that corresponds to the minimum value in the sequence, or null when <paramref name="source"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Double"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
            <summary>
            Returns the minimum value in a sequence of nullable <see cref="T:System.Single"/> values.
            </summary>
            <param name="source">A sequence of nullable <see cref="T:System.Single"/> values to determine the minimum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Single"/> that corresponds to the minimum value in the sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Returns the minimum value in a sequence of <see cref="T:System.Single"/> values.
            </summary>
            <param name="source">A sequence of <see cref="T:System.Single"/> values to determine the minimum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Single"/> that corresponds to the minimum value in the sequence, or null when <paramref name="source"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Single"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
            <summary>
            Returns the minimum value in a sequence of nullable <see cref="T:System.Int32"/> values.
            </summary>
            <param name="source">A sequence of nullable <see cref="T:System.Int32"/> values to determine the minimum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Int32"/> that corresponds to the minimum value in the sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Returns the minimum value in a sequence of <see cref="T:System.Int32"/> values.
            </summary>
            <param name="source">A sequence of <see cref="T:System.Int32"/> values to determine the minimum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Int32"/> that corresponds to the minimum value in the sequence, or null when <paramref name="source"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Int32"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Returns the minimum value in a sequence of nullable <see cref="T:System.Int64"/> values.
            </summary>
            <param name="source">A sequence of nullable <see cref="T:System.Int64"/> values to determine the minimum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Int64"/> that corresponds to the minimum value in the sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Returns the minimum value in a sequence of <see cref="T:System.Int64"/> values.
            </summary>
            <param name="source">A sequence of <see cref="T:System.Int64"/> values to determine the minimum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Int64"/> that corresponds to the minimum value in the sequence, or null when <paramref name="source"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Int64"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the minimum value in a sequence.
            </summary>
            <typeparam name="TOut">Type of the elements of the sequence.</typeparam>
            <param name="source">A sequence to determine the minimum value of.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the minimum value in the sequence or default(<typeparamref name="TOut"/>) if the source sequence is empty, or null when <paramref name="source"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<typeparamref name="TOut"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequences. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns the minimum value in a sequence using a given <see cref="T:System.Collections.Generic.IComparer`1"/>.
            </summary>
            <typeparam name="TOut">Type of the elements of the sequence.</typeparam>
            <param name="source">A sequence to determine the minimum value of.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to compare elements of the source sequence.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the minimum value in the sequence or default(<typeparamref name="TOut"/>) if the source sequence is empty, or null when either <paramref name="source"/> or <paramref name="comparer"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<typeparamref name="TOut"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0},``0)">
            <summary>
            Returns the minimum value in a sequence using a given <see cref="T:System.Collections.Generic.IComparer`1"/> or a fallback value if the source is empty.
            </summary>
            <typeparam name="TOut">Type of the elements of the sequence.</typeparam>
            <param name="source">A sequence to determine the minimum value of.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to compare elements of the source sequence.</param>
            <param name="fallback">The value to return when the sequence is empty.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the minimum value in the sequence or <paramref name="fallback"/> if the source sequence is empty, or null when either <paramref name="source"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the minimum nullable <see cref="T:System.Decimal"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Decimal"/> that corresponds to the minimum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the minimum nullable <see cref="T:System.Decimal"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Decimal"/> that corresponds to the minimum value returned by <paramref name="selector"/> or default(<see cref="T:System.Decimal"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Decimal"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the minimum nullable <see cref="T:System.Double"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Double"/> that corresponds to the minimum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the minimum nullable <see cref="T:System.Double"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Double"/> that corresponds to the minimum value returned by <paramref name="selector"/> or default(<see cref="T:System.Double"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Double"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the minimum nullable <see cref="T:System.Single"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Single"/> that corresponds to the minimum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the minimum nullable <see cref="T:System.Single"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Single"/> that corresponds to the minimum value returned by <paramref name="selector"/> or default(<see cref="T:System.Single"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Single"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the minimum nullable <see cref="T:System.Int32"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Int32"/> that corresponds to the minimum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the minimum nullable <see cref="T:System.Int32"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Int32"/> that corresponds to the minimum value returned by <paramref name="selector"/> or default(<see cref="T:System.Int32"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Int32"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the minimum nullable <see cref="T:System.Int64"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Int64"/> that corresponds to the minimum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the minimum nullable <see cref="T:System.Int64"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Int64"/> that corresponds to the minimum value returned by <paramref name="selector"/> or default(<see cref="T:System.Int64"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Int64"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the minimum result.
            </summary>
            <typeparam name="TOut">Type of the result of the function.</typeparam>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the minimum value return by <paramref name="selector"/> or default(<typeparamref name="TOut"/>) if the source sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<typeparamref name="TOut"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the minimum result determined by using a given <see cref="T:System.Collections.Generic.IComparer`1"/> to compare result values.
            </summary>
            <typeparam name="TOut">Type of the result of the function.</typeparam>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to compare the result values of <paramref name="selector"/>.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the minimum value return by <paramref name="selector"/> or default(<typeparamref name="TOut"/>) if the source sequence is empty, or null when either <paramref name="source"/>, <paramref name="selector"/> or <paramref name="comparer"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<typeparamref name="TOut"/>).
            This may be a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},``1)">
            <summary>
            Invokes a transform function on each element of a sequence and returns the minimum result determined by using a given <see cref="T:System.Collections.Generic.IComparer`1"/> to compare result values or returns a fallback value if the sequence is empty.
            </summary>
            <typeparam name="TOut">Type of the result of the function.</typeparam>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to compare the result values of <paramref name="selector"/>.</param>
            <param name="fallback">A <typeparamref name="TOut"/> value to return when the sequence is empty.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the minimum value return by <paramref name="selector"/> or <paramref name="fallback"/> if the source sequence is empty, or null when either <paramref name="source"/>, <paramref name="selector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Decimal}}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the minimum nullable <see cref="T:System.Decimal"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose nullable <see cref="T:System.Decimal"/> Value property gives the value to determine the minimum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Decimal"/> that corresponds to the minimum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Decimal}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the minimum nullable <see cref="T:System.Decimal"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Decimal"/> Value property gives the value to determine the minimum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Decimal"/> that corresponds to the minimum value returned by <paramref name="selector"/> or default(<see cref="T:System.Decimal"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Decimal"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Double}}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the minimum nullable <see cref="T:System.Double"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose nullable <see cref="T:System.Double"/> Value property gives the value to determine the minimum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Double"/> that corresponds to the minimum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Double}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the minimum nullable <see cref="T:System.Double"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Double"/> Value property gives the value to determine the minimum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Double"/> that corresponds to the minimum value returned by <paramref name="selector"/> or default(<see cref="T:System.Double"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Double"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Single}}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the minimum nullable <see cref="T:System.Single"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose nullable <see cref="T:System.Single"/> Value property gives the value to determine the minimum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Single"/> that corresponds to the minimum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Single}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the minimum nullable <see cref="T:System.Single"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Single"/> Value property gives the value to determine the minimum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Single"/> that corresponds to the minimum value returned by <paramref name="selector"/> or default(<see cref="T:System.Single"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Single"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Int32}}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the minimum nullable <see cref="T:System.Int32"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose nullable <see cref="T:System.Int32"/> Value property gives the value to determine the minimum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Int32"/> that corresponds to the minimum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Int32}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the minimum nullable <see cref="T:System.Int32"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Int32"/> Value property gives the value to determine the minimum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Int32"/> that corresponds to the minimum value returned by <paramref name="selector"/> or default(<see cref="T:System.Int32"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Int32"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Nullable{System.Int64}}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the minimum nullable <see cref="T:System.Int64"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose nullable <see cref="T:System.Int64"/> Value property gives the value to determine the minimum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a nullable <see cref="T:System.Int64"/> that corresponds to the minimum value returned by <paramref name="selector"/> or null if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Int64}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the minimum nullable <see cref="T:System.Int64"/> value.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Int64"/> Value property gives the value to determine the minimum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <see cref="T:System.Int64"/> that corresponds to the minimum value returned by <paramref name="selector"/> or default(<see cref="T:System.Int64"/>) if the sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<see cref="T:System.Int64"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the minimum result.
            </summary>
            <typeparam name="TOut">Type of the result of the function.</typeparam>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TOut"/> Value property gives the value to determine the minimum with.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the minimum value return by <paramref name="selector"/> or default(<typeparamref name="TOut"/>) if the source sequence is empty, or null when either <paramref name="source"/> or <paramref name="selector"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<typeparamref name="TOut"/>).
            This infact is a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the minimum result determined by using a given <see cref="T:System.Collections.Generic.IComparer`1"/> to compare result values.
            </summary>
            <typeparam name="TOut">Type of the result of the function.</typeparam>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TOut"/> Value property gives the value to determine the minimum with.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to compare the result values of <paramref name="selector"/>.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the minimum value return by <paramref name="selector"/> or default(<typeparamref name="TOut"/>) if the source sequence is empty, or null when either <paramref name="source"/>, <paramref name="selector"/> or <paramref name="comparer"/> is null.</returns>
            <remarks>
            When <paramref name="source"/> is an empty sequence the Value property of the result <see cref="T:Obtics.Values.IValueProvider`1"/> will be default(<typeparamref name="TOut"/>).
            This may be a non-sensical response. It is upto the developer to detect an empty source sequence. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Collections.Generic.IComparer{``1},``1)">
            <summary>
            Invokes a transform function on each element of a sequence dynamicaly and returns the minimum result determined by using a given <see cref="T:System.Collections.Generic.IComparer`1"/> to compare result values or returns a fallback value if the sequence is empty.
            </summary>
            <typeparam name="TOut">Type of the result of the function.</typeparam>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TOut"/> Value property gives the value to determine the minimum with.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> to compare the result values of <paramref name="selector"/>.</param>
            <param name="fallback">A <typeparamref name="TOut"/> value to return when the sequence is empty.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives a <typeparamref name="TOut"/> that corresponds to the minimum value return by <paramref name="selector"/> or <paramref name="fallback"/> if the source sequence is empty, or null when either <paramref name="source"/>, <paramref name="selector"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Cap``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence</typeparam>
            <param name="source">A sequence to convert to an <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <returns>An <see cref="T:System.Collections.Generic.IList`1"/> with elements from <paramref name="source"/>, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.UpCast``1(Obtics.Collections.IVersionedEnumerable)">
            <summary>
            Helper method shared by Cast and OfType. Checks if the element cast is a simple upcast or not.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="source"></param>
            <returns>The upcasted sequence or null if it isn't an upcast.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Cast``1(System.Collections.IEnumerable)">
            <summary>
            Converts the elements of an <see cref="T:System.Collections.IEnumerable"/> to the specified type, leaving out the elements for which a conversion path can not be found.
            </summary>
            <typeparam name="TResult">The type to convert the elements of source to.</typeparam>
            <param name="source">The <see cref="T:System.Collections.IEnumerable"/> that contains the elements to be converted.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains each convertable element of
                the source sequence converted to the specified type, or null if <paramref name="source"/> is null.</returns>
            <remarks>
            Obtics transformations in principle never raise exceptions for the same reasons
            that eventhandlers should never raise exceptions.
            When no conversion path can be found to cast an item to the intended type the 
            item is simply left out of the result collection (like <see cref="M:Obtics.Collections.ObservableEnumerable.OfType``1(System.Collections.IEnumerable)"/>).
            When a path can be found then this path should never raise an exception. This 
            transformation will not handle such exceptions since it knows nothing about them
            and will let them escalate. This in turn means that the transformation pipeline will be
            left in an inconsistent state. If it is
            possible for such a path to raise an exception then this is not the method to use.
            In such a case it would be better to use <see cref="M:Obtics.Collections.ObservableEnumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/> and <see cref="M:Obtics.Collections.ObservableEnumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/> and check the conversion.
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <param name="source">The sequence to return elements from.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the elements from the input sequence starting at the first element that does not pass the test specified by predicate, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Boolean}})">
            <summary>
            Bypasses elements in a sequence as long as a specified condition is true dynamicaly and then returns the remaining elements.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <param name="source">The sequence to return elements from.</param>
            <param name="predicate">A function to test each element for a condition. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whos <see cref="T:System.Boolean"/> Value property indicates if the given element satisfies the condition.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the elements from the input sequence starting at the first element that does not pass the test specified by predicate, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements. The element's index is used in the logic of the predicate function.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <param name="source">The sequence to return elements from.</param>
            <param name="predicate">A function to test each source element for a condition; the second parameter of the function represents the index of the source element.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the elements from the input sequence starting at the first element that does not pass the test specified by predicate, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,Obtics.Values.IValueProvider{System.Boolean}})">
            <summary>
            Bypasses elements in a sequence as long as a specified condition is true dynamicaly and then returns the remaining elements. The element's index is used in the logic of the predicate function.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <param name="source">The sequence to return elements from.</param>
            <param name="predicate">A function to test each source element for a condition; the second parameter of the function represents the index of the source element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whos <see cref="T:System.Boolean"/> Value property indicates if the given element satisfies the condition.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the elements from the input sequence starting at the first element that does not pass the test specified by predicate, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Filters a sequence based on a predicate.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to filter.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements from the input sequence that satisfy the condition, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Boolean}})">
            <summary>
            Filters a sequence based on a predicate. Each element's index is used in the logic of the predicate function.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to filter.</param>
            <param name="predicate">A function to test each source element for a condition. The second parameter of the function represents the index of the source element.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements from the input sequence that satisfy the condition, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Filters a sequence based on a dynamic predicate.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to filter.</param>
            <param name="predicate">A function to test each element for a condition. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Boolean"/> Value property indicates if the given element satisfies the predicate.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements from the input sequence that satisfy the condition, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,Obtics.Values.IValueProvider{System.Boolean}})">
            <summary>
            Filters a sequence based on a dynamic predicate. Each element's index is used in the logic of the predicate function.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence to filter.</param>
            <param name="predicate">A function to test each source element for a condition. The second parameter of the function represents the index of the source element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <see cref="T:System.Boolean"/> Value property indicates if the given element satisfies the predicate.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains elements from the input sequence that satisfy the condition, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Count``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gives the number of items in a sequence.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence</typeparam>
            <param name="source">The sequence to count the number of items of</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the number of items in the sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Count``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Gives the number of items in a sequence that satisfy a given predicate.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence</typeparam>
            <param name="source">The sequence to count the number of items of</param>
            <param name="predicate">The predicate to test the individual items with</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the number of items in the sequence that match the predicate, or null when either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Count``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{System.Boolean}})">
            <summary>
            Gives the number of items in a sequence that satisfy a given predicate dynamicaly.
            </summary>
            <typeparam name="TSource">Type of the elements of the sequence</typeparam>
            <param name="source">The sequence to count the number of items of</param>
            <param name="predicate">The predicate to test the individual items with. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose boolean Value property indicates if the given element satisfies the predicate.</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/>, whose Value property gives the number of items in the sequence that match the predicate, or null if either <paramref name="source"/> or <paramref name="predicate"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Produces the set intersection of two sequences by using the default equality comparer to compare values.
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose distinct elements that also appear in <paramref name="second"/> will be returned.</param>
            <param name="second">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose distinct elements that also appear in the <paramref name="first"/> sequence will be returned.</param>
            <returns>A sequence, that contains the elements that form the set intersection of two sequences, or null when either <paramref name="first"/> or <paramref name="second"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Produces the set intersection of two sequences by using the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare values.
            </summary>
            <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
            <param name="first">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose distinct elements that also appear in <paramref name="second"/> will be returned.</param>
            <param name="second">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose distinct elements that also appear in the <paramref name="first"/> sequence will be returned.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare values.</param>
            <returns>A sequence, that contains the elements that form the set intersection of two sequences, or null when either <paramref name="first"/>, <paramref name="second"/> or <paramref name="comparer"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Take``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns a specified number of contiguous elements from the start of a sequence.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The sequence to take elements from.</param>
            <param name="count">The number of elements to take from the sequence.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/>, that contains the specified number of elements from the start of the sequence, or null when <paramref name="source"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.Take``1(System.Collections.Generic.IEnumerable{``0},Obtics.Values.IValueProvider{System.Int32})">
            <summary>
            Returns a variable number of contiguous elements from the start of a sequence.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The sequence to take elements from.</param>
            <param name="count">An <see cref="T:Obtics.Values.IValueProvider`1"/> whose Value property gives number of elements to take from the sequence.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the specified number of elements from the start of the sequence, or null when either <paramref name="source"/> or <paramref name="count"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ThenBy``2(Obtics.Collections.IObservableOrderedEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in ascending order according to a key.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="source">An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/> that contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted according to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ThenBy``2(Obtics.Collections.IObservableOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in ascending order by using a given comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="source">An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/> that contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> used to compare key values.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted according to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ThenBy``2(Obtics.Collections.IObservableOrderedEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in ascending order according to a key dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="source">An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/> that contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to order the given element by.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted according to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ThenBy``2(Obtics.Collections.IObservableOrderedEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in ascending order dynamicaly by using a given comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="source">An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/> that contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> used to compare key values. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to order the given element by.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted according to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in ascending order according to a key.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="source">An <see cref="T:System.Linq.IOrderedEnumerable`1"/> that contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1"/>, whose elements are sorted according to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
            <remarks>The result of this method will only be reactive and observable if source is in fact an <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>.</remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in ascending order by using a given comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="source">An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/> that contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> used to compare key values.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted according to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
            <remarks>The result of this method will only be reactive and observable if source is in fact an <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>.</remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in ascending order according to a key dynamicaly.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="source">An <see cref="T:System.Linq.IOrderedEnumerable`1"/> that contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to order the given element by.</param>
            <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1"/>, whose elements are sorted according to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
            <remarks>The result of this method will only be reactive and observable if source is in fact an <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>.</remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableEnumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,Obtics.Values.IValueProvider{``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in ascending order dynamicaly by using a given comparer.
            </summary>
            <typeparam name="TSource">The type of the elements of the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="source">An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/> that contains elements to sort.</param>
            <param name="keySelector">A function to extract a key from each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property gives the key to order the given element by.</param>
            <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1"/> used to compare key values.</param>
            <returns>An <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>, whose elements are sorted according to a key, or null when either <paramref name="source"/> or <paramref name="keySelector"/> is null.</returns>
            <remarks>The result of this method will only be reactive and observable if source is in fact an <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>.</remarks>
        </member>
        <member name="T:Obtics.Collections.IObservableDictionary`2">
            <summary>
            Observable variation of the IDictionary interface.
            </summary>
            <typeparam name="TKey">Type of the keys.</typeparam>
            <typeparam name="TValue">Type of the values.</typeparam>
        </member>
        <member name="M:Obtics.Collections.IObservableDictionary`2.ContainsKey(Obtics.Values.IValueProvider{`0})">
            <summary>
            Determines live if a certain live key exists in the dictionary.
            </summary>
            <param name="key">The <see cref="T:Obtics.Values.IValueProvider`1"/> for the key</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> of a boolean indicating if the dictionary contains the key. If <paramref name="key"/> equals null then null will be returned instead.</returns>
            <remarks>
            Whenever the collection in the dictionary or the key delivered by <paramref name="key"/> changes the
            value delivered by the result provider will be updated.
            </remarks>
        </member>
        <member name="P:Obtics.Collections.IObservableDictionary`2.Item(Obtics.Values.IValueProvider{`0})">
            <summary>
            Gets a live value from this dictionary with a live key.
            </summary>
            <param name="key">The <see cref="T:Obtics.Values.IValueProvider`1"/> for the key</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> for the value. If <paramref name="key"/> equals null then null will be returned instead.</returns>
            <remarks>
            Whenever the collection in the dictionary or the key delivered by <paramref name="key"/> changes the
            value delivered by the result provider will be updated.
            </remarks>
        </member>
        <member name="T:Obtics.Values.Transformations.CascadingTransformationBase`5">
            <summary>
            Base class for Cascading value transformations
            </summary>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TOut"></typeparam>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TItm"></typeparam>
            <typeparam name="TPrms"></typeparam>
            <remarks>
            A Cascading value transformation means a 2 step transformation. The first step produces an observable
            result (itm) and the final result is produced by the second step from itm. So two sources of change 
            notifications are being tracked. 1st Source itself and 2nd the result of some transformation of source.
            The final result is presented as a valueprovider so a client needs to track changes in this result valueprovider only.
            </remarks>
        </member>
        <member name="M:Obtics.Values.Transformations.CascadingTransformationBase`5.ItmFromSource">
            <summary>
            Transformation that produces the intermediary result from Source
            </summary>
            <returns>the intermediary result</returns>
        </member>
        <member name="P:Obtics.Values.Transformations.CascadingTransformationBase`5.Buffer">
            <summary>
            The stored intermediary result.
            </summary>
            <remarks>
            This result is stored only when this object has clients listening for property changes.  
            </remarks>
        </member>
        <member name="F:Obtics.Values.MapInfo.GenericPrmsCount">
            <summary>
            True if we are dealing with generic methods.
            if true then the source and target methods should take the exact same type parameters
            </summary>
        </member>
        <member name="F:Obtics.Values.MapInfo.ResultDirectlyObservable">
             <summary>
            if true:
            The result of the target methods are declared as same type as source method but is observable
            (like IEnumerable -> IEnumerable with INotifyCollectionChanged)
            
            if false:
            The target methods return an IValueProvider&lt;TResult&gt;
             </summary>
        </member>
        <member name="F:Obtics.Values.MapInfo.NeedsUpcast">
            <summary>
            In combination with ResultDirectlyObservable. The result of the Target methods is a specialization
            of the result of the source method and should be upcast to the source type to ensure compatibility. 
            </summary>
        </member>
        <member name="T:Obtics.Values.ExpressionObserverObject">
            <summary>
            ExpressionObserver instance class. 
            </summary>
            <remarks>
            This class allows extension of the ExpressionObserver. Via an <see cref="T:Obtics.Values.ExpressionObserverMaster"/> method mappings
            can be added and removed from the observer.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Rewrite(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Rewrites a LambdaExpression to a new reactive LambdaExpression that will return an IValueProvider;
            </summary>
            <param name="original">The original, presumably not-observable LambdaExpression</param>
            <returns>
            Reactive LambdaExpression which in turn will return an IValueProvider of the original return type.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this LambdaExpression form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.       
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Rewrite``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Rewrites a LambdaExpression that returns <typeparamref name="TResult"/> to a LambdaExpression that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            This <see cref="T:Obtics.Values.IValueProvider`1"/> will be reactive to changes of observable dependencies of the original LambdaExpression. 
            </summary>
            <typeparam name="TResult">Type of the result returned by the <paramref name="original"/> LambdaExpression (when compiled) and type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the <see cref="T:Obtics.Values.IValueProvider`1"/> returned by the rewritten LambdaExpression</typeparam>
            <param name="original">The original, presumably not-observable, LambdaExpression ((<see cref="T:System.Linq.Expressions.Expression`1"/>)). The return value of this LambdaExpression when compiled should be <typeparamref name="TResult"/>.</param>
            <returns>
            A LambdaExpression which when compiled will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this LambdaExpression form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.       
            </remarks>        
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Rewrite``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Rewrites a LambdaExpression that returns <typeparamref name="TResult"/> to a LambdaExpression that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            This <see cref="T:Obtics.Values.IValueProvider`1"/> will be reactive to changes of observable dependencies of the original LambdaExpression. 
            </summary>
            <typeparam name="TPrm1">Type of argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TResult">Type of the result returned by the <paramref name="original"/> LambdaExpression (when compiled) and type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the <see cref="T:Obtics.Values.IValueProvider`1"/> returned by the rewritten LambdaExpression</typeparam>
            <param name="original">The original, presumably not-observable, LambdaExpression (<see cref="T:System.Linq.Expressions.Expression`1"/>). The return value of this LambdaExpression when compiled should be <typeparamref name="TResult"/>.</param>
            <returns>
            A LambdaExpression which when compiled will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this LambdaExpression form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.       
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Rewrite``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
            <summary>
            Rewrites a LambdaExpression that returns <typeparamref name="TResult"/> to a LambdaExpression that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            This <see cref="T:Obtics.Values.IValueProvider`1"/> will be reactive to changes of observable dependencies of the original LambdaExpression. 
            </summary>
            <typeparam name="TPrm1">Type of the first argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TPrm2">Type of the second argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TResult">Type of the result returned by the <paramref name="original"/> LambdaExpression (when compiled) and type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the <see cref="T:Obtics.Values.IValueProvider`1"/> returned by the rewritten LambdaExpression</typeparam>
            <param name="original">The original, presumably not-observable, LambdaExpression ((<see cref="T:System.Linq.Expressions.Expression`1"/>)). The return value of this LambdaExpression when compiled should be <typeparamref name="TResult"/>.</param>
            <returns>
            A LambdaExpression which when compiled will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this LambdaExpression form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.       
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Rewrite``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}})">
            <summary>
            Rewrites a LambdaExpression that returns <typeparamref name="TResult"/> to a LambdaExpression that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            This <see cref="T:Obtics.Values.IValueProvider`1"/> will be reactive to changes of observable dependencies of the original LambdaExpression. 
            </summary>
            <typeparam name="TPrm1">Type of the first argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TPrm2">Type of the second argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TPrm3">Type of the third argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TResult">Type of the result returned by the <paramref name="original"/> LambdaExpression (when compiled) and type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the <see cref="T:Obtics.Values.IValueProvider`1"/> returned by the rewritten LambdaExpression</typeparam>
            <param name="original">The original, presumably not-observable, LambdaExpression ((<see cref="T:System.Linq.Expressions.Expression`1"/>)). The return value of this LambdaExpression when compiled should be <typeparamref name="TResult"/>.</param>
            <returns>
            A LambdaExpression which when compiled will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this LambdaExpression form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.       
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Rewrite``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}})">
            <summary>
            Rewrites a LambdaExpression that returns <typeparamref name="TResult"/> to a LambdaExpression that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            This <see cref="T:Obtics.Values.IValueProvider`1"/> will be reactive to changes of observable dependencies of the original LambdaExpression. 
            </summary>
            <typeparam name="TPrm1">Type of the first argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TPrm2">Type of the second argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TPrm3">Type of the third argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TPrm4">Type of the fourth argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TResult">Type of the result returned by the <paramref name="original"/> LambdaExpression (when compiled) and type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the <see cref="T:Obtics.Values.IValueProvider`1"/> returned by the rewritten LambdaExpression</typeparam>
            <param name="original">The original, presumably not-observable, LambdaExpression ((<see cref="T:System.Linq.Expressions.Expression`1"/>)). The return value of this LambdaExpression when compiled should be <typeparamref name="TResult"/>.</param>
            <returns>
            A LambdaExpression which when compiled will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this LambdaExpression form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.       
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Compile(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.LambdaExpression"/> to a new reactive <see cref="T:System.Linq.Expressions.LambdaExpression"/> that will return an IValueProvider and compiles the result.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.LambdaExpression"/></param>
            <returns>
            Reactive <see cref="T:System.Delegate"/> which in turn will return an IValueProvider of the original return type
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.LambdaExpression"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.LambdaExpression"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.LambdaExpression"/> is computationaly equal to a previously compiled <see cref="T:System.Linq.Expressions.LambdaExpression"/>
            then they will return the cached <see cref="T:System.Delegate"/>.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Compile``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/> and compiles the result.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <returns>
            Reactive <see cref="T:System.Func`1"/> which in turn will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/>.</typeparam>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then they will return the cached <see cref="T:System.Func`1"/>.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Compile``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/> and compiles the result.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <typeparam name="TPrm1">Type of the argument for <paramref name="original"/> and the resulting <see cref="T:System.Func`2"/>.</typeparam>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/> and the resulting <see cref="T:System.Func`2"/>.</typeparam>
            <returns>
            Reactive <see cref="T:System.Func`2"/> which in turn will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously rewritten and compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then they will return the cached <see cref="T:System.Func`2"/>.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Compile``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/> and compiles the result.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <typeparam name="TPrm1">Type of the first argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`3"/>.</typeparam>
            <typeparam name="TPrm2">Type of the second argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`3"/>.</typeparam>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/> and the resulting <see cref="T:System.Func`3"/>.</typeparam>
            <returns>
            Reactive <see cref="T:System.Func`3"/> which in turn will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously rewritten and compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then they will return the cached <see cref="T:System.Func`3"/>.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Compile``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/> and compiles the result.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <typeparam name="TPrm1">Type of the first argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`4"/>.</typeparam>
            <typeparam name="TPrm2">Type of the second argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`4"/>.</typeparam>
            <typeparam name="TPrm3">Type of the third argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`4"/>.</typeparam>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/> and the resulting <see cref="T:System.Func`4"/>.</typeparam>
            <returns>
            Reactive <see cref="T:System.Func`4"/> which in turn will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously rewritten and compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then they will return the cached <see cref="T:System.Func`4"/>.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Compile``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/> and compiles the result.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <typeparam name="TPrm1">Type of the first argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <typeparam name="TPrm2">Type of the second argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <typeparam name="TPrm3">Type of the third argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <typeparam name="TPrm4">Type of the fourth argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <returns>
            Reactive <see cref="T:System.Func`5"/> which in turn will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously rewritten and compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then they will return the cached <see cref="T:System.Func`5"/>.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Execute``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>, compiles the result and executes it.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <returns>
            Reactive <see cref="T:Obtics.Values.IValueProvider`1"/> or null returned by the compiled <see cref="T:System.Func`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/>.</typeparam>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then the cached <see cref="T:System.Func`1"/> will be executed.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Execute``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>, compiles the result and executes it with the given <paramref name="prm1"/>.
            </summary>
            <param name="prm1">The argument to be passed to the compiled reactive <see cref="T:System.Func`2"/> to get the final result.</param>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <returns>
            Reactive <see cref="T:Obtics.Values.IValueProvider`1"/> or null returned by the compiled <see cref="T:System.Func`2"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <typeparam name="TPrm1">Type of the argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`2"/>.</typeparam>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/>.</typeparam>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then the cached <see cref="T:System.Func`2"/> will be executed.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Execute``3(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>, compiles the result and executes it with the given <paramref name="prm1"/> and <paramref name="prm2"/>.
            </summary>
            <param name="prm1">The first argument to be passed to the compiled reactive <see cref="T:System.Func`3"/> to get the final result.</param>
            <param name="prm2">The second argument to be passed to the compiled reactive <see cref="T:System.Func`3"/> to get the final result.</param>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <returns>
            Reactive <see cref="T:Obtics.Values.IValueProvider`1"/> or null returned by the compiled <see cref="T:System.Func`3"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <typeparam name="TPrm1">Type of the first argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`3"/>.</typeparam>
            <typeparam name="TPrm2">Type of the second argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`3"/>.</typeparam>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/>.</typeparam>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then the cached <see cref="T:System.Func`3"/> will be executed.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Execute``4(``0,``1,``2,System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>, compiles the result and executes it with the given <paramref name="prm1"/>, <paramref name="prm2"/> and <paramref name="prm3"/>.
            </summary>
            <param name="prm1">The first argument to be passed to the compiled reactive <see cref="T:System.Func`4"/> to get the final result.</param>
            <param name="prm2">The second argument to be passed to the compiled reactive <see cref="T:System.Func`4"/> to get the final result.</param>
            <param name="prm3">The third argument to be passed to the compiled reactive <see cref="T:System.Func`4"/> to get the final result.</param>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <returns>
            Reactive <see cref="T:Obtics.Values.IValueProvider`1"/> or null returned by the compiled <see cref="T:System.Func`4"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <typeparam name="TPrm1">Type of the first argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`4"/>.</typeparam>
            <typeparam name="TPrm2">Type of the second argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`4"/>.</typeparam>
            <typeparam name="TPrm3">Type of the third argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`4"/>.</typeparam>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/>.</typeparam>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then the cached <see cref="T:System.Func`4"/> will be executed.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverObject.Execute``5(``0,``1,``2,``3,System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>, compiles the result and executes it with the given <paramref name="prm1"/>, <paramref name="prm2"/>, <paramref name="prm3"/> and <paramref name="prm4"/>.
            </summary>
            <param name="prm1">The first argument to be passed to the compiled reactive <see cref="T:System.Func`5"/> to get the final result.</param>
            <param name="prm2">The second argument to be passed to the compiled reactive <see cref="T:System.Func`5"/> to get the final result.</param>
            <param name="prm3">The third argument to be passed to the compiled reactive <see cref="T:System.Func`5"/> to get the final result.</param>
            <param name="prm4">The fourth argument to be passed to the compiled reactive <see cref="T:System.Func`5"/> to get the final result.</param>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <returns>
            Reactive <see cref="T:Obtics.Values.IValueProvider`1"/> or null returned by the compiled <see cref="T:System.Func`5"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <typeparam name="TPrm1">Type of the first argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <typeparam name="TPrm2">Type of the second argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <typeparam name="TPrm3">Type of the third argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <typeparam name="TPrm4">Type of the fourth argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/>.</typeparam>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then the cached <see cref="T:System.Func`5"/> will be executed.
            </remarks>
        </member>
        <member name="P:Obtics.Values.ExpressionObserverObject.Default">
            <summary>
            Returns the default ExpressionObserverObject.
            </summary>
            <permission cref="T:Obtics.Configuration.ExtendObticsPermission">Is needed for setting this property.</permission>
        </member>
        <member name="T:Obtics.Values.ExpressionObserverMaster">
            <summary>
            Controls manipulation of a ExpressionObserverObject
            </summary>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMaster.#ctor">
            <summary>
            Creates a master of an ExpressionServerObject without any mappings.
            </summary>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMaster.#ctor(Obtics.Values.ExpressionObserverObject)">
            <summary>
            Create master and copy all mappings from a given ExpressionServerObject
            </summary>
            <param name="sourceExpressionServerObject">ExpressionServerObject to copy the mappings from.</param>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMaster.Add(System.Reflection.MethodInfo,System.Reflection.MethodInfo[])">
            <summary>
            Add method mapping to ExpressionObserverObject.
            </summary>
            <param name="sourceMethod">Method to map</param>
            <param name="targetMethods">Reactive methods to map to.</param>
            <remarks>
            Source method can be static or instance members, generic or member of a generic type.
            target methods must always be static members of a non-generic type. If source is instance member then the 'this' value is mapped
            to the first parameter of the target method.
            
            so
            <code>
            class X&lt;T&gt;
            {
                static T Method1( T p );
                T Method2( T p );
                static T Method3&lt;T2;&gt;( T p, T2 p2 );
            }
            </code>
            
            can be mapped to:
            
            <code>
            class XMapp
            {
                static IValueProvider&lt;T&gt; Method1&lt;T&gt;( IValueProvider&lt;T&gt; p );
                static IValueProvider&lt;T&gt; Method2&lt;T&gt;( X t, IValueProvider&lt;T&gt; p );
                static IValueProvider&lt;T&gt; Method3&lt;T,T2&gt;( T p, IValueProvider&lt;T2&gt; p2 );
            }
            </code>
            
            Multiple target methods can be given. Each can take different mapped parameters
            
            The total of type parameters of the source method including the type paramters of it's declaring type are
            the type parameters of the target methods.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMaster.Add(System.Reflection.PropertyInfo,System.Reflection.MethodInfo[])">
            <summary>
            Add property mapping to ExpressionObserverObject.
            </summary>
            <param name="sourceProperty">Property to map</param>
            <param name="targetMethods">Reactive methods to map to.</param>
            <remarks>
            Source property can be static or instance member of a generic or non-generic type.
            target methods must always be static members of a non-generic type. If source is instance member then the 'this' value is mapped
            to the first parameter of the target method.
            
            so
            <code>
            class X&lt;T&gt;
            {
                public static T Prop1{ get; }
                public T Prop2{ get; }
            }
            </code>
            
            can be mapped to:
            
            <code>
            class XMapp
            {
                public static IValueProvider&lt;T&gt; Prop1&lt;T&gt;( );
                public static IValueProvider&lt;T&gt; Prop2&lt;T&gt;( X&lt;T&gt; p );
            }
            </code>
            
            Multiple target methods can be given. Each can take different mapped parameters
            
            The total of type parameters of the source method including the type paramters of it's declaring type are
            the type parameters of the target methods.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMaster.Add(System.Reflection.FieldInfo,System.Reflection.MethodInfo[])">
            <summary>
            Add field mapping to ExpressionObserverObject.
            </summary>
            <param name="sourceField">Field to map</param>
            <param name="targetMethods">Reactive methods to map to.</param>
            <remarks>
            Source field can be static or instance member of a generic or non-generic type.
            target methods must always be static members of a non-generic type. If source is instance member then the 'this' value is mapped
            to the first parameter of the target method.
            
            so
            <code>
            class X&lt;T&gt;
            {
                public static T Field1;
                public T Field2;
            }
            </code>
            
            can be mapped to:
            
            <code>
            class XMapp
            {
                public static IValueProvider&lt;T&gt; Field1&lt;T&gt;( );
                public static IValueProvider&lt;T&gt; Field2&lt;T&gt;( X&lt;T&gt; p );
            }
            </code>
            
            Multiple target methods can be given. Each can take different mapped parameters
            
            The total of type parameters of the source method including the type paramters of it's declaring type are
            the type parameters of the target methods.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMaster.Add(System.Reflection.MethodInfo,System.Type)">
            <summary>
            Add method mapping to ExpressionObserverObject.
            </summary>
            <param name="sourceMethod">Method to map</param>
            <param name="mappedToClass">Type to find target methods in.</param>
            <remarks>
            Target methods must have same name as source method and have matching arguments.
            
            Source method can be static or instance members, generic or member of a generic type.
            target methods must always be static members of a non-generic type. If source is instance member then the 'this' value is mapped
            to the first parameter of the target method.
            
            The total of type parameters of the source method including the type paramters of it's declaring type are
            the type parameters of the target methods.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMaster.Add(System.Reflection.MethodInfo,System.Type,System.String)">
            <summary>
            Add method mapping to ExpressionObserverObject.
            </summary>
            <param name="sourceMethod">Method to map</param>
            <param name="mappedToClass">Type to find target methods in.</param>
            <param name="targetMethodsName">Name of the target methods.</param>
            <remarks>
            Target methods must have same name as source method and have matching arguments.
            
            Source method can be static or instance members, generic or member of a generic type.
            target methods must always be static members of a non-generic type. If source is instance member then the 'this' value is mapped
            to the first parameter of the target method.
            
            The total of type parameters of the source method including the type paramters of it's declaring type are
            the type parameters of the target methods.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMaster.Add(System.Reflection.PropertyInfo,System.Type)">
            <summary>
            Add property mapping to ExpressionObserverObject.
            </summary>
            <param name="sourceProperty">Property to map</param>
            <param name="mappedToClass">Type to find target methods in.</param>
            <remarks>
            Target method must have same name as source proerty and have matching arguments.
            
            Source property can be static or instance member of a generic or non-generic type.
            target methods must always be static members of a non-generic type. If source is instance member then the 'this' value is mapped
            to the first and only parameter of the target method.
            
            The total of type parameters of the source property declaring type are
            the type parameters of the target methods.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMaster.Add(System.Reflection.PropertyInfo,System.Type,System.String)">
            <summary>
            Add property mapping to ExpressionObserverObject.
            </summary>
            <param name="sourceProperty">Property to map</param>
            <param name="mappedToClass">Type to find target methods in.</param>
            <param name="targetMethodsName">Name of the target methods.</param>
            <remarks>
            Target method must have same name as source proerty and have matching arguments.
            
            Source property can be static or instance member of a generic or non-generic type.
            target methods must always be static members of a non-generic type. If source is instance member then the 'this' value is mapped
            to the first and only parameter of the target method.
            
            The total of type parameters of the source property declaring type are
            the type parameters of the target methods.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMaster.Add(System.Reflection.FieldInfo,System.Type)">
            <summary>
            Add field mapping to ExpressionObserverObject.
            </summary>
            <param name="sourceField">Field to map</param>
            <param name="mappedToClass">Type to find target methods in.</param>
            <remarks>
            Target method must have same name as source field and have matching arguments.
            
            Source field can be static or instance member of a generic or non-generic type.
            target methods must always be static members of a non-generic type. If source is instance member then the 'this' value is mapped
            to the first and only parameter of the target method.
            
            The total of type parameters of the source field declaring type are
            the type parameters of the target methods.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMaster.Add(System.Reflection.FieldInfo,System.Type,System.String)">
            <summary>
            Add field mapping to ExpressionObserverObject.
            </summary>
            <param name="sourceField">Field to map</param>
            <param name="mappedToClass">Type to find target methods in.</param>
            <param name="targetMethodsName">Name of the target methods.</param>
            <remarks>
            Target method must have same name as source field and have matching arguments.
            
            Source field can be static or instance member of a generic or non-generic type.
            target methods must always be static members of a non-generic type. If source is instance member then the 'this' value is mapped
            to the first and only parameter of the target method.
            
            The total of type parameters of the source field declaring type are
            the type parameters of the target methods.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMaster.Remove(System.Reflection.MethodInfo)">
            <summary>
            Remove a method mapping
            </summary>
            <param name="sourceMethod">The source method to remove.</param>
            <returns>True if a mapping existed and was successfuly removed.</returns>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMaster.Remove(System.Reflection.PropertyInfo)">
            <summary>
            Remove a property mapping
            </summary>
            <param name="sourceProperty">The source proeprty to remove.</param>
            <returns>True if a mapping existed and was successfuly removed.</returns>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMaster.Remove(System.Reflection.FieldInfo)">
            <summary>
            Remove a field mapping
            </summary>
            <param name="sourceField">The source field to remove.</param>
            <returns>True if a mapping existed and was successfuly removed.</returns>
        </member>
        <member name="P:Obtics.Values.ExpressionObserverMaster.ExpressionObserver">
            <summary>
            The ExpressionObserverObject governed by this ExpressionObserverMaster
            </summary>
        </member>
        <member name="T:Obtics.Configuration.TypeTypeConverter">
            <summary>
            Internaly used TypeConverter that converts a string to a <see cref="T:System.Type"/> object.
            </summary>
        </member>
        <member name="T:Obtics.Configuration.ObticsConfigurationSection">
            <summary>
            Configuration section for Obtics.
            </summary>
            <remarks>The name of this configuration section is 'Obtics'.</remarks>
        </member>
        <member name="F:Obtics.Configuration.ObticsConfigurationSection.ObticsAsyncConfigurationSectionName">
            <summary>
            The name of the configuration section serviced by <see cref="T:Obtics.Configuration.ObticsConfigurationSection"/>.
            </summary>
        </member>
        <member name="F:Obtics.Configuration.ObticsConfigurationSection.DefaultWorkQueueProviderAttributeName">
            <summary>
            Name of the DefaultWorkQueueProvider configuration attribute.
            </summary>
        </member>
        <member name="F:Obtics.Configuration.ObticsConfigurationSection.CollectionAdaptersElementName">
            <summary>
            CollectionAdaptersElementName
            </summary>
        </member>
        <member name="M:Obtics.Configuration.ObticsConfigurationSection.GetDefaultWorkQueueProviderInstance">
            <summary>
            Gets a new instance of the <see cref="P:Obtics.Configuration.ObticsConfigurationSection.DefaultWorkQueueProviderType"/>.
            </summary>
            <returns>A newly created instance of the <see cref="P:Obtics.Configuration.ObticsConfigurationSection.DefaultWorkQueueProviderType"/>.</returns>
        </member>
        <member name="P:Obtics.Configuration.ObticsConfigurationSection.DefaultWorkQueueProviderType">
            <summary>
            DefaultWorkQueueProviderType, the type of the DefaultWorkQueueProvider.
            </summary>
            <remarks>The name of the configuration attribute of this property is 'DefaultWorkQueueProvider'</remarks>
            <seealso cref="P:Obtics.Async.WorkQueue.DefaultWorkQueueProvider"/>
        </member>
        <member name="P:Obtics.Configuration.ObticsConfigurationSection.CollectionAdapters">
            <summary>
            CollectionAdapterConfigurationElementCollection
            </summary>
        </member>
        <member name="T:Obtics.Configuration.ObticsConfigurationSection.DefaultWorkQueueProviderValidatorClass">
            <summary>
            Validator for the DefaultWorkQueueProvider configuration attribute.
            Expects the string given to represent a Type implementing <see cref="T:Obtics.Async.IWorkQueueProvider"/>
            and having a default constructor.
            </summary>
        </member>
        <member name="F:Obtics.Configuration.ObticsConfigurationSection.DefaultWorkQueueProviderValidatorClass.DefaultWorkQueueProviderValidatorName">
            <summary>
            Name of the DefaultWorkQueueProviderValidator method.
            </summary>
        </member>
        <member name="M:Obtics.Configuration.ObticsConfigurationSection.DefaultWorkQueueProviderValidatorClass.DefaultWorkQueueProviderValidator(System.Object)">
            <summary>
            Verifies that the given type is a valid WorkQueueProvider
            </summary>
            <param name="typeObj">The <see cref="T:System.Type"/> object that needs to be verified.</param>
        </member>
        <member name="T:Obtics.Collections.Transformations.SortTransformationBase`4">
            <summary>
            Base for sorting transformations
            </summary>
            <typeparam name="TType">Type of the result collection elements.</typeparam>
            <typeparam name="TKey">Type of the key to sort by.</typeparam>
            <typeparam name="TSource">Type of the source collection, which must atleast be an IEnumerable&lt;Pair&lt;TType,TKey&gt;&gt;. </typeparam>
            <typeparam name="TPrms">The type of the parameters struct.</typeparam>
        </member>
        <member name="T:Obtics.Collections.Transformations.OpaqueTransformationBase`3">
            <summary>
            Base class for collection transformations
            Opaque means that the immedate result is independent of the source. As a result there may be a difference
            between source NCC sequence number and buffer sequence number and the buffer depends on a correct order
            of processed NCC events. 
            </summary>
            <typeparam name="TOut">The type of the elements of the result collection</typeparam>
            <typeparam name="TSource">The type of our source</typeparam>
            <typeparam name="TPrms">The type of the parameters struct.</typeparam>
            <remarks>
            This class is base on SourcedObject&lt;TSource&gt; and adds implementations for IEnumerable&lt;TOut&gt; and INotifyCollectionChanged
            
            It also implements basic plumbing for event handling and notification.
            </remarks>
        </member>
        <member name="M:Obtics.Collections.Transformations.OpaqueTransformationBase`3.ProcessSourceChangedNotification2(System.Object,Obtics.INCollectionChangedEventArgs)">
            <summary>
            ProcessSourceCollectionChangeNotification2 abstract method
            </summary>
            
            <param name="args"></param>
            <param name="sender"></param>
            <remarks>
            override in derived classes to implement OnSourceCollectionChanged functionality
            </remarks>
        </member>
        <member name="M:Obtics.Collections.Transformations.OpaqueTransformationBase`3.PrepareSnapshot">
            <summary>
            Prepare a snapshot enumerator
            </summary>
            <returns></returns>
            <remarks>
            Prepares the enumerator but does not actually copy the sequence contents. It makes a note
            that when a sequence changing operation is about to be performed and this emumerator
            has not finished yet, a copy of the contents needs to be made.
            
            Most often no copying is needed.
            </remarks>
        </member>
        <member name="M:Obtics.Collections.Transformations.OpaqueTransformationBase`3.TakeSnapshot">
            <summary>
            Check if a note is left and if so and we have a still active enumerator make a copy of the current contents. 
            </summary>
        </member>
        <member name="M:Obtics.Collections.Transformations.OpaqueTransformationBase`3.CreateSnapshotEnumerator">
            <summary>
            Creates a standard enumerator that is used to seed the snapshot emumerator or to take an actual snapshot with.
            </summary>
            <returns></returns>
            <remarks>
            This is not an abstract method. Some derived classes do not use this snapshot mechanism.
            </remarks>
        </member>
        <member name="P:Obtics.Collections.Transformations.OpaqueTransformationBase`3.SnapshotNeedsChecking">
            <summary>
            Flag that indicates that we potentialy have an active enumerator.
            </summary>
        </member>
        <member name="P:Obtics.Collections.Transformations.OpaqueTransformationBase`3.SourceContentVersion">
            <summary>
            The current NCC sequence number of the source, as far as we known.
            </summary>
        </member>
        <member name="P:Obtics.Collections.Transformations.OpaqueTransformationBase`3.InternalContentVersion">
            <summary>
            Our NCC sequence number. Increased every time we broadcast an NCC event.
            </summary>
        </member>
        <member name="T:Obtics.Collections.IObservableOrderedEnumerable`1">
            <summary>
            An observable variation of the <see cref="T:System.Linq.IOrderedEnumerable`1"/> interface.
            </summary>
            <typeparam name="TElement">Type of the elements of the sequence represented by this interface.</typeparam>
        </member>
        <member name="M:Obtics.Collections.IObservableOrderedEnumerable`1.CreateOrderedEnumerable``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0},System.Boolean)">
            <summary>
            CreateOrderedEnumerable overload that returns an <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>.
            It performs a subsequent ordering on the elements of an <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>
                according to a key.
            </summary>
            <typeparam name="TKey">The type of the key produced by <paramref name="keySelector"/>.</typeparam>
            <param name="keySelector">The <see cref="T:System.Func`2"/> used to extract the key for each element.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> used to compare keys for placement in the returned sequence.</param>
            <param name="descending">true to sort the elements in descending order; false to sort the elements in ascending order.</param>
            <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1"/> whose elements are sorted according to a key.</returns>
            <remarks>The <see cref="M:System.Linq.IOrderedEnumerable`1.CreateOrderedEnumerable``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0},System.Boolean)"/> implementation should return an
            <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/> instance up casted to <see cref="T:System.Linq.IOrderedEnumerable`1"/>.</remarks>
        </member>
        <member name="M:Obtics.Collections.IObservableOrderedEnumerable`1.CreateOrderedEnumerable``1(System.Func{`0,Obtics.Values.IValueProvider{``0}},System.Collections.Generic.IComparer{``0},System.Boolean)">
            <summary>
            Performs a subsequent ordering on the elements of an <see cref="T:Obtics.Collections.IObservableOrderedEnumerable`1"/>
                according to a dynamic key.
            </summary>
            <typeparam name="TKey">The type of the key produced by <paramref name="keySelector"/>.</typeparam>
            <param name="keySelector">The <see cref="T:System.Func`2"/> used to extract the key for each element. It returns an <see cref="T:Obtics.Values.IValueProvider`1"/> whose <typeparamref name="TKey"/> Value property provides the key for the given element.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> used to compare keys for placement in the returned sequence.</param>
            <param name="descending">true to sort the elements in descending order; false to sort the elements in ascending order.</param>
            <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1"/> whose elements are sorted according to a key.</returns>
        </member>
        <member name="T:Obtics.Collections.Transformations.SkipTransformation`1">
            <summary>
            Skips an X number of elements from the source to return the remaining elements.
            </summary>
            <typeparam name="TType"></typeparam>
        </member>
        <member name="T:Obtics.Collections.Transformations.CommunicativeAggregateBase`5">
            <summary>
            Base class for aggregates where all elements of the source sequence contribute to the result value in a
            way that is independent of the order in which they occur. The contribution of each individual element can
            also be substracted of the result.
            </summary>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TOut"></typeparam>
            <typeparam name="TAcc"></typeparam>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TPrms"></typeparam>
        </member>
        <member name="M:Obtics.Collections.Transformations.CommunicativeAggregateBase`5.AddItem(`0,`2)">
            <summary>
            Add the contribution of this item to the result value.
            </summary>
            <param name="item"></param>
            <param name="total"></param>
            <returns></returns>
        </member>
        <member name="M:Obtics.Collections.Transformations.CommunicativeAggregateBase`5.RemoveItem(`0,`2)">
            <summary>
            Remove the contribution of this item from the result value.
            </summary>
            <param name="item"></param>
            <param name="total"></param>
            <returns></returns>
        </member>
        <member name="M:Obtics.Collections.Transformations.CommunicativeAggregateBase`5.GetResult(`2)">
            <summary>
            Calculate the final result from the accumulated (intermediate) value.
            </summary>
            <param name="total"></param>
            <returns></returns>
        </member>
        <member name="T:Obtics.Collections.CollectionCap`1">
            <summary>
            Serves as a 'Cap' on a transformation pipeline. It hides the transformation internals (by not exposing the source)
            and provides buffered access to transformation contents.
            </summary>
            <typeparam name="TType"></typeparam>
        </member>
        <member name="T:Obtics.Collections.Transformations.TranslucentTransformationBase`3">
            <summary>
            Base class for collection transformations
            Translucent means that the immediate result depends both on buffered information and source information.
            This means that propblems will occure when the source and buffer happen to be out of step.
            TranslucentTransformationBase resolves that by sending a Reset collection changed event to the clients if
            such a situation is detected.
            </summary>
            <typeparam name="TOut">The type of the elements of the result collection</typeparam>
            <typeparam name="TSource">The type of our source</typeparam>
            <typeparam name="TPrms">The type of the parameters struct.</typeparam>
            <remarks>
            This class is base on <see cref="T:Obtics.Collections.Transformations.OpaqueTransformationBase`3"/> and adds implementations for <see cref="T:System.Collections.Generic.IEnumerable`1"/> and <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/>
            
            It also implements basic plumbing for event handling and notification.
            </remarks>
        </member>
        <member name="M:Obtics.Collections.Transformations.TranslucentTransformationBase`3.UpdateResultIsHidden(System.Boolean,System.Boolean)">
            <summary>
            When result gets hidden ClientsSNDisordered becomes false
            </summary>
            <param name="newValue"></param>
            <param name="oldValue"></param>
        </member>
        <member name="M:Obtics.Collections.Transformations.TranslucentTransformationBase`3.CheckSourceContentVersion(Obtics.Collections.IVersionedEnumerator)">
            <summary>
            We construct a result. If we detect that our source has already progeressed
            (but we haven't received an update yet) we know we can not create a proper result
            (depends on both internal state and our source. The should be in sync)
            We should return an empty list and make a note that our clients are Sequence
            disordered.
            A change event should be on the way and when it arrives we will send a reset to
            all our clients.
            </summary>
            <param name="sourceEnumerator"></param>
            <returns></returns>
        </member>
        <member name="T:Obtics.Async.IWorkQueueProvider">
            <summary>
            Interface for an <see cref="T:Obtics.Async.IWorkQueue"/> provider.
            </summary>
        </member>
        <member name="M:Obtics.Async.IWorkQueueProvider.GetWorkQueue">
            <summary>
            Gets a work queue
            </summary>
            <returns>An <see cref="T:Obtics.Async.IWorkQueue"/> implementation that can be used to queue workitems for delayed processing.</returns>
            <remarks>This method should be thread safe.
            Depending on the context each call may return a different <see cref="T:Obtics.Async.IWorkQueue"/> object. In a multithreaded environment,
            for example, the returned work queue may be a different one for each thread.
            </remarks>
        </member>
        <member name="T:Obtics.Values.ExpressionRewriter">
            <summary>
            Does the actual heavy lifting when rewriting non-live expressions to live ones.
            </summary>
        </member>
        <member name="M:Obtics.Values.ExpressionRewriter.#ctor(Obtics.Values.ExpressionObserverObject,System.Collections.Generic.Dictionary{System.Linq.Expressions.Expression,System.Int32},Obtics.Values.ExpressionRewriter.ParamCountContainer)">
            <summary>
            Constructor
            </summary>
            <param name="traceableExpressions"></param>
            <param name="methodMappings"></param>
            <param name="pcc"></param>
        </member>
        <member name="M:Obtics.Values.ExpressionRewriter.MemberIsValueProviderValueProperty(System.Reflection.MemberInfo)">
            <summary>
            Determine if the given MemberInfo represents the Value property of an IValueProvider.
            </summary>
            <param name="memberInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Obtics.Values.ExpressionRewriter.IsStaticMethodCall(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression@)">
            <summary>
            Determine if the give Expression represents a call to the ValueProvider.Static method; 
            </summary>
            <param name="exp"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:Obtics.Values.ExpressionRewriter.MakeUnlimitedConvertCall(System.Linq.Expressions.Expression,System.Boolean)">
            <summary>
            Build a Call to ObservableEnumerable.Convert version that takes an array ('infinit' number) of ValuProviders
            </summary>
            <param name="nextExp">The select method body.</param>
            <param name="cascading">If true the body returns an IValueProvider we can pass through directly; If false the body returns the value we have to create an IValueProvider for.</param>
            <returns>An expression that gives an IValueProvider with the value.</returns>
        </member>
        <member name="M:Obtics.Values.ExpressionRewriter.MakeLimitedConvertCall(System.Linq.Expressions.Expression,System.Boolean)">
            <summary>
            Build a Call to ObservableEnumerable.Convert version that takes a limited (1-4) number of IValueProvider arguments.
            </summary>
            <param name="nextExp">The select method body.</param>
            <param name="cascading">If true the body returns an IValueProvider we can pass through directly; If false the body returns the value we have to create an IValueProvider for.</param>
            <returns>An expression that gives an IValueProvider with the value.</returns>
        </member>
        <member name="M:Obtics.Values.ExpressionRewriter.Observe(System.Linq.Expressions.Expression)">
            <summary>
            Take the top level expression. Walk down the tree to find observable dependencies.
            These dependencies will be rewritten as IValueProviders. In the toplevel expression
            we will replace these dependencies by references to the Value properties of 
            IValueProvider arguments. This top level expression with the observable dependencies replaced
            will become the body of a lambda expression. This lambda expression and the rewritten
            dependencies (IValueProviders) will become the arguments to a call to ValueProvider.Convert.
            This Convert will give us an IValueProvider yielding the original result of our toplevel expression
            as the Value of this IValueProvider.
            
            It is evident that the observable dependencies themselves will be rewritten using a recursive
            invocation of this method.
            </summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="T:Obtics.Collections.Transformations.IndexedTranslator`1">
            <summary>
            Collection changed notification translating buffer for indexed tranformations.
            </summary>
            <typeparam name="TType"></typeparam>
        </member>
        <member name="T:Obtics.Collections.Transformations.TakeTransformation`1">
            <summary>
            Returns the first X number of elements from the source and ommits the remaining elements.
            </summary>
            <typeparam name="TType"></typeparam>
        </member>
        <member name="T:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs">
            <summary>
            Extends the <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> class with a property so that the order
            wherein different collection changed events are received can be checked.  
            </summary>
        </member>
        <member name="M:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs.#ctor(Obtics.Collections.VersionNumber,System.Collections.Specialized.NotifyCollectionChangedAction)">
            <summary>
            Initializes a new instance of the <see cref="T:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs"/>
                class that describes a <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>
                change.
            </summary>
            <param name="versionNumber">The sequence number of this event.</param>
            <param name="action">The action that caused the event. This must be set to <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>.</param>
        </member>
        <member name="M:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs.#ctor(Obtics.Collections.VersionNumber,System.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList)">
            <summary>
            Initializes a new instance of the <see cref="T:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs"/>
                class that describes a multi-item change.
            </summary>
            <param name="versionNumber">The sequence number of this event.</param>
            <param name="action">The action that caused the event. This can be set to <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>,
                <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Add"/>, or <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>.
            </param>
            <param name="changedItems"></param>
        </member>
        <member name="M:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs.#ctor(Obtics.Collections.VersionNumber,System.Collections.Specialized.NotifyCollectionChangedAction,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs"/>
                class that describes a one-item change.
            </summary>
            <param name="versionNumber">The sequence number of this event.</param>
            <param name="action">The action that caused the event. This can be set to <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>,
                <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Add"/>, or <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>.</param>
            <param name="changedItem">The item that is affected by the change.</param>
        </member>
        <member name="M:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs.#ctor(Obtics.Collections.VersionNumber,System.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList,System.Collections.IList)">
            <summary>
            Initializes a new instance of the <see cref="T:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs"/>
                class that describes a multi-item <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/>
                change.
            </summary>
            <param name="versionNumber">The sequence number of this event.</param>
            <param name="action">The action that caused the event. This can only be set to System.Collections.Specialized.NotifyCollectionChangedAction.Replace.</param>
            <param name="newItems">The new items that are replacing the original items.</param>
            <param name="oldItems">The original items that are replaced.</param>
            <exception cref="T:System.ArgumentException">If action is not Replace.</exception>
            <exception cref="T:System.ArgumentNullException">If oldItems or newItems is null.</exception>
        </member>
        <member name="M:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs.#ctor(Obtics.Collections.VersionNumber,System.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs"/>
                class that describes a multi-item change or a reset change.
            </summary>
            <param name="versionNumber">The sequence number of this event.</param>
            <param name="action">The action that caused the event. This can be set to <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>,
                <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Add"/>, or <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>.</param>
            <param name="changedItems">The items affected by the change.</param>
            <param name="startingIndex">The index where the change occurred.</param>
            <exception cref="T:System.ArgumentException">If action is not Reset, Add, or Remove, if action is Reset and either changedItems
                is not null or startingIndex is not -1, or if action is Add or Remove and
                startingIndex is less than -1.
            </exception>
            <exception cref="T:System.ArgumentNullException">If action is Add or Remove and changedItems is null.</exception>
        </member>
        <member name="M:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs.#ctor(Obtics.Collections.VersionNumber,System.Collections.Specialized.NotifyCollectionChangedAction,System.Object,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs"/>
                class that describes a one-item change.
            </summary>
            <param name="versionNumber">The sequence number of this event.</param>
            <param name="action">The action that caused the event. This can be set to <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Reset"/>,
                <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Add"/>, or <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Remove"/>.
            </param>
            <param name="changedItem">The item that is affected by the change.</param>
            <param name="index">The index where the change occurred.</param>
            <exception cref="T:System.ArgumentException">
                If action is not Reset, Add, or Remove, or if action is Reset and either
                changedItems is not null or index is not -1.
            </exception>
        </member>
        <member name="M:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs.#ctor(Obtics.Collections.VersionNumber,System.Collections.Specialized.NotifyCollectionChangedAction,System.Object,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs"/>
                class that describes a one-item <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/>
                change.
            </summary>
            <param name="versionNumber">The sequence number of this event.</param>
            <param name="action">The action that caused the event. This can only be set to <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/>.</param>
            <param name="newItem">The new item that is replacing the original item.</param>
            <param name="oldItem">The original item that is replaced.</param>
            <exception cref="T:System.ArgumentException">If action is not Replace.</exception>
        </member>
        <member name="M:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs.#ctor(Obtics.Collections.VersionNumber,System.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList,System.Collections.IList,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs"/>
                class that describes a multi-item <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/>
                change.
            </summary>
            <param name="versionNumber">The sequence number of this event.</param>
            <param name="action">The action that caused the event. This can only be set to <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/>.</param>
            <param name="newItems">The new items that are replacing the original items.</param>
            <param name="oldItems">The original items that are replaced.</param>
            <param name="startingIndex">The index of the begin item of the items that are being replaced.</param>
            <exception cref="T:System.ArgumentException">If action is not Replace.</exception>
            <exception cref="T:System.ArgumentNullException">If oldItems or newItems is null.</exception>
        </member>
        <member name="M:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs.#ctor(Obtics.Collections.VersionNumber,System.Collections.Specialized.NotifyCollectionChangedAction,System.Collections.IList,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs"/>
                class that describes a multi-item <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Move"/>
                change.
            </summary>
            <param name="versionNumber">The sequence number of this event.</param>
            <param name="action">The action that caused the event. This can only be set to <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Move"/>.</param>
            <param name="changedItems">The items affected by the change.</param>
            <param name="index">The new index for the changed items.</param>
            <param name="oldIndex">The old index for the changed items.</param>
            <exception cref="T:System.ArgumentException">If action is not Move or index is less than 0.</exception>
        </member>
        <member name="M:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs.#ctor(Obtics.Collections.VersionNumber,System.Collections.Specialized.NotifyCollectionChangedAction,System.Object,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs"/>
                class that describes a multi-item <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Move"/>
                change.
            </summary>
            <param name="versionNumber">The sequence number of this event.</param>
            <param name="action">The action that caused the event. This can only be set to <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Move"/>.</param>
            <param name="changedItem">The item affected by the change.</param>
            <param name="index">The new index for the changed item.</param>
            <param name="oldIndex">The old index for the changed item.</param>
            <exception cref="T:System.ArgumentException">If action is not Move or index is less than 0.</exception>
        </member>
        <member name="M:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs.#ctor(Obtics.Collections.VersionNumber,System.Collections.Specialized.NotifyCollectionChangedAction,System.Object,System.Object,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs"/>
                class that describes a one-item <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/>
                change.
            </summary>
            <param name="versionNumber">The sequence number of this event.</param>
            <param name="action">The action that caused the event. This can be set to <see cref="F:System.Collections.Specialized.NotifyCollectionChangedAction.Replace"/>.</param>
            <param name="newItem">The new item that is replacing the original item.</param>
            <param name="oldItem">The original item that is replaced.</param>
            <param name="index">The index of the item being replaced.</param>
            <exception cref="T:System.ArgumentException">If action is not Replace.</exception>
        </member>
        <member name="P:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs.CollectionVersion">
            <summary>
            The versionNumber of the collection after processing of the information in this event.
            the event can be processed on a collection with ContentVersion == CollectionVersion.Previous
            </summary>
        </member>
        <member name="T:Obtics.Async.WorkQueueOnThreadPoolProvider">
            <summary>
            <see cref="T:Obtics.Async.IWorkQueueProvider"/> that provides an <see cref="T:Obtics.Async.IWorkQueue"/> based on <see cref="T:System.Threading.ThreadPool"/>.
            </summary>
        </member>
        <member name="T:Obtics.Async.IPrioritizedWorkQueueProvider">
            <summary>
            Interface for an <see cref="T:Obtics.Async.IWorkQueue"/> provider that returns multiple
            prioritized <see cref="T:Obtics.Async.IWorkQueue"/> objects.
            </summary>
            <remarks>
            Any workitems in a work queue of lower priority will only get serviced
            when all workitems in higher priority queues have been serviced. In a 
            multithreaded environment it is not guaranteed that the higher priority 
            work items have completed when a lower priority work item gets serviced.
            </remarks>
        </member>
        <member name="P:Obtics.Async.IPrioritizedWorkQueueProvider.Count">
            <summary>
            Gives the total number of priority levels provided by this provider.
            </summary>
        </member>
        <member name="P:Obtics.Async.IPrioritizedWorkQueueProvider.Item(System.Int32)">
            <summary>
            Gives an <see cref="T:Obtics.Async.IWorkQueue"/> from the total work queue collection.
            </summary>
            <param name="priority">Priority of the requested <see cref="T:Obtics.Async.IWorkQueue"/>. This ranges from 1 upto and including <see cref="P:Obtics.Async.IPrioritizedWorkQueueProvider.Count"/>.</param>
            <returns>The requested <see cref="T:Obtics.Async.IWorkQueue"/>.</returns>
            <remarks>Work queues aquired with lower priority indexes have lower priority than the ones
            aquired with higher priority indexes.</remarks>
        </member>
        <member name="M:Obtics.Async.WorkQueueOnThreadPoolProvider.GetWorkQueue">
            <summary>
            Gets the default <see cref="T:Obtics.Async.IWorkQueue"/> for this adapter.
            </summary>
            <returns>The default <see cref="T:Obtics.Async.IWorkQueue"/> for this adapter.</returns>
            <remarks>The returned <see cref="T:Obtics.Async.IWorkQueue"/> is the work queue with priority == 2; The highest priority.</remarks>
        </member>
        <member name="P:Obtics.Async.WorkQueueOnThreadPoolProvider.Count">
            <summary>
            Gives the total number of prioritized <see cref="T:Obtics.Async.IWorkQueue"/> objects provided by this <see cref="T:Obtics.Async.IPrioritizedWorkQueueProvider"/>.
            </summary>
            <remarks>This number is 2 for this provider.</remarks>
        </member>
        <member name="P:Obtics.Async.WorkQueueOnThreadPoolProvider.Item(System.Int32)">
            <summary>
            Returns an <see cref="T:Obtics.Async.IWorkQueue"/> with specified priority. 
            </summary>
            <param name="priority">Priority of the <see cref="T:Obtics.Async.IWorkQueue"/> to get. This priority can be 1 or 2.</param>
            <returns>The requested <see cref="T:Obtics.Async.IWorkQueue"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The given <paramref name="priority"/> is other than 1 or 2.</exception>
            <remarks>This priority can be 1 or 2.</remarks>
        </member>
        <member name="T:Obtics.Async.WorkQueueOnDispatcherProvider">
            <summary>
            Default <see cref="T:Obtics.Async.IWorkQueueProvider"/> based on <see cref="T:System.Windows.Threading.Dispatcher"/>.
            Schedules workitems with priority <see cref="F:System.Windows.Threading.DispatcherPriority.DataBind"/>.
            </summary>
        </member>
        <member name="M:Obtics.Async.WorkQueueOnDispatcherProvider.GetWorkQueue">
            <summary>
            Gets the default <see cref="T:Obtics.Async.IWorkQueue"/> for this adapter.
            </summary>
            <returns>The default <see cref="T:Obtics.Async.IWorkQueue"/> for this adapter.</returns>
            <remarks>The returned <see cref="T:Obtics.Async.IWorkQueue"/> is the work queue with priority == 2; The highest priority.</remarks>
        </member>
        <member name="P:Obtics.Async.WorkQueueOnDispatcherProvider.Count">
            <summary>
            Gives the total number of prioritized <see cref="T:Obtics.Async.IWorkQueue"/> objects provided by this <see cref="T:Obtics.Async.IPrioritizedWorkQueueProvider"/>.
            </summary>
            <remarks>This number is 2 for this provider.</remarks>
        </member>
        <member name="P:Obtics.Async.WorkQueueOnDispatcherProvider.Item(System.Int32)">
            <summary>
            Returns an <see cref="T:Obtics.Async.IWorkQueue"/> with specified priority. 
            </summary>
            <param name="priority">Priority of the <see cref="T:Obtics.Async.IWorkQueue"/> to get. This priority can be 1 or 2.</param>
            <returns>The requested <see cref="T:Obtics.Async.IWorkQueue"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The given <paramref name="priority"/> is other than 1 or 2.</exception>
            <remarks>This priority can be 1 or 2.</remarks>
        </member>
        <member name="T:Obtics.Values.Transformations.SetReadOnlyTransformation`1">
            <summary>
            ReadOnly
            </summary>
            <typeparam name="TType"></typeparam>
        </member>
        <member name="M:Obtics.Values.Transformations.SetReadOnlyTransformation`1.Create(Obtics.Values.IValueProvider{`0})">
            <summary>
            Constructor, initializes with a source
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Obtics.Values.Transformations.SetReadOnlyTransformation`1.ProtectedGetValue">
            <summary>
            ProtectedValue
            </summary>
        </member>
        <member name="T:Obtics.Collections.Transformations.ConvertTransformation`2">
            <summary>
            Transforms a collection of TIn elements to a collection of TOut elements by
            converting each individual source element by means of a converter Function.
            </summary>
            <typeparam name="TIn">Type of the source elements</typeparam>
            <typeparam name="TOut">Type of the outpus elements</typeparam>
        </member>
        <member name="M:Obtics.Collections.Transformations.LazySnapshotEnumerator.Create``1(Obtics.Collections.Transformations.ILockForLazySnapshotEnumerator,Obtics.Collections.VersionNumber,System.Collections.Generic.IEnumerator{``0})">
            <summary>
            Creates a new lazy snapshot enumerator.
            </summary>
            <typeparam name="TType"></typeparam>
            <param name="transformation"></param>
            <param name="versionNumber"></param>
            <param name="innerEnumerator"></param>
            <returns></returns>
        </member>
        <member name="M:Obtics.Collections.Transformations.LazySnapshotEnumerator.TakeSnapshot``1(Obtics.Collections.Transformations.ILockForLazySnapshotEnumerator,System.Func{System.Collections.Generic.IEnumerator{``0}})">
            <summary>
            A change to the source collection is about to happen. Create an actual copy if needed.
            </summary>
            <typeparam name="TType"></typeparam>
            <param name="transformation">The collection that is about to change.</param>
            <param name="enumeratorGenerator">A function that creates an enumerator if an actual snapshot needs to be created.</param>
        </member>
        <member name="T:Obtics.Collections.Transformations.LazySnapshotEnumerator.VersionNode`1">
            <summary>
            Central node for all ective enumerators. Tied to a particular version of the source collection.
            This will receive the one actual contents copy if it is created.
            </summary>
            <typeparam name="TType"></typeparam>
        </member>
        <member name="T:Obtics.Collections.IVersionedEnumerator`1">
            <summary>
            Typed override of the <see cref="T:Obtics.Collections.IVersionedEnumerator"/> interface.
            </summary>
            <typeparam name="TType">Type of the elements of the enumerated sequence.</typeparam>
        </member>
        <member name="T:Obtics.Collections.IVersionedEnumerator">
            <summary>
            Override of the <see cref="T:System.Collections.IEnumerator"/> interface that provides version information about the sequence being enumerated.
            </summary>
        </member>
        <member name="P:Obtics.Collections.IVersionedEnumerator.ContentVersion">
            <summary>
            The <see cref="T:Obtics.Collections.VersionNumber"/> of the current enumeration. This should not change during the lifetime of this 
            <see cref="T:Obtics.Collections.IVersionedEnumerator"/> object.
            </summary>
        </member>
        <member name="T:Obtics.Collections.VersionRelation">
            <summary>
            Indicates the historic relation between two <see cref="T:Obtics.Collections.VersionNumber"/> values.
            </summary>
        </member>
        <member name="F:Obtics.Collections.VersionRelation.Past">
            <summary>
            The first <see cref="T:Obtics.Collections.VersionNumber"/> is before or is the same as the second <see cref="T:Obtics.Collections.VersionNumber"/>.
            (first &lt;= second)
            </summary>
        </member>
        <member name="F:Obtics.Collections.VersionRelation.Next">
            <summary>
            The first <see cref="T:Obtics.Collections.VersionNumber"/> is the <see cref="T:Obtics.Collections.VersionNumber"/> directly following the second <see cref="T:Obtics.Collections.VersionNumber"/>.
            (first == second + 1)
            </summary>
        </member>
        <member name="F:Obtics.Collections.VersionRelation.Future">
            <summary>
            The first <see cref="T:Obtics.Collections.VersionNumber"/> is further in the future than the next <see cref="T:Obtics.Collections.VersionNumber"/> after the second <see cref="T:Obtics.Collections.VersionNumber"/>.
            (first &gt; second + 1)
            </summary>
        </member>
        <member name="T:Obtics.Collections.VersionNumber">
            <summary>
            ContentVersion is an abstraction of the version number of an object. Whenever an object changes and it has a ContentVersion
            this ContentVersion should become original VersionNumber.Next.
            
            VersionNumbers can be compared to see if the are equal, are in the past, (far)future or is next in line.
            </summary>
        </member>
        <member name="M:Obtics.Collections.VersionNumber.IsInRelationTo(Obtics.Collections.VersionNumber)">
            <summary>
            Compares this <see cref="T:Obtics.Collections.VersionNumber"/> to a current <see cref="T:Obtics.Collections.VersionNumber"/> and returns its historic relation to that current <see cref="T:Obtics.Collections.VersionNumber"/>.
            </summary>
            <param name="current">The <see cref="T:Obtics.Collections.VersionNumber"/> to compare this <see cref="T:Obtics.Collections.VersionNumber"/> to.</param>
            <returns>A <see cref="T:Obtics.Collections.VersionRelation"/> value indicating the historic relation of this <see cref="T:Obtics.Collections.VersionNumber"/> to the <paramref name="current"/> <see cref="T:Obtics.Collections.VersionNumber"/>.</returns>
        </member>
        <member name="M:Obtics.Collections.VersionNumber.IsInRelationTo(System.Nullable{Obtics.Collections.VersionNumber})">
            <summary>
            Compares this <see cref="T:Obtics.Collections.VersionNumber"/> to a nullable current <see cref="T:Obtics.Collections.VersionNumber"/> and returns its historic relation to that current <see cref="T:Obtics.Collections.VersionNumber"/>.
            When the current <see cref="T:Obtics.Collections.VersionNumber"/> is null, this <see cref="T:Obtics.Collections.VersionNumber"/> will always be regarded as in the <see cref="!:SequenceRelation.Future"/>.
            </summary>
            <param name="current">The nullable <see cref="T:Obtics.Collections.VersionNumber"/> to compare this <see cref="T:Obtics.Collections.VersionNumber"/> to.</param>
            <returns>A <see cref="T:Obtics.Collections.VersionRelation"/> value indicating the historic relation of this <see cref="T:Obtics.Collections.VersionNumber"/> to the nullable <paramref name="current"/> <see cref="T:Obtics.Collections.VersionNumber"/>.
            If the <paramref name="current"/> <see cref="T:Obtics.Collections.VersionNumber"/> is null then the result will be <see cref="!:SequenceRelation.Future"/>.</returns>
        </member>
        <member name="M:Obtics.Collections.VersionNumber.Equals(Obtics.Collections.VersionNumber)">
            <summary>
            Compares this <see cref="T:Obtics.Collections.VersionNumber"/> to another and returns true if they are equal.
            </summary>
            <param name="other">The other <see cref="T:Obtics.Collections.VersionNumber"/> to equality compare this <see cref="T:Obtics.Collections.VersionNumber"/> to.</param>
            <returns>Returns true if this <see cref="T:Obtics.Collections.VersionNumber"/> equals the <paramref name="other"/> <see cref="T:Obtics.Collections.VersionNumber"/>.</returns>
        </member>
        <member name="M:Obtics.Collections.VersionNumber.Equals(System.Object)">
            <summary>
            Override of object.Equals method.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with.</param>
            <returns>True if <paramref name="obj"/> is a <see cref="T:Obtics.Collections.VersionNumber"/> and this <see cref="T:Obtics.Collections.VersionNumber"/> equals <paramref name="obj"/> as <see cref="T:Obtics.Collections.VersionNumber"/>.</returns>
        </member>
        <member name="M:Obtics.Collections.VersionNumber.GetHashCode">
            <summary>
            Override of object.GetHashCode
            </summary>
            <returns>A hashcode for this <see cref="T:Obtics.Collections.VersionNumber"/>.</returns>
        </member>
        <member name="M:Obtics.Collections.VersionNumber.op_Equality(Obtics.Collections.VersionNumber,Obtics.Collections.VersionNumber)">
            <summary>
            Equality operator; Compares two <see cref="T:Obtics.Collections.VersionNumber"/> values for equality.
            </summary>
            <param name="firstVersionNumber">The first <see cref="T:Obtics.Collections.VersionNumber"/> to compare.</param>
            <param name="secondVersionNumber">The second <see cref="T:Obtics.Collections.VersionNumber"/> to compare.</param>
            <returns>True if the <paramref name="firstVersionNumber"/> and <paramref name="secondVersionNumber"/> <see cref="T:Obtics.Collections.VersionNumber"/>s are equal and false otherwise.</returns>
        </member>
        <member name="M:Obtics.Collections.VersionNumber.op_Inequality(Obtics.Collections.VersionNumber,Obtics.Collections.VersionNumber)">
            <summary>
            Inequality operator; Compares two <see cref="T:Obtics.Collections.VersionNumber"/> values for inequality.
            </summary>
            <param name="firstVersionNumber">The first <see cref="T:Obtics.Collections.VersionNumber"/> to compare.</param>
            <param name="secondVersionNumber">The second <see cref="T:Obtics.Collections.VersionNumber"/> to compare.</param>
            <returns>True if the <paramref name="firstVersionNumber"/> and <paramref name="secondVersionNumber"/> <see cref="T:Obtics.Collections.VersionNumber"/>s are not equal and false otherwise.</returns>
        </member>
        <member name="M:Obtics.Collections.VersionNumber.ToString">
            <summary>
            Converts the <see cref="T:Obtics.Collections.VersionNumber"/> to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Obtics.Collections.VersionNumber.Next">
            <summary>
            Gives the <see cref="T:Obtics.Collections.VersionNumber"/> that is next after this <see cref="T:Obtics.Collections.VersionNumber"/>.
            </summary>
            <remarks>
            Always:
            <code>
            this.Next.IsInRelationTo(this) == SequenceRelation.Next;
            </code>
            </remarks>
        </member>
        <member name="P:Obtics.Collections.VersionNumber.Previous">
            <summary>
            Gives the <see cref="T:Obtics.Collections.VersionNumber"/> where this <see cref="T:Obtics.Collections.VersionNumber"/> is next after.
            </summary>
            <remarks>
            Always:
            <code>
            this.IsInRelationTo(this.Previous) == SequenceRelation.Next;
            </code>
            </remarks>
        </member>
        <member name="T:Obtics.ObticsEqualityComparer`1">
             <summary>
             This class forms a fix for very strange behaviour when comparing delegates for equality.
             
             Consider the following main function in a console application:
             
                    static void Main(string[] args)
                    {
                        Func&lt;int, int&gt; shallowFunc1 = i =&gt; i + 10;
                        Func&lt;int, int&gt; shallowFunc2 = i =&gt; i + 10;
            
                        Console.Out.WriteLine("shallowFunc1 == shallowFunc2:" + EqualityComparer&lt;Func&lt;int, int&gt;&gt;.Default.Equals(shallowFunc1, shallowFunc2).ToString());
                        Console.Out.WriteLine("shallowFunc1#:" + EqualityComparer&lt;Func&lt;int, int&gt;&gt;.Default.GetHashCode(shallowFunc1).ToString());
                        Console.Out.WriteLine("shallowFunc2#:" + EqualityComparer&lt;Func&lt;int, int&gt;&gt;.Default.GetHashCode(shallowFunc2).ToString());
            
                        Func&lt;Func&lt;int, int&gt;&gt; deepFunc = () =&gt; i =&gt; i + 10;
            
                        Console.Out.WriteLine("deepFunc() == deepFunc():" + EqualityComparer&lt;Func&lt;int, int&gt;&gt;.Default.Equals(deepFunc(), deepFunc()).ToString());
                        Console.Out.WriteLine("deepFunc()#:" + EqualityComparer&lt;Func&lt;int, int&gt;&gt;.Default.GetHashCode(deepFunc()).ToString());
            
                        Expression&lt;Func&lt;Func&lt;int, int&gt;&gt;&gt; deepExp = () =&gt; i =&gt; i + 10;
                        var deepFunc2 = deepExp.Compile();
            
                        Console.Out.WriteLine("deepFunc2() == deepFunc2():" + EqualityComparer&lt;Func&lt;int, int&gt;&gt;.Default.Equals(deepFunc2(), deepFunc2()).ToString());
                        Console.Out.WriteLine("deepFunc2()#:" + EqualityComparer&lt;Func&lt;int, int&gt;&gt;.Default.GetHashCode(deepFunc2()).ToString());
            
                        Console.In.ReadLine();
                    }
            }
            
             This is what I get for output:
            
            
             shallowFunc1 == shallowFunc2:False
             shallowFunc1#:1915136
             shallowFunc2#:1915136
             deepFunc() == deepFunc():True
             deepFunc()#:1915136
             deepFunc2() == deepFunc2():False
             deepFunc2()#:1915136
            
             All hashcodes are equal! This class forms a work arround for that.
             
             
             
             
             </summary>
             <typeparam name="TType"></typeparam>
        </member>
        <member name="T:Obtics.NCToNPC">
            <summary>
            This class maps internally used INotifyChanged events to public INotifyPropertyChanged events.
            </summary>
            <remarks>
            It passes the original INotifyChanged sender as sender of the INotifyPropertyChanged event.
            </remarks>
        </member>
        <member name="E:Obtics.NCToNPC.PropertyChanged">
            <summary>
            PropertyChanged event
            </summary>
        </member>
        <member name="P:Obtics.NCToNPC.HavePropertyChangedListeningClients">
            <summary>
            HavePropertyChangedListeners, true if there are any listeners for the PropertyChanged event.
            </summary>
        </member>
        <member name="T:Obtics.Collections.Transformations.DistinctTransformationBase`3">
            <summary>
            Base class for Distinct transformations. Given an EqualityComparer the result will contain only the 
            first occuring element of a certain equality set.
            </summary>
            <typeparam name="TType">Type of the elements</typeparam>
            <typeparam name="TSource">Type of source. Must implement <see cref="T:Obtics.Collections.IVersionedEnumerable`1"/>.</typeparam>
            <typeparam name="TPrms">Type of the parameter struct.</typeparam>
        </member>
        <member name="T:Obtics.Collections.Transformations.ConvertPairsGroupingTransformation`3">
            <summary>
            Specific purpose transformation (should be internal?)
            Transform a grouping of Pairs of items en keys to a grouping of items.
            </summary>
            <typeparam name="TKey">Type of the key.</typeparam>
            <typeparam name="TItem">Type of the item.</typeparam>
            <typeparam name="TSource">Type of  the source sequence.</typeparam>
            <remarks>
            The first Property of the Pair is the Item and the Second property is the Key. This key should be
            the same as the Key of the group, though it wouldn't matter to this transformation really.
            </remarks>
        </member>
        <member name="T:Obtics.Async.WorkQueueAdapters.HighLowPrioritizedWorkQueueAdapter">
            <summary>
            A work queue adapter that provides a high and low priority queue based on a single parent queue.
            </summary>
        </member>
        <member name="M:Obtics.Async.WorkQueueAdapters.HighLowPrioritizedWorkQueueAdapter.Get(Obtics.Async.IWorkQueue)">
            <summary>
            Aquires a high-low prioritized <see cref="T:Obtics.Async.IPrioritizedWorkQueueProvider"/> based on a gives parent <see cref="T:Obtics.Async.IWorkQueue"/>.
            </summary>
            <param name="queue">The parent <see cref="T:Obtics.Async.IWorkQueue"/> to base the return high-low prioritized <see cref="T:Obtics.Async.IPrioritizedWorkQueueProvider"/> on.</param>
            <returns>A high-low prioritized <see cref="T:Obtics.Async.IPrioritizedWorkQueueProvider"/>.</returns>
            <remarks>The same <see cref="T:Obtics.Async.IPrioritizedWorkQueueProvider"/> will always get returned for the same parent <see cref="T:Obtics.Async.IWorkQueue"/>.</remarks>
        </member>
        <member name="P:Obtics.Async.WorkQueueAdapters.HighLowPrioritizedWorkQueueAdapter.InternalHighLowPrioritizedWorkQueueAdapter.Count">
            <summary>
            The total number of prioritized work queues, which will always be 2 for this object.
            </summary>
        </member>
        <member name="P:Obtics.Async.WorkQueueAdapters.HighLowPrioritizedWorkQueueAdapter.InternalHighLowPrioritizedWorkQueueAdapter.Item(System.Int32)">
            <summary>
            Gives an <see cref="T:Obtics.Async.IWorkQueue"/> from the total work queue collection.
            </summary>
            <param name="priority">Priority of the requested <see cref="T:Obtics.Async.IWorkQueue"/>. This can be either 1 or 2.</param>
            <returns>The requested <see cref="T:Obtics.Async.IWorkQueue"/>.</returns>
            <remarks>Work queues aquired with lower priority indexes have lower priority than the ones
            aquired with higher priority indexes.</remarks>
        </member>
        <member name="T:Obtics.Async.IWorkQueue">
            <summary>
            Interface for a work pool that can be used by Obtics 
            </summary>
        </member>
        <member name="M:Obtics.Async.IWorkQueue.QueueWorkItem(System.Threading.WaitCallback,System.Object)">
            <summary>
            Queue a workitem for later execution.
            </summary>
            <param name="callback">The <see cref="T:System.Threading.WaitCallback"/> delegate that will be called when the workitem is executed.</param>
            <param name="callbackArgument">Any extra arguments for the <paramref name="callback"/> delegate.</param>
            <remarks>Each queued workitem gets executed once. The order in which the individual queued workitems are executed is undetermined.</remarks>
        </member>
        <member name="T:Obtics.Values.StaticValueProvider`1">
            <summary>
            ValueProvider holding a single never changing value.
            </summary>
            <typeparam name="TType">The type of the Value property</typeparam>
            <remarks>
            This ValueProvider doesn't implement INotifyPropertyChanged since none of it's
            properties ever change.
            </remarks>
        </member>
        <member name="F:Obtics.Values.StaticValueProvider`1.ValuePropertyName">
            <summary>
            Propertyname of the Value property
            </summary>
        </member>
        <member name="F:Obtics.Values.StaticValueProvider`1.IsReadOnlyPropertyName">
            <summary>
            Propertyname of the IsReadOnly property
            </summary>
        </member>
        <member name="M:Obtics.Values.StaticValueProvider`1.#ctor(`0)">
            <summary>
            Constructor, Initializes Value with the given value
            </summary>
            <param name="value">The value to assign to the Value property</param>
        </member>
        <member name="M:Obtics.Values.StaticValueProvider`1.Equals(System.Object)">
            <summary>
            Equals override. This object is equal to the parameter if they are of the same type and have the same value.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Obtics.Values.StaticValueProvider`1.Equals(Obtics.Values.StaticValueProvider{`0})">
            <summary>
            This StaticValueProvider&lt;TType&gt; object is equal to another StaticValueProvider&lt;TType&gt; object if they have the same Value.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="P:Obtics.Values.StaticValueProvider`1.Value">
            <summary>
            Value property. Calling the property setter will raise an exception.
            </summary>
        </member>
        <member name="P:Obtics.Values.StaticValueProvider`1.IsReadOnly">
            <summary>
            IsReadOnly property. Always return true for the StaticValueProvider class
            </summary>
        </member>
        <member name="T:Obtics.SIList">
            <summary>
            SIList, static information about the IList interface
            </summary>
        </member>
        <member name="F:Obtics.SIList.ItemsIndexerPropertyName">
            <summary>
            ItemsIndexerPropertyName
            </summary>
        </member>
        <member name="F:Obtics.SIList.ItemsIndexerPropertyChangedEventArgs">
            <summary>
            ItemsIndexerPropertyChangedEventArgs
            </summary>
        </member>
        <member name="F:Obtics.SIList.ItemsIndexerINCEventArgs">
            <summary>
            ItemsIndexerINCEventArgs
            </summary>
        </member>
        <member name="T:Obtics.Comparer.CombinedComparer`2">
            <summary>
            Combines two comparers to form one composite comparer.
            The first comparer has highest priority.
            </summary>
            <typeparam name="TKey1">Type of first value to compare.</typeparam>
            <typeparam name="TKey2">Type of second value to compare.</typeparam>
        </member>
        <member name="T:Obtics.Hasher">
            <summary>
            Struct to help creating a good hash
            </summary>
        </member>
        <member name="T:Obtics.Values.NoMappingsFoundException">
            <summary>
            This exception is raised if a class has been given to <see cref="T:Obtics.Values.ExpressionObserverMaster"/> to search for member mappings, but no matching mappings can be found in the class.
            </summary>
        </member>
        <member name="T:Obtics.Values.MappingException">
            <summary>
            This exception is raised by <see cref="T:Obtics.Values.ExpressionObserverMaster"/> if a sertain member mapping has been given but the
            mapping does not match the member or its sibling mappings.
            </summary>
        </member>
        <member name="M:Obtics.Values.MappingException.#ctor">
            <summary>
            Initializes a new instance of the Obtics.Values.MappingException class.
            </summary>
        </member>
        <member name="M:Obtics.Values.MappingException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the Obtics.Values.MappingException class with a specified
                error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Obtics.Values.MappingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the Obtics.Values.MappingException class with serialized
                data.
            </summary>
            <param name="info">
            The System.Runtime.Serialization.SerializationInfo that holds the serialized
            object data about the exception being thrown.
            </param>
            <param name="context">
            The System.Runtime.Serialization.StreamingContext that contains contextual 
            information about the source or destination.
            </param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The info parameter is null.</exception>
        </member>
        <member name="M:Obtics.Values.MappingException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the Obtics.Values.MappingException class with a specified
            error message and a reference to the inner exception that is the cause of
            this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference
                (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="M:Obtics.Values.NoMappingsFoundException.#ctor">
            <summary>
            Initializes a new instance of the Obtics.Values.MappingException class.
            </summary>
        </member>
        <member name="M:Obtics.Values.NoMappingsFoundException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the Obtics.Values.MappingException class with a specified
                error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Obtics.Values.NoMappingsFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the Obtics.Values.MappingException class with serialized
                data.
            </summary>
            <param name="info">
            The System.Runtime.Serialization.SerializationInfo that holds the serialized
            object data about the exception being thrown.
            </param>
            <param name="context">
            The System.Runtime.Serialization.StreamingContext that contains contextual 
            information about the source or destination.
            </param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The info parameter is null.</exception>
        </member>
        <member name="M:Obtics.Values.NoMappingsFoundException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the Obtics.Values.MappingException class with a specified
            error message and a reference to the inner exception that is the cause of
            this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference
                (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="T:Obtics.Collections.ICollectionAdapter">
            <summary>
            An interface for objects that can adapt an object of an unknown type of sequence to
            a form Obtics can understand. This adapted form should implement IVersionedEnumerable at least
            and preferably implement <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> for observability. This
            <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> implementation should provide <see cref="T:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs"/>
            for its event arguments.
            </summary>
        </member>
        <member name="M:Obtics.Collections.ICollectionAdapter.AdaptCollection(System.Object)">
            <summary>
            Adapts an unknown collection to a form Obtics can understand.
            </summary>
            <param name="collection">The unkown collection to adapt.</param>
            <returns>An <see cref="T:Obtics.Collections.IVersionedEnumerable"/> implementation that wraps <paramref name="collection"/>.
            It should preferably implement <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> for observability but this is not required. This
            <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> implementation should provide <see cref="T:Obtics.Collections.OrderedNotifyCollectionChangedEventArgs"/>
            for its event arguments.</returns>
        </member>
        <member name="P:Obtics.Collections.Transformations.UnorderedNotifyVpcTransformation`2.Converter">
            <summary>
            publication of Converter specially for DynamicSortTransformation so that it doesn't need
            tp maintain it's own copy.
            </summary>
            <remarks>
            Externally accessed but just returning a truly static value.. no lock
            </remarks>
        </member>
        <member name="T:Obtics.Collections.IObservableLookup`2">
            <summary>
            Observable variation of the ILookup interface.
            </summary>
            <typeparam name="TKey">Type of the keys.</typeparam>
            <typeparam name="TElement">Type of the elements.</typeparam>
        </member>
        <member name="M:Obtics.Collections.IObservableLookup`2.Contains(Obtics.Values.IValueProvider{`0})">
            <summary>
            Observably and reactively determines if a certain key exists in the lookup.
            </summary>
            <param name="key">The provider of the key.</param>
            <returns>A provider of a boolean indicating if the lookup contains the key. If <paramref name="key"/> equal null then null will be returned instead.</returns>
            <remarks>
            Whenever the collection in the lookup or the key delivered by <paramref name="key"/> changes the
            value delivered by the result provider will be updated.
            </remarks>
        </member>
        <member name="P:Obtics.Collections.IObservableLookup`2.Item(Obtics.Values.IValueProvider{`0})">
            <summary>
            Observabley and reactively gets a sequence of elements from this dictionary with a key.
            </summary>
            <param name="key">The provider of the key</param>
            <returns>An observable sequence of elements. If <paramref name="key"/> equal null then null will be returned instead.</returns>
            <remarks>
            Whenever the collection in the lookup or the key delivered by <paramref name="key"/> changes the
            the result sequence will be updated.
            </remarks>
        </member>
        <member name="T:Obtics.Collections.Transformations.GroupingTransformation`2">
            <summary>
            GroupingTransformation takes a source and a key value and forms a Grouping literaly out of the
            given parameters.
            </summary>
            <typeparam name="TKey">Type of the key</typeparam>
            <typeparam name="TElement">Type of the elements</typeparam>
        </member>
        <member name="M:Obtics.Collections.Transformations.GroupingTransformation`2.Create(System.Collections.Generic.IEnumerable{`1},`0)">
            <summary>
            Create
            </summary>
            <param name="source">The source of the elements</param>
            <param name="key">The key value</param>
        </member>
        <member name="M:Obtics.Collections.Transformations.BoundGroupFilterDispenser`2.GetGroup(`1)">
            <summary>
            Returns a group collection by key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Obtics.Collections.Transformations.BoundGroupFilterDispenser`2.EqualityComparer">
            <summary>
            EqualityComparer publication specially for BoundGroupFilterTransformation so that
            it doesn't need its own copy.
            </summary>
        </member>
        <member name="P:Obtics.Collections.Transformations.BoundGroupFilterDispenser`2.Cache">
            <summary>
            Cache publication specially for BoundGroupFilterTransformation so that they can share
            this information. This should be accessed only when we have listeners for source change notifications
            </summary>
        </member>
        <member name="T:Obtics.Collections.Transformations.AnyAggregate">
            <summary>
            Returns true if there is atleast one boolean in the source collection with value == true.
            </summary>
        </member>
        <member name="T:Obtics.Collections.Transformations.UnorderedDistinctTransformationBase`3">
            <summary>
            Base class for Distinct transformations. Given an EqualityComparer the result will contain only the 
            first occuring element of a certain equality set.
            </summary>
            <typeparam name="TType">Type of the elements</typeparam>
            <typeparam name="TSource">Type of source. Must implement <see cref="T:Obtics.Collections.IVersionedEnumerable`1"/>.</typeparam>
            <typeparam name="TPrms">Type of the parameter struct.</typeparam>
        </member>
        <member name="T:Obtics.Collections.Patches.SimplePatch`1">
            <summary>
            Takes a non-patched source and magicks a sequence for it's notify collection changed events. Preferable there should be only
            1 SequencePatch for a given non-versiined source. If this object would receive change notifications out of order then the result
            will be messed up.
            </summary>
            <typeparam name="TType"></typeparam>
        </member>
        <member name="T:Obtics.Collections.Patches.SimplePatch">
            <summary>
            Takes a non-patched source and magicks a sequence for it's notify collection changed events. Preferable there should be only
            1 SequencePatch for a given non-patched source. If this object would receive change notifications out of order then the result
            will be messed up.
            </summary>
        </member>
        <member name="T:Obtics.Async.WorkQueueAdapters.WorkQueueOnThreadPoolAdapter">
            <summary>
            Creates an <see cref="T:Obtics.Async.IWorkQueue"/> based on <see cref="T:System.Threading.ThreadPool"/>.
            </summary>
        </member>
        <member name="M:Obtics.Async.WorkQueueAdapters.WorkQueueOnThreadPoolAdapter.Get">
            <summary>
            Gets the <see cref="T:Obtics.Async.IWorkQueue"/>.
            </summary>
            <returns>The <see cref="T:Obtics.Async.IWorkQueue"/>.</returns>
        </member>
        <member name="M:Obtics.Async.WorkQueueAdapters.WorkQueueOnThreadPoolAdapter.InternalWorkQueueOnThreadPoolAdapter.QueueWorkItem(System.Threading.WaitCallback,System.Object)">
            <summary>
            Queue a workitem for later execution.
            </summary>
            <param name="callback">The <see cref="T:System.Threading.WaitCallback"/> delegate that will be called when the workitem is executed.</param>
            <param name="prm">Any extra arguments for the <paramref name="callback"/> delegate.</param>
            <remarks>Each queued workitem gets executed once. The order in which the individual queued workitems are executed is undetermined.</remarks>
        </member>
        <member name="T:Obtics.Values.RewriterHelper">
            <summary>
            This class contains public methods needed by the system. These methods are not intended to be used by your code.
            </summary>
        </member>
        <member name="M:Obtics.Values.RewriterHelper.Cacher0``1(System.Func{Obtics.Values.IValueProvider{``0}})">
            <summary>
            Provides caching mechanism for a pipeline generated by a given function.
            </summary>
            <typeparam name="TType"></typeparam>
            <param name="generator"></param>
            <returns></returns>
            <remarks>This method is for internal use only and not intended to be used from your code.</remarks>
        </member>
        <member name="M:Obtics.Values.RewriterHelper.Cacher1``2(System.Func{``0,Obtics.Values.IValueProvider{``1}},``0)">
            <summary>
            Provides caching mechanism for a pipeline generated by a given function.
            </summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TType"></typeparam>
            <param name="generator"></param>
            <param name="arg1"></param>
            <returns></returns>
            <remarks>This method is for internal use only and not intended to be used from your code.</remarks>
        </member>
        <member name="M:Obtics.Values.RewriterHelper.Cacher2``3(System.Func{``0,``1,Obtics.Values.IValueProvider{``2}},``0,``1)">
            <summary>
            Provides caching mechanism for a pipeline generated by a given function.
            </summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TType"></typeparam>
            <param name="generator"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
            <remarks>This method is for internal use only and not intended to be used from your code.</remarks>
        </member>
        <member name="M:Obtics.Values.RewriterHelper.Cacher3``4(System.Func{``0,``1,``2,Obtics.Values.IValueProvider{``3}},``0,``1,``2)">
            <summary>
            Provides caching mechanism for a pipeline generated by a given function.
            </summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TType"></typeparam>
            <param name="generator"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <returns></returns>
            <remarks>This method is for internal use only and not intended to be used from your code.</remarks>
        </member>
        <member name="M:Obtics.Values.RewriterHelper.Cacher4``5(System.Func{``0,``1,``2,``3,Obtics.Values.IValueProvider{``4}},``0,``1,``2,``3)">
            <summary>
            Provides caching mechanism for a pipeline generated by a given function.
            </summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
            <typeparam name="TType"></typeparam>
            <param name="generator"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <returns></returns>
            <remarks>This method is for internal use only and not intended to be used from your code.</remarks>
        </member>
        <member name="M:Obtics.Values.RewriterHelper.SelectExt1``2(System.Object[],System.Int32,System.Func{``0,``1})">
            <summary>
            Calls a typed function with a sequence of parameters taken from an untyped array.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="prms"></param>
            <param name="from"></param>
            <param name="func"></param>
            <returns></returns>
            <remarks>This method is for internal use only and not intended to be used from your code.</remarks>
        </member>
        <member name="M:Obtics.Values.RewriterHelper.SelectExt2``3(System.Object[],System.Int32,System.Func{``0,``1,``2})">
            <summary>
            Calls a typed function with a sequence of parameters taken from an untyped array.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="prms"></param>
            <param name="from"></param>
            <param name="func"></param>
            <returns></returns>
            <remarks>This method is for internal use only and not intended to be used from your code.</remarks>
        </member>
        <member name="M:Obtics.Values.RewriterHelper.SelectExt3``4(System.Object[],System.Int32,System.Func{``0,``1,``2,``3})">
            <summary>
            Calls a typed function with a sequence of parameters taken from an untyped array.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="prms"></param>
            <param name="from"></param>
            <param name="func"></param>
            <returns></returns>
            <remarks>This method is for internal use only and not intended to be used from your code.</remarks>
        </member>
        <member name="M:Obtics.Values.RewriterHelper.SelectExt4``5(System.Object[],System.Int32,System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Calls a typed function with a sequence of parameters taken from an untyped array.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="prms"></param>
            <param name="from"></param>
            <param name="func"></param>
            <returns></returns>
            <remarks>This method is for internal use only and not intended to be used from your code.</remarks>
        </member>
        <member name="M:Obtics.Values.RewriterHelper.SafeCall``2(``0,System.Func{``0,``1})">
            <summary>
            Executes a function and returns its result only of its requiered parameter is not null. Will return a default value if the parameter is null.
            </summary>
            <typeparam name="TObject"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="obj"></param>
            <param name="f"></param>
            <returns></returns>
            <remarks>This method is for internal use only and not intended to be used from your code.</remarks>
        </member>
        <member name="T:Obtics.Values.Transformations.IValueTransformationPipelineFactory`2">
            <summary>
            An IValueTransformationPipelineFactory is an object that knows how to create a value transformation pipeline out of a 
            certain input parameter.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Obtics.Values.Transformations.IValueTransformationPipelineFactory`2.Create(`0)">
            <summary>
            Create a pipeline based on a given parameter.
            </summary>
            <param name="key">The input parameter</param>
            <returns>a value transformation pipeline </returns>
            <remarks>
            Typically the result of two separate call to this method with two equal key values
            should yield two equal pipelines.
            </remarks>
        </member>
        <member name="T:Obtics.Configuration.CollectionAdapterConfigurationElementCollection">
            <summary>
            A <see cref="T:System.Configuration.ConfigurationElementCollection"/> of <see cref="T:Obtics.Configuration.CollectionAdapterConfigurationElement"/> objects.
            </summary>
        </member>
        <member name="M:Obtics.Configuration.CollectionAdapterConfigurationElementCollection.CreateNewElement">
            <summary>
            Creates a new element for this collection.
            </summary>
            <returns>A newly created element.</returns>
        </member>
        <member name="M:Obtics.Configuration.CollectionAdapterConfigurationElementCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            Gets a key that uniquely identifies the given element in this collection.
            </summary>
            <param name="element">The element to get the key from.</param>
            <returns>The key of the element.</returns>
        </member>
        <member name="T:Obtics.Configuration.CollectionAdapterConfigurationElement">
            <summary>
            An <see cref="T:System.Configuration.ConfigurationElement"/> that allows the specification of an <see cref="T:Obtics.Collections.ICollectionAdapterProvider"/>
            implementation in a configuration file.
            
            The <see cref="T:Obtics.Collections.ICollectionAdapterProvider"/> should have a parameterless constructor. 
            </summary>
        </member>
        <member name="F:Obtics.Configuration.CollectionAdapterConfigurationElement.CollectionAdapterConfigurationElementName">
            <summary>
            Element name of this ConfigurationElement
            </summary>
        </member>
        <member name="F:Obtics.Configuration.CollectionAdapterConfigurationElement.NameAttributeName">
            <summary>
            AttributeName of the name attribute.
            </summary>
        </member>
        <member name="F:Obtics.Configuration.CollectionAdapterConfigurationElement.TypeAttributeName">
            <summary>
            Name of the Type configuration attribute.
            </summary>
        </member>
        <member name="P:Obtics.Configuration.CollectionAdapterConfigurationElement.Name">
            <summary>
            Name key of this ConfigurationElement instance.
            </summary>
            <remarks>
            This is a required attribute and the key of this information in the collectionAdapters collection.
            The matching attribute is 'name'.
            </remarks>
        </member>
        <member name="P:Obtics.Configuration.CollectionAdapterConfigurationElement.Type">
            <summary>
            Type of the <see cref="T:Obtics.Collections.ICollectionAdapterProvider"/> implementation. This type should provide a public parameterless constructor.
            </summary>
        </member>
        <member name="P:Obtics.Configuration.CollectionAdapterConfigurationElement.Instance">
            <summary>
            Gets a new instance of the <see cref="T:Obtics.Collections.ICollectionAdapterProvider"/>.
            </summary>
            <returns>A newly created instance of the <see cref="T:Obtics.Collections.ICollectionAdapterProvider"/>.</returns>
        </member>
        <member name="T:Obtics.Configuration.CollectionAdapterConfigurationElement.CollectionAdapterTypeValidatorClass">
            <summary>
            Helper class that validates given ICollectionAdapterProvider implementations. 
            </summary>
        </member>
        <member name="F:Obtics.Configuration.CollectionAdapterConfigurationElement.CollectionAdapterTypeValidatorClass.CollectionAdapterTypeValidatorName">
            <summary>
            Name of the CollectionAdapterTypeValidator method.
            </summary>
        </member>
        <member name="M:Obtics.Configuration.CollectionAdapterConfigurationElement.CollectionAdapterTypeValidatorClass.CollectionAdapterTypeValidator(System.Object)">
            <summary>
            Method executed to validate the given object.
            </summary>
            <param name="typeObj">The object to validate.</param>
            <exception cref="T:System.Configuration.ConfigurationErrorsException">Raised of the object is not valid.</exception>
        </member>
        <member name="T:Obtics.Collections.ObservableDictionary`2">
            <summary>
            An observable dictionary
            </summary>
            <typeparam name="TKey">Type of the keys</typeparam>
            <typeparam name="TValue">Type of the values</typeparam>
            <remarks>
            The order of elements is important for this dictionary in the sense that it is always preserved, even though
            the actual order is arbitrary. To be able to preserve this order the dictionary is emplemented as a binary tree
            variation and not as a hash table. 
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates an instance of ObservableDictionary using the given <paramref name="comparer"/> to compare keys.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to comparer keys with.</param>
            <exception cref="T:System.ArgumentNullException">When <paramref name="comparer"/> is null.</exception>
        </member>
        <member name="M:Obtics.Collections.ObservableDictionary`2.#ctor">
            <summary>
            Creates an instance of ObservableDictionary using the default comparer to compare keys.
            </summary>
        </member>
        <member name="M:Obtics.Collections.ObservableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Creates an instance of ObservableDictionary using the default comparer to compare keys and
            copies all key value pairs from the <paramref name="source"/> dictionary into this dictionary.
            </summary>
            <param name="source">The source <see cref="T:System.Collections.Generic.IDictionary`2"/> to copy key value pairs from.</param>
            <exception cref="T:System.ArgumentException">When <paramref name="source"/> contains duplicate keys.</exception>
            <exception cref="T:System.ArgumentNullException">When <paramref name="source"/> is null.</exception>
        </member>
        <member name="M:Obtics.Collections.ObservableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates an instance of ObservableDictionary using the given <paramref name="comparer"/> to compare keys and
            copies all key value pairs from the <paramref name="source"/> dictionary into this dictionary.
            </summary>
            <param name="source">The source <see cref="T:System.Collections.Generic.IDictionary`2"/> to copy key value pairs from.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to comparer keys with.</param>
            <exception cref="T:System.ArgumentException">When <paramref name="source"/> contains duplicate keys.</exception>
            <exception cref="T:System.ArgumentNullException">When <paramref name="source"/> or <paramref name="comparer"/> is null.</exception>
        </member>
        <member name="M:Obtics.Collections.ObservableDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor
            </summary>
            <param name="serializationInfo"></param>
            <param name="streamingContext"></param>
        </member>
        <member name="M:Obtics.Collections.ObservableDictionary`2.ContainsKey(Obtics.Values.IValueProvider{`0})">
            <summary>
            Determines live if a certain live key exists in the dictionary.
            </summary>
            <param name="key">The <see cref="T:Obtics.Values.IValueProvider`1"/> for the key</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> of a boolean indicating if the dictionary contains the key. If <paramref name="key"/> equals null then null will be returned instead.</returns>
            <remarks>
            Whenever the collection in the dictionary or the key delivered by <paramref name="key"/> changes the
            value delivered by the result provider will be updated.
            </remarks>
        </member>
        <member name="M:Obtics.Collections.ObservableDictionary`2.Add(`0,`1)">
            <summary>
            Adds an element with the provided <paramref name="key"/> and <paramref name="value"/> to the dictionary.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the dictionary.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
        </member>
        <member name="M:Obtics.Collections.ObservableDictionary`2.ContainsKey(`0)">
            <summary>
            Determines whether the dictionary contains an element with the specified <paramref name="key"/>.
            </summary>
            <param name="key">The key to find the element with.</param>
            <returns>true if the dictionary contains an element with the key; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
        </member>
        <member name="M:Obtics.Collections.ObservableDictionary`2.Remove(`0)">
            <summary>
            Removes the element with the specified <paramref name="key"/> from the dictionary.
            </summary>
            <param name="key">The key to find and remove the element with.</param>
            <returns>true if the element is found and removed; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
        </member>
        <member name="M:Obtics.Collections.ObservableDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to retrieve a value from the dictionary by key.
            </summary>
            <param name="key">The key to find the value with.</param>
            <param name="value">Out parameter; receives the found value if it can be found; the default value for <typeparamref name="TValue"/> otherwise.</param>
            <returns>A boolean value indicating if the value could be found in the dictionary.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableDictionary`2.Clear">
            <summary>
            Removes all entries from the dictionary.
            </summary>
        </member>
        <member name="M:Obtics.Collections.ObservableDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            removes the given entry from the dictionary if present.
            </summary>
            <param name="item">The entry to remove.</param>
            <returns>A boolean value indicating if the entry could be found and removed; false otherwise.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableDictionary`2.GetEnumerator">
            <summary>
            GetEnumerator override that returns an <see cref="T:Obtics.Collections.IVersionedEnumerator"/> of <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </summary>
            <returns>An <see cref="T:Obtics.Collections.IVersionedEnumerator"/> of <see cref="T:System.Collections.Generic.KeyValuePair`2"/> for this dictionary.</returns>
        </member>
        <member name="M:Obtics.Collections.ObservableDictionary`2.TakeSnapshot">
            <summary>
            When the contents are being updated this method should be called.
            </summary>
        </member>
        <member name="M:Obtics.Collections.ObservableDictionary`2.Obtics#Collections#IVersionedEnumerable#GetEnumerator">
            <summary>
            GetEnumerator override that returns an <see cref="T:Obtics.Collections.IVersionedEnumerator"/>.
            </summary>
            <returns>An <see cref="T:Obtics.Collections.IVersionedEnumerator"/> for this dictionary.</returns>
        </member>
        <member name="P:Obtics.Collections.ObservableDictionary`2.Item(Obtics.Values.IValueProvider{`0})">
            <summary>
            Gets a live value from this dictionary with a live key.
            </summary>
            <param name="key">The <see cref="T:Obtics.Values.IValueProvider`1"/> for the key</param>
            <returns>An <see cref="T:Obtics.Values.IValueProvider`1"/> for the value. If <paramref name="key"/> equals null then null will be returned instead.</returns>
            <remarks>
            Whenever the collection in the dictionary or the key delivered by <paramref name="key"/> changes the
            value delivered by the result provider will be updated.
            </remarks>
        </member>
        <member name="P:Obtics.Collections.ObservableDictionary`2.Keys">
            <summary>
            Gets a read only <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the dictionary.
            </summary>
        </member>
        <member name="P:Obtics.Collections.ObservableDictionary`2.Values">
            <summary>
            Gets the collection of Values in the current dictionary.
            </summary>
        </member>
        <member name="P:Obtics.Collections.ObservableDictionary`2.Item(`0)">
            <summary>
            Gets or sets a single value in the current dictinary. The value is identified with the given key.
            </summary>
            <param name="key">The key to identify the value with.</param>
            <returns>The found value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Raised if no value can be found with the given key.</exception>
        </member>
        <member name="P:Obtics.Collections.ObservableDictionary`2.Count">
            <summary>
            Gets the total number of entries in the dictionary.
            </summary>
        </member>
        <member name="P:Obtics.Collections.ObservableDictionary`2.IsReadOnly">
            <summary>
            Gets a boolean value indicating if the dictionary is read only.
            </summary>
            <remarks>Always returns false</remarks>
        </member>
        <member name="E:Obtics.Collections.ObservableDictionary`2.CollectionChanged">
            <summary>
            Raises events whenever the contents of the dictionary change.
            </summary>
        </member>
        <member name="E:Obtics.Collections.ObservableDictionary`2.PropertyChanged">
            <summary>
            Raises events whenever a property of the dictionary changes value.
            </summary>
        </member>
        <member name="P:Obtics.Collections.ObservableDictionary`2.ContentVersion">
            <summary>
            The version of the current content of the dictionary.
            </summary>
            <remarks>
            In a multithreaded environment the returned ContentVersion may be outdated the moment it is returned.
            </remarks>
        </member>
        <member name="T:Obtics.Carrousel.InternalCarrousel`2">
            <summary>
            Actual Carrousel implementation. Based on ConcurrentWeakHashtable. First tries to find an existing
            object. If it doesn't exist it creates a new one.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="T:Obtics.Async.WorkQueue">
            <summary>
            Static methods for <see cref="T:Obtics.Async.IWorkQueue"/> operations.
            </summary>
        </member>
        <member name="P:Obtics.Async.WorkQueue.DefaultWorkQueueProvider">
            <summary>
            Returns the default <see cref="T:Obtics.Async.IWorkQueueProvider"/> used by optics.
            </summary>
            <remarks>The actual <see cref="T:Obtics.Async.IWorkQueueProvider"/> returned can be configured
            using the <see cref="T:Obtics.Configuration.ObticsConfigurationSection"/> configuration class.</remarks>
        </member>
        <member name="T:Obtics.ArrayWrapper`1">
            <summary>
            Wrapper for Arrays. This wrapper compares the Arrays elements for equality
            when compared with another wrapper
            </summary>
            <typeparam name="TType">Type of the array elements</typeparam>
        </member>
        <member name="T:Obtics.NCToNCC">
            <summary>
            This class maps internally used INotifyChanged events to public INotifyCollectionChanged events.
            </summary>
            <remarks>
            It passes the original INotifyChanged sender as sender of the INotifyCollectionChanged event.
            </remarks>
        </member>
        <member name="E:Obtics.NCToNCC.CollectionChanged">
            <summary>
            CollectionChanged event
            </summary>
        </member>
        <member name="P:Obtics.NCToNCC.HaveCollectionChangedListeningClients">
            <summary>
            HaveCollectionChangedListeners, true if there are any listeners for the CollectionChanged event.
            </summary>
        </member>
        <member name="T:Obtics.Collections.Transformations.SumHelper">
            <summary>
            Helper to deal with sum overflow issues. Note: transformations can not raise exceptions
            as a consequence of an event (like adding an item that causes an overflow in the Sum).
            </summary>
        </member>
        <member name="T:Obtics.Async.WorkQueueAdapters.WorkQueueOnDispatcherAdapter">
            <summary>
            Creates an <see cref="T:Obtics.Async.IWorkQueue"/> based on a given <see cref="T:System.Windows.Threading.Dispatcher"/> .
            </summary>
        </member>
        <member name="M:Obtics.Async.WorkQueueAdapters.WorkQueueOnDispatcherAdapter.Get(System.Windows.Threading.Dispatcher,System.Windows.Threading.DispatcherPriority)">
            <summary>
            Aquires an <see cref="T:Obtics.Async.IWorkQueue"/> based on the given <see cref="T:System.Windows.Threading.Dispatcher"/> and <see cref="T:System.Windows.Threading.DispatcherPriority"/>.
            </summary>
            <param name="dispatcher">The <see cref="T:System.Windows.Threading.Dispatcher"/> to base the <see cref="T:Obtics.Async.IWorkQueue"/> on.</param>
            <param name="priority">The <see cref="T:System.Windows.Threading.DispatcherPriority"/> to base the <see cref="T:Obtics.Async.IWorkQueue"/> on.</param>
            <returns>An <see cref="T:Obtics.Async.IWorkQueue"/> whose work items get serviced by invokations from <paramref name="dispatcher"/> at priority <paramref name="priority"/>.</returns>
            <remarks>Each unique combination yields one <see cref="T:Obtics.Async.IWorkQueue"/> and one <see cref="T:Obtics.Async.IWorkQueue"/> only.</remarks>
        </member>
        <member name="M:Obtics.Async.WorkQueueAdapters.WorkQueueOnDispatcherAdapter.Get">
            <summary>
            Aquires an <see cref="T:Obtics.Async.IWorkQueue"/> based on the CurrentDispatcher and Normal priority.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Obtics.Async.WorkQueueAdapters.WorkQueueOnDispatcherAdapter.InternalWorkQueueOnDispatcherAdapter.QueueWorkItem(System.Threading.WaitCallback,System.Object)">
            <summary>
            Queue a workitem for later execution.
            </summary>
            <param name="callback">The <see cref="T:System.Threading.WaitCallback"/> delegate that will be called when the workitem is executed.</param>
            <param name="prm">Any extra arguments for the <paramref name="callback"/> delegate.</param>
            <remarks>Each queued workitem gets executed once. The order in which the individual queued workitems are executed is undetermined.</remarks>
        </member>
        <member name="M:Obtics.Async.WorkQueueAdapters.WorkQueueOnDispatcherAdapter.InternalWorkQueueOnDispatcherAdapter.Equals(Obtics.Tuple{System.Windows.Threading.Dispatcher,System.Windows.Threading.DispatcherPriority})">
            <summary>
            Compares an <see cref="T:Obtics.Async.WorkQueueAdapters.WorkQueueOnDispatcherAdapter.InternalWorkQueueOnDispatcherAdapter"/> with a parent <see cref="T:System.Windows.Threading.Dispatcher"/> and <see cref="T:System.Windows.Threading.DispatcherPriority"/> combination.
            </summary>
            <param name="other"></param>
            <returns>True if this <see cref="T:Obtics.Async.WorkQueueAdapters.WorkQueueOnDispatcherAdapter.InternalWorkQueueOnDispatcherAdapter"/> object is based on the given <see cref="T:System.Windows.Threading.Dispatcher"/> and <see cref="T:System.Windows.Threading.DispatcherPriority"/> combination.</returns>
        </member>
        <member name="T:Obtics.Collections.Transformations.UnorderedFilterTransformation`1">
            <summary>
            Unordered form of the <see cref="T:Obtics.Collections.Transformations.FilterTransformation`1"/>  class
            </summary>
            <typeparam name="TElement">Type of the elements of the sequence.</typeparam>
            <remarks>
            FilterTransformation maintains a buffer with element - index information. This class doesn't
            </remarks>
        </member>
        <member name="M:Obtics.Collections.Transformations.UnorderedBoundGroupFilterDispenser`2.GetGroup(`1)">
            <summary>
            Returns a group collection by key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Obtics.Collections.Transformations.UnorderedBoundGroupFilterDispenser`2.Cache">
            <summary>
            Cache publication specially for BoundGroupFilterTransformation so that they can share
            this information. This should be accessed only when we have listeners for source change notifications
            </summary>
        </member>
        <member name="M:Obtics.Collections.Patches.MtPatchBase`2.prms_ListChanged(System.Object,System.ComponentModel.ListChangedEventArgs)">
            <summary>
            
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <remarks>
            In a multithreaded environment we need to assume that while we are dealing with a changed event,
            the source collection will not change further.
            </remarks>
        </member>
        <member name="T:Obtics.Collections.Patches.MtPatchAdapterClass`1">
            <summary>
            </summary>
            <typeparam name="TSource"></typeparam>
        </member>
        <member name="T:Obtics.Collections.Patches.MtPatchAdapterClass`2">
            <summary>
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TElement"></typeparam>
        </member>
        <member name="T:Obtics.SICollection">
            <summary>
            SICollection, static information about the ICollection interface
            </summary>
        </member>
        <member name="F:Obtics.SICollection.CountPropertyName">
            <summary>
            CountPropertyName
            </summary>
        </member>
        <member name="F:Obtics.SICollection.IsReadOnlyPropertyName">
            <summary>
            IsReadOnlyPropertyName
            </summary>
        </member>
        <member name="F:Obtics.SICollection.CountPropertyChangedEventArgs">
            <summary>
            CountPropertyChangedEventArgs
            </summary>
        </member>
        <member name="F:Obtics.SICollection.IsReadOnlyPropertyChangedEventArgs">
            <summary>
            IsReadOnlyPropertyChangedEventArgs
            </summary>
        </member>
        <member name="T:Obtics.Values.Transformations.BufferTransformation`1">
            <summary>
            Provides asynchronous processing of <see cref="T:Obtics.Values.IValueProvider`1"/> change propagation.
            </summary>
            <typeparam name="TType">Type of the Value property</typeparam>
            <remarks>
            Provides asynchronous processing by using an <see cref="T:Obtics.Async.IWorkQueue"/>. The existing value is buffered
            and a received change notification from the source is queued in the <see cref="T:Obtics.Async.IWorkQueue"/>.
            Only when the <see cref="T:Obtics.Async.IWorkQueue"/> returns will the change be propagated to our clients.
            </remarks>
        </member>
        <member name="M:Obtics.Values.Transformations.BufferTransformation`1.Create(Obtics.Values.IValueProvider{`0},Obtics.Async.IWorkQueue)">
            <summary>
            returns an existing BufferTransformation with given parameters or constructs a new one 
            </summary>
            <param name="source">Source <see cref="T:Obtics.Values.IValueProvider`1"/>.</param>
            <param name="workQueue">An <see cref="T:Obtics.Async.IWorkQueue"/> object we queue or jobs in for delayed processing.</param>
            <returns>The found or newly created <see cref="T:Obtics.Values.Transformations.BufferTransformation`1"/>.</returns>
        </member>
        <member name="P:Obtics.Values.Transformations.BufferTransformation`1.PSVPCNIsPending">
            <summary>
            PSVPCNIsPending (P rocess S ource V alue P roperty C hanged N otification)
            True when a job has been scheduled to PSVPCN.
            </summary>
        </member>
        <member name="M:Obtics.Values.Transformations.ReturnPathTransformation`1.ProtectedGetValue">
            <summary>
            ProtectedValue
            </summary>
        </member>
        <member name="P:Obtics.Collections.Transformations.NotifyVpcTransformation`2.Converter">
            <summary>
            publication of Converter specially for DynamicSortTransformation so that it doesn't need
            tp maintain it's own copy.
            </summary>
            <remarks>
            Externally accessed but just returning a truly static value.. no lock
            </remarks>
        </member>
        <member name="T:Obtics.Collections.Transformations.BoundGroupFilterTransformation`2">
            <summary>
            BoundGroupFilter, selects those items from a source that yield a specific key via a keyGenerator method
            </summary>
            <typeparam name="TType"></typeparam>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="T:Obtics.Collections.Transformations.AverageAggregateNullableDecimal">
            <summary>
            AverageAggregate implementation for a sequence of nullable decimals.
            </summary>
            <remarks>
            Calculates the average value over the sequence. Null values are completely ignored.
            If the sequence is empty or contains nothing but null values then the result will be null.
            </remarks>
        </member>
        <member name="T:Obtics.Collections.Transformations.AverageAggregateDecimal">
            <summary>
            AverageAggregate implementation for decimals
            </summary>
            <remarks>
            Calculates the average value over the sequence. 
            If the sequence is empty then the result will be null.
            </remarks>
        </member>
        <member name="F:Obtics.Caster`1._IsNullable">
            <summary>
            Static bool field if the TOut type is nullable
            </summary>
        </member>
        <member name="F:Obtics.Caster`1.Cache">
            <summary>
            Cache for compiled converter functions
            </summary>
        </member>
        <member name="M:Obtics.Caster`1.Cast(System.Object)">
            <summary>
            Cast a given object to TOut.
            </summary>
            <param name="castee">The object to cast or null.</param>
            <returns>A tuple where the first value is the cast result and the second is a boolean that indicates if the cast is supported.</returns>
        </member>
        <member name="T:Obtics.Values.ExpressionObserver">
            <summary>
            Class with methods to create an observable LambdaExpression out of any LambdaExpression.
            </summary>
            <remarks>
            This class is concerned with rewriting non-observable LamdaExpressions into observable LambdaExpressions.
            <para>
            A LambdaExpression can be compiled and the result of this compilation is a Lambda function or in short just a lambda. This
            lambda can be invoked with 0 or more arguments and it calculates a single result which is the return value of the lambda. A lambda
            is called pure if it always returns the same result for any set of arguments. A lamda is not pure if it depends on external
            variables. A lambda is 'pseudo pure' if it does not depend on any independent external variables. A variable is independent
            if it is not a property of any of the lamda's arguments. For example; if Person is an immutable object then the function 'f'
            below is pure. If Person is mutable then the lambda is pseudo pure.
            
            <code>
            Func&lt;Person,string&gt; f = p => p.FirstName ;
            </code>
            
            The following code is not pure and not pseudo pure since it depends on the independent external variable 'firstName'
            
            <code>
            bool firstName;
            Func&lt;Person,string&gt; f = p => firstName ? p.FirstName : p.LastName ;
            </code>
            </para>
            
            <para>
            A non-observable LambdaExpression is an Expression that when compiled would calculate an intended result from a set of
            input parameters. This calculation is one-time. In the case of non-pure lamda's, to get an updated result, the lambda needs to be called again and
            it is upto the client to determine when it needs to be called. 
            </para>
            <para>
            An Observable LambdaExpression is an Expression that, when compiled, would return a ValueProvider. The Value of the ValueProvider 
            would contain the intended result. Whenever a change is detected in any of parameters passed to the Lambda the ValueProvider will
            send a change notification and the Value property of the ValueProvider will contain the new result. So, in the case of non-pure
            lambda's the client is relieved of the task to determine when the result needs to be recalculated. Also; in the case that all mutable properties
            accessed are themselves observable and any functions accessed within the lambda are pure then the observable variant of
            a pseudo pure non-observable lamda will be pure. So the following code will write 'true' to the console.
            
            <code>
            Func&lt;Person,string&gt; f = ExpressionObserver&lt;Person&gt;.Compile( p => p.FirstName ) ;
            Person p = new Person("Glenn","Miller");
            var first = f(p);
            p.FirstName = "John";
            var second = f(p);
            Console.Out.WriteLine(object.Equals(first,second));
            </code>
            </para>
            <para>
            ExpressionObserver contains three sets of static methods:
            
            <list type="bullet">
            <item>
            <term>Rewrite</term>
            <description>
            These methods take a non-observable LambdaExpression and return a new Obserable LambdaExpression. When
            compiled the new Observable LambdaExpression generates an Observable Lamda. This Observable Lambda has a
            ValueProvider as results who's Value property will generate the same result as the original compiled 
            LabdaExpression would.
            </description>
            </item>
            <item>
            <term>Compile</term>
            <description>
            These methods take a non-observable LambdaExpression and call a Rewrite method with it. 
            After that it compiles the result and return the resulting Lambda function. These methods
            use a cache. If they detect that they have already Rewritten and Compiled a previous but
            computationaly equal LambdaExpression than they will return the previously compiled Lambda function.
            </description>
            </item>
            <item>
            <term>Execute</term>
            <description>
            These methods take a non-observable LambdaExpression and call a Compile method with it.
            After that they execute the resulting Lambda function with arguments that are also passed to the
            Execute method and return the resulting IValueProvider.
            </description>
            </item>
            </list>
            </para>
            <para>
            ExpressionObserver translates a non-observable LambdaExpression into an observable one by searching
            for all property references within the LambdaExpression and registering for change notifications
            on these properties. It does this in a cascading fashion. That means that the expression as below.
            <code>
            Expression&lt;Func&lt;Person,int&gt;&gt; f = p => p.FirstName.Length;
            </code>
            Is translated into something like
            <code>
            Expression&lt;Func&lt;Person,IValueProvider&lt;int&gt;&gt;&gt; f = p => ValueProvider.Property(ValueProvider.Property(ValueProvider.Static(p), "FirstName"), "Length");
            </code>
            </para>
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Rewrite(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Rewrites a LambdaExpression to a new reactive LambdaExpression that will return an IValueProvider;
            </summary>
            <param name="original">The original, presumably not-observable LambdaExpression</param>
            <returns>
            Reactive LambdaExpression which in turn will return an IValueProvider of the original return type.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this LambdaExpression form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.       
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Rewrite``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Rewrites a LambdaExpression that returns <typeparamref name="TResult"/> to a LambdaExpression that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            This <see cref="T:Obtics.Values.IValueProvider`1"/> will be reactive to changes of observable dependencies of the original LambdaExpression. 
            </summary>
            <typeparam name="TResult">Type of the result returned by the <paramref name="original"/> LambdaExpression (when compiled) and type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the <see cref="T:Obtics.Values.IValueProvider`1"/> returned by the rewritten LambdaExpression</typeparam>
            <param name="original">The original, presumably not-observable, LambdaExpression ((<see cref="T:System.Linq.Expressions.Expression`1"/>)). The return value of this LambdaExpression when compiled should be <typeparamref name="TResult"/>.</param>
            <returns>
            A LambdaExpression which when compiled will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this LambdaExpression form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.       
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Rewrite``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Rewrites a LambdaExpression that returns <typeparamref name="TResult"/> to a LambdaExpression that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            This <see cref="T:Obtics.Values.IValueProvider`1"/> will be reactive to changes of observable dependencies of the original LambdaExpression. 
            </summary>
            <typeparam name="TPrm1">Type of argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TResult">Type of the result returned by the <paramref name="original"/> LambdaExpression (when compiled) and type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the <see cref="T:Obtics.Values.IValueProvider`1"/> returned by the rewritten LambdaExpression</typeparam>
            <param name="original">The original, presumably not-observable, LambdaExpression (<see cref="T:System.Linq.Expressions.Expression`1"/>). The return value of this LambdaExpression when compiled should be <typeparamref name="TResult"/>.</param>
            <returns>
            A LambdaExpression which when compiled will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this LambdaExpression form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.       
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Rewrite``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
            <summary>
            Rewrites a LambdaExpression that returns <typeparamref name="TResult"/> to a LambdaExpression that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            This <see cref="T:Obtics.Values.IValueProvider`1"/> will be reactive to changes of observable dependencies of the original LambdaExpression. 
            </summary>
            <typeparam name="TPrm1">Type of the first argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TPrm2">Type of the second argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TResult">Type of the result returned by the <paramref name="original"/> LambdaExpression (when compiled) and type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the <see cref="T:Obtics.Values.IValueProvider`1"/> returned by the rewritten LambdaExpression</typeparam>
            <param name="original">The original, presumably not-observable, LambdaExpression ((<see cref="T:System.Linq.Expressions.Expression`1"/>)). The return value of this LambdaExpression when compiled should be <typeparamref name="TResult"/>.</param>
            <returns>
            A LambdaExpression which when compiled will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this LambdaExpression form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.       
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Rewrite``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}})">
            <summary>
            Rewrites a LambdaExpression that returns <typeparamref name="TResult"/> to a LambdaExpression that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            This <see cref="T:Obtics.Values.IValueProvider`1"/> will be reactive to changes of observable dependencies of the original LambdaExpression. 
            </summary>
            <typeparam name="TPrm1">Type of the first argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TPrm2">Type of the second argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TPrm3">Type of the third argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TResult">Type of the result returned by the <paramref name="original"/> LambdaExpression (when compiled) and type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the <see cref="T:Obtics.Values.IValueProvider`1"/> returned by the rewritten LambdaExpression</typeparam>
            <param name="original">The original, presumably not-observable, LambdaExpression ((<see cref="T:System.Linq.Expressions.Expression`1"/>)). The return value of this LambdaExpression when compiled should be <typeparamref name="TResult"/>.</param>
            <returns>
            A LambdaExpression which when compiled will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this LambdaExpression form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.       
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Rewrite``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}})">
            <summary>
            Rewrites a LambdaExpression that returns <typeparamref name="TResult"/> to a LambdaExpression that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            This <see cref="T:Obtics.Values.IValueProvider`1"/> will be reactive to changes of observable dependencies of the original LambdaExpression. 
            </summary>
            <typeparam name="TPrm1">Type of the first argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TPrm2">Type of the second argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TPrm3">Type of the third argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TPrm4">Type of the fourth argument to be passed to the <paramref name="original"/> LambdaExpression and the result LambdaExpression</typeparam>
            <typeparam name="TResult">Type of the result returned by the <paramref name="original"/> LambdaExpression (when compiled) and type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the <see cref="T:Obtics.Values.IValueProvider`1"/> returned by the rewritten LambdaExpression</typeparam>
            <param name="original">The original, presumably not-observable, LambdaExpression ((<see cref="T:System.Linq.Expressions.Expression`1"/>)). The return value of this LambdaExpression when compiled should be <typeparamref name="TResult"/>.</param>
            <returns>
            A LambdaExpression which when compiled will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this LambdaExpression form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.       
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Compile(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.LambdaExpression"/> to a new reactive <see cref="T:System.Linq.Expressions.LambdaExpression"/> that will return an IValueProvider and compiles the result.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.LambdaExpression"/></param>
            <returns>
            Reactive <see cref="T:System.Delegate"/> which in turn will return an IValueProvider of the original return type
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.LambdaExpression"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.LambdaExpression"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.LambdaExpression"/> is computationaly equal to a previously compiled <see cref="T:System.Linq.Expressions.LambdaExpression"/>
            then they will return the cached <see cref="T:System.Delegate"/>.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Compile``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/> and compiles the result.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <returns>
            Reactive <see cref="T:System.Func`1"/> which in turn will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/>.</typeparam>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then they will return the cached <see cref="T:System.Func`1"/>.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Compile``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/> and compiles the result.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <typeparam name="TPrm1">Type of the argument for <paramref name="original"/> and the resulting <see cref="T:System.Func`2"/>.</typeparam>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/> and the resulting <see cref="T:System.Func`2"/>.</typeparam>
            <returns>
            Reactive <see cref="T:System.Func`2"/> which in turn will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously rewritten and compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then they will return the cached <see cref="T:System.Func`2"/>.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Compile``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/> and compiles the result.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <typeparam name="TPrm1">Type of the first argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`3"/>.</typeparam>
            <typeparam name="TPrm2">Type of the second argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`3"/>.</typeparam>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/> and the resulting <see cref="T:System.Func`3"/>.</typeparam>
            <returns>
            Reactive <see cref="T:System.Func`3"/> which in turn will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously rewritten and compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then they will return the cached <see cref="T:System.Func`3"/>.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Compile``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/> and compiles the result.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <typeparam name="TPrm1">Type of the first argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`4"/>.</typeparam>
            <typeparam name="TPrm2">Type of the second argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`4"/>.</typeparam>
            <typeparam name="TPrm3">Type of the third argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`4"/>.</typeparam>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/> and the resulting <see cref="T:System.Func`4"/>.</typeparam>
            <returns>
            Reactive <see cref="T:System.Func`4"/> which in turn will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously rewritten and compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then they will return the cached <see cref="T:System.Func`4"/>.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Compile``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/> and compiles the result.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <typeparam name="TPrm1">Type of the first argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <typeparam name="TPrm2">Type of the second argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <typeparam name="TPrm3">Type of the third argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <typeparam name="TPrm4">Type of the fourth argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <returns>
            Reactive <see cref="T:System.Func`5"/> which in turn will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously rewritten and compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then they will return the cached <see cref="T:System.Func`5"/>.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Execute``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>, compiles the result and executes it.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <returns>
            Reactive <see cref="T:Obtics.Values.IValueProvider`1"/> or null returned by the compiled <see cref="T:System.Func`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/>.</typeparam>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then the cached <see cref="T:System.Func`1"/> will be executed.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Execute``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>, compiles the result and executes it with the given <paramref name="prm1"/>.
            </summary>
            <param name="prm1">The argument to be passed to the compiled reactive <see cref="T:System.Func`2"/> to get the final result.</param>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <returns>
            Reactive <see cref="T:Obtics.Values.IValueProvider`1"/> or null returned by the compiled <see cref="T:System.Func`2"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <typeparam name="TPrm1">Type of the argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`2"/>.</typeparam>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/>.</typeparam>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then the cached <see cref="T:System.Func`2"/> will be executed.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Execute``3(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>, compiles the result and executes it with the given <paramref name="prm1"/> and <paramref name="prm2"/>.
            </summary>
            <param name="prm1">The first argument to be passed to the compiled reactive <see cref="T:System.Func`3"/> to get the final result.</param>
            <param name="prm2">The second argument to be passed to the compiled reactive <see cref="T:System.Func`3"/> to get the final result.</param>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <returns>
            Reactive <see cref="T:Obtics.Values.IValueProvider`1"/> or null returned by the compiled <see cref="T:System.Func`3"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <typeparam name="TPrm1">Type of the first argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`3"/>.</typeparam>
            <typeparam name="TPrm2">Type of the second argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`3"/>.</typeparam>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/>.</typeparam>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then the cached <see cref="T:System.Func`3"/> will be executed.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Execute``4(``0,``1,``2,System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>, compiles the result and executes it with the given <paramref name="prm1"/>, <paramref name="prm2"/> and <paramref name="prm3"/>.
            </summary>
            <param name="prm1">The first argument to be passed to the compiled reactive <see cref="T:System.Func`4"/> to get the final result.</param>
            <param name="prm2">The second argument to be passed to the compiled reactive <see cref="T:System.Func`4"/> to get the final result.</param>
            <param name="prm3">The third argument to be passed to the compiled reactive <see cref="T:System.Func`4"/> to get the final result.</param>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <returns>
            Reactive <see cref="T:Obtics.Values.IValueProvider`1"/> or null returned by the compiled <see cref="T:System.Func`4"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <typeparam name="TPrm1">Type of the first argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`4"/>.</typeparam>
            <typeparam name="TPrm2">Type of the second argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`4"/>.</typeparam>
            <typeparam name="TPrm3">Type of the third argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`4"/>.</typeparam>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/>.</typeparam>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then the cached <see cref="T:System.Func`4"/> will be executed.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Execute``5(``0,``1,``2,``3,System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>, compiles the result and executes it with the given <paramref name="prm1"/>, <paramref name="prm2"/>, <paramref name="prm3"/> and <paramref name="prm4"/>.
            </summary>
            <param name="prm1">The first argument to be passed to the compiled reactive <see cref="T:System.Func`5"/> to get the final result.</param>
            <param name="prm2">The second argument to be passed to the compiled reactive <see cref="T:System.Func`5"/> to get the final result.</param>
            <param name="prm3">The third argument to be passed to the compiled reactive <see cref="T:System.Func`5"/> to get the final result.</param>
            <param name="prm4">The fourth argument to be passed to the compiled reactive <see cref="T:System.Func`5"/> to get the final result.</param>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <returns>
            Reactive <see cref="T:Obtics.Values.IValueProvider`1"/> or null returned by the compiled <see cref="T:System.Func`5"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <typeparam name="TPrm1">Type of the first argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <typeparam name="TPrm2">Type of the second argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <typeparam name="TPrm3">Type of the third argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <typeparam name="TPrm4">Type of the fourth argument to <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/>.</typeparam>
            <remarks>
            This method will try to rewrite the original Expression to a form that will yield a maximum reactive value transformation.
            The new expression will try to listen for changes on all property references in the original expression. Lambda functions
            enclosed in this <see cref="T:System.Linq.Expressions.Expression`1"/> form a limit to the reactiveness of the result. Any values that depend
            on an argument of an inner lambda function will not get tracked for changes. The changes can not be tracked because this
            inner lambda will be consumed my some function and the rewriteer can not guess how this function will use that lambda.
            More importantly it doesn't know how many times the lambda will be called by that function.
            Note that many Implicitly observable collection transformations (Observable LINQ) will consume lambda functions
            but they will rewrite their own lambda's.
            
            The resulting <see cref="T:System.Linq.Expressions.Expression`1"/> will not always be compiled. The Compile methods maintain a cache and if
            the detect that a given original <see cref="T:System.Linq.Expressions.Expression`1"/> is computationaly equal to a previously compiled <see cref="T:System.Linq.Expressions.Expression`1"/>
            then the cached <see cref="T:System.Func`5"/> will be executed.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Unobserve``2(``0,System.Func{``0,``1})">
            <summary>
            This expression shields the arguments to a given lambda from rewriting when used in an observed expression.
            </summary>
            <typeparam name="TIn1">Type of the first argument to <paramref name="lambda"/>.</typeparam>
            <typeparam name="TOut">Type of the return value of <paramref name="lambda"/>.</typeparam>
            <param name="in1">First argument to <paramref name="lambda"/>.</param>
            <param name="lambda">The lambda (expression) whose components that are directly dependent on it's arguments will be rewritten by <see cref="T:Obtics.Values.ExpressionObserver"/>.</param>
            <returns>The value returned by <paramref name="lambda"/>.</returns>
            <remarks>
            ExpressionObserver never rewrites arguments of inner lambda functions unless they lambda is an argument to a special function (Enumerable member functions).
            
            This method is an easy way to inject an inner lambda in an observed expression. Note that only those parts of the inner lambda that are directly dependend on one of the lambda arguments, are protected
            from rewriting.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Unobserve``3(``0,``1,System.Func{``0,``1,``2})">
            <summary>
            This expression shields the arguments to a given lambda from rewriting when used in an observed expression.
            </summary>
            <typeparam name="TIn1">Type of the first argument to <paramref name="lambda"/>.</typeparam>
            <typeparam name="TIn2">Type of the second argument to <paramref name="lambda"/>.</typeparam>
            <typeparam name="TOut">Type of the return value of <paramref name="lambda"/>.</typeparam>
            <param name="in1">First argument to <paramref name="lambda"/>.</param>
            <param name="in2">Second argument to <paramref name="lambda"/>.</param>
            <param name="lambda">The lambda (expression) whose components that are directly dependent on it's arguments will be rewritten by <see cref="T:Obtics.Values.ExpressionObserver"/>.</param>
            <returns>The value returned by <paramref name="lambda"/>.</returns>
            <remarks>
            ExpressionObserver never rewrites arguments of inner lambda functions unless they lambda is an argument to a special function (Enumerable member functions).
            
            This method is an easy way to inject an inner lambda in an observed expression. Note that only those parts of the inner lambda that are directly dependend on one of the lambda arguments, are protected
            from rewriting.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Unobserve``4(``0,``1,``2,System.Func{``0,``1,``2,``3})">
            <summary>
            This expression shields the arguments to a given lambda from rewriting when used in an observed expression.
            </summary>
            <typeparam name="TIn1">Type of the first argument to <paramref name="lambda"/>.</typeparam>
            <typeparam name="TIn2">Type of the second argument to <paramref name="lambda"/>.</typeparam>
            <typeparam name="TIn3">Type of the third argument to <paramref name="lambda"/>.</typeparam>
            <typeparam name="TOut">Type of the return value of <paramref name="lambda"/>.</typeparam>
            <param name="in1">First argument to <paramref name="lambda"/>.</param>
            <param name="in2">Second argument to <paramref name="lambda"/>.</param>
            <param name="in3">Third argument to <paramref name="lambda"/>.</param>
            <param name="lambda">The lambda (expression) whose components that are directly dependent on it's arguments will be rewritten by <see cref="T:Obtics.Values.ExpressionObserver"/>.</param>
            <returns>The value returned by <paramref name="lambda"/>.</returns>
            <remarks>
            ExpressionObserver never rewrites arguments of inner lambda functions unless they lambda is an argument to a special function (Enumerable member functions).
            
            This method is an easy way to inject an inner lambda in an observed expression. Note that only those parts of the inner lambda that are directly dependend on one of the lambda arguments, are protected
            from rewriting.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver.Unobserve``5(``0,``1,``2,``3,System.Func{``0,``1,``2,``3,``4})">
            <summary>
            This expression shields the arguments to a given lambda from rewriting when used in an observed expression.
            </summary>
            <typeparam name="TIn1">Type of the first argument to <paramref name="lambda"/>.</typeparam>
            <typeparam name="TIn2">Type of the second argument to <paramref name="lambda"/>.</typeparam>
            <typeparam name="TIn3">Type of the third argument to <paramref name="lambda"/>.</typeparam>
            <typeparam name="TIn4">Type of the fourth argument to <paramref name="lambda"/>.</typeparam>
            <typeparam name="TOut">Type of the return value of <paramref name="lambda"/>.</typeparam>
            <param name="in1">First argument to <paramref name="lambda"/>.</param>
            <param name="in2">Second argument to <paramref name="lambda"/>.</param>
            <param name="in3">Third argument to <paramref name="lambda"/>.</param>
            <param name="in4">Fourth argument to <paramref name="lambda"/>.</param>
            <param name="lambda">The lambda (expression) whose components that are directly dependent on it's arguments will be rewritten by <see cref="T:Obtics.Values.ExpressionObserver"/>.</param>
            <returns>The value returned by <paramref name="lambda"/>.</returns>
            <remarks>
            ExpressionObserver never rewrites arguments of inner lambda functions unless they lambda is an argument to a special function (Enumerable member functions).
            
            This method is an easy way to inject an inner lambda in an observed expression. Note that only those parts of the inner lambda that are directly dependend on one of the lambda arguments, are protected
            from rewriting.
            </remarks>
        </member>
        <member name="P:Obtics.Values.ExpressionObserver.Default">
            <summary>
            Default ExpressionObserverObject instance. Has mappings for all object Linq methods (methods of class Enumerable)
            </summary>
            <permission cref="T:Obtics.Configuration.ExtendObticsPermission">Is needed for setting this property.</permission>
        </member>
        <member name="T:Obtics.Values.ExpressionObserver`1">
            <summary>
            <see cref="T:Obtics.Values.ExpressionObserver"/> helper class, specialized for rewriting lambda expressions that
            take one specificaly typed argument. 
            </summary>
            <typeparam name="TPrm1">The type of the one argument the lambda expressions take.</typeparam>
            <seealso cref="T:Obtics.Values.ExpressionObserver"/>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver`1.Rewrite``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Rewrites a LambdaExpression that returns <typeparamref name="TResult"/> to a LambdaExpression that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            This <see cref="T:Obtics.Values.IValueProvider`1"/> will be reactive to changes of observable dependencies of the original LambdaExpression. 
            </summary>
            <typeparam name="TResult">Type of the result returned by the <paramref name="original"/> LambdaExpression (when compiled) and type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the <see cref="T:Obtics.Values.IValueProvider`1"/> returned by the rewritten LambdaExpression</typeparam>
            <param name="original">The original, presumably not-observable, LambdaExpression ((<see cref="T:System.Linq.Expressions.Expression`1"/>)). The return value of this LambdaExpression when compiled should be <typeparamref name="TResult"/>.</param>
            <returns>
            A LambdaExpression which when compiled will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <seealso cref="M:Obtics.Values.ExpressionObserver.Rewrite``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})"/>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver`1.Compile``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/> and compiles the result.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/> and the resulting <see cref="T:System.Func`2"/>.</typeparam>
            <returns>
            Reactive <see cref="T:System.Func`2"/> which in turn will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <seealso cref="M:Obtics.Values.ExpressionObserver.Compile``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})"/>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver`1.Execute``1(`0,System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>, compiles the result and executes it with the given <paramref name="prm1"/>.
            </summary>
            <param name="prm1">The argument to be passed to the compiled reactive <see cref="T:System.Func`2"/> to get the final result.</param>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <returns>
            Reactive <see cref="T:Obtics.Values.IValueProvider`1"/> or null returned by the compiled <see cref="T:System.Func`2"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/>.</typeparam>
            <seealso cref="M:Obtics.Values.ExpressionObserver.Execute``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})"/>
        </member>
        <member name="T:Obtics.Values.ExpressionObserver`2">
            <summary>
            <see cref="T:Obtics.Values.ExpressionObserver"/> helper class, specialized for rewriting lambda expressions that
            take two specificaly typed arguments. 
            </summary>
            <typeparam name="TPrm1">The type of the first argument the lambda expressions take.</typeparam>
            <typeparam name="TPrm2">The type of the second argument the lambda expressions take.</typeparam>
            <seealso cref="T:Obtics.Values.ExpressionObserver"/>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver`2.Rewrite``1(System.Linq.Expressions.Expression{System.Func{`0,`1,``0}})">
            <summary>
            Rewrites a LambdaExpression that returns <typeparamref name="TResult"/> to a LambdaExpression that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            This <see cref="T:Obtics.Values.IValueProvider`1"/> will be reactive to changes of observable dependencies of the original LambdaExpression. 
            </summary>
            <typeparam name="TResult">Type of the result returned by the <paramref name="original"/> LambdaExpression (when compiled) and type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the <see cref="T:Obtics.Values.IValueProvider`1"/> returned by the rewritten LambdaExpression</typeparam>
            <param name="original">The original, presumably not-observable, LambdaExpression ((<see cref="T:System.Linq.Expressions.Expression`1"/>)). The return value of this LambdaExpression when compiled should be <typeparamref name="TResult"/>.</param>
            <returns>
            A LambdaExpression which when compiled will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <seealso cref="M:Obtics.Values.ExpressionObserver.Rewrite``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})"/>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver`2.Compile``1(System.Linq.Expressions.Expression{System.Func{`0,`1,``0}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/> and compiles the result.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/> and the resulting <see cref="T:System.Func`3"/>.</typeparam>
            <returns>
            Reactive <see cref="T:System.Func`3"/> which in turn will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <seealso cref="M:Obtics.Values.ExpressionObserver.Compile``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})"/>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver`2.Execute``1(`0,`1,System.Linq.Expressions.Expression{System.Func{`0,`1,``0}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>, compiles the result and executes it with the given <paramref name="prm1"/> and <paramref name="prm2"/>.
            </summary>
            <param name="prm1">The first argument to be passed to the compiled reactive <see cref="T:System.Func`3"/> to get the final result.</param>
            <param name="prm2">The second argument to be passed to the compiled reactive <see cref="T:System.Func`3"/> to get the final result.</param>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <returns>
            Reactive <see cref="T:Obtics.Values.IValueProvider`1"/> or null returned by the compiled <see cref="T:System.Func`3"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/>.</typeparam>
            <seealso cref="M:Obtics.Values.ExpressionObserver.Execute``3(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})"/>
        </member>
        <member name="T:Obtics.Values.ExpressionObserver`3">
            <summary>
            <see cref="T:Obtics.Values.ExpressionObserver"/> helper class, specialized for rewriting lambda expressions that
            take three specificaly typed arguments. 
            </summary>
            <typeparam name="TPrm1">The type of the first argument the lambda expressions take.</typeparam>
            <typeparam name="TPrm2">The type of the second argument the lambda expressions take.</typeparam>
            <typeparam name="TPrm3">The type of the third argument the lambda expressions take.</typeparam>
            <seealso cref="T:Obtics.Values.ExpressionObserver"/>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver`3.Rewrite``1(System.Linq.Expressions.Expression{System.Func{`0,`1,`2,``0}})">
            <summary>
            Rewrites a LambdaExpression that returns <typeparamref name="TResult"/> to a LambdaExpression that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            This <see cref="T:Obtics.Values.IValueProvider`1"/> will be reactive to changes of observable dependencies of the original LambdaExpression. 
            </summary>
            <typeparam name="TResult">Type of the result returned by the <paramref name="original"/> LambdaExpression (when compiled) and type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the <see cref="T:Obtics.Values.IValueProvider`1"/> returned by the rewritten LambdaExpression</typeparam>
            <param name="original">The original, presumably not-observable, LambdaExpression ((<see cref="T:System.Linq.Expressions.Expression`1"/>)). The return value of this LambdaExpression when compiled should be <typeparamref name="TResult"/>.</param>
            <returns>
            A LambdaExpression which when compiled will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <seealso cref="M:Obtics.Values.ExpressionObserver.Rewrite``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}})"/>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver`3.Compile``1(System.Linq.Expressions.Expression{System.Func{`0,`1,`2,``0}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/> and compiles the result.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/> and the resulting <see cref="T:System.Func`4"/>.</typeparam>
            <returns>
            Reactive <see cref="T:System.Func`4"/> which in turn will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <seealso cref="M:Obtics.Values.ExpressionObserver.Compile``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}})"/>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver`3.Execute``1(`0,`1,`2,System.Linq.Expressions.Expression{System.Func{`0,`1,`2,``0}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>, compiles the result and executes it with the given <paramref name="prm1"/>, <paramref name="prm2"/> and <paramref name="prm3"/>.
            </summary>
            <param name="prm1">The first argument to be passed to the compiled reactive <see cref="T:System.Func`4"/> to get the final result.</param>
            <param name="prm2">The second argument to be passed to the compiled reactive <see cref="T:System.Func`4"/> to get the final result.</param>
            <param name="prm3">The third argument to be passed to the compiled reactive <see cref="T:System.Func`4"/> to get the final result.</param>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <returns>
            Reactive <see cref="T:Obtics.Values.IValueProvider`1"/> or null returned by the compiled <see cref="T:System.Func`4"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/>.</typeparam>
            <seealso cref="M:Obtics.Values.ExpressionObserver.Execute``4(``0,``1,``2,System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}})"/>
        </member>
        <member name="T:Obtics.Values.ExpressionObserver`4">
            <summary>
            <see cref="T:Obtics.Values.ExpressionObserver"/> helper class, specialized for rewriting lambda expressions that
            take four specificaly typed arguments. 
            </summary>
            <typeparam name="TPrm1">The type of the first argument the lambda expressions take.</typeparam>
            <typeparam name="TPrm2">The type of the second argument the lambda expressions take.</typeparam>
            <typeparam name="TPrm3">The type of the third argument the lambda expressions take.</typeparam>
            <typeparam name="TPrm4">The type of the fourth argument the lambda expressions take.</typeparam>
            <seealso cref="T:Obtics.Values.ExpressionObserver"/>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver`4.Rewrite``1(System.Linq.Expressions.Expression{System.Func{`0,`1,`2,`3,``0}})">
            <summary>
            Rewrites a LambdaExpression that returns <typeparamref name="TResult"/> to a LambdaExpression that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            This <see cref="T:Obtics.Values.IValueProvider`1"/> will be reactive to changes of observable dependencies of the original LambdaExpression. 
            </summary>
            <typeparam name="TResult">Type of the result returned by the <paramref name="original"/> LambdaExpression (when compiled) and type of the <see cref="P:Obtics.Values.IValueProvider`1.Value"/> property of the <see cref="T:Obtics.Values.IValueProvider`1"/> returned by the rewritten LambdaExpression</typeparam>
            <param name="original">The original, presumably not-observable, LambdaExpression ((<see cref="T:System.Linq.Expressions.Expression`1"/>)). The return value of this LambdaExpression when compiled should be <typeparamref name="TResult"/>.</param>
            <returns>
            A LambdaExpression which when compiled will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <seealso cref="M:Obtics.Values.ExpressionObserver.Rewrite``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}})"/>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver`4.Compile``1(System.Linq.Expressions.Expression{System.Func{`0,`1,`2,`3,``0}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/> and compiles the result.
            </summary>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/> and the resulting <see cref="T:System.Func`5"/>.</typeparam>
            <returns>
            Reactive <see cref="T:System.Func`5"/> which in turn will return an <see cref="T:Obtics.Values.IValueProvider`1"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <seealso cref="M:Obtics.Values.ExpressionObserver.Compile``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}})"/>
        </member>
        <member name="M:Obtics.Values.ExpressionObserver`4.Execute``1(`0,`1,`2,`3,System.Linq.Expressions.Expression{System.Func{`0,`1,`2,`3,``0}})">
            <summary>
            Rewrites a <see cref="T:System.Linq.Expressions.Expression`1"/> to a new reactive <see cref="T:System.Linq.Expressions.Expression`1"/> that will return an <see cref="T:Obtics.Values.IValueProvider`1"/>, compiles the result and executes it with the given <paramref name="prm1"/>, <paramref name="prm2"/>, <paramref name="prm3"/> and <paramref name="prm4"/>.
            </summary>
            <param name="prm1">The first argument to be passed to the compiled reactive <see cref="T:System.Func`5"/> to get the final result.</param>
            <param name="prm2">The second argument to be passed to the compiled reactive <see cref="T:System.Func`5"/> to get the final result.</param>
            <param name="prm3">The third argument to be passed to the compiled reactive <see cref="T:System.Func`5"/> to get the final result.</param>
            <param name="prm4">The fourth argument to be passed to the compiled reactive <see cref="T:System.Func`5"/> to get the final result.</param>
            <param name="original">The original, presumably not-observable <see cref="T:System.Linq.Expressions.Expression`1"/></param>
            <returns>
            Reactive <see cref="T:Obtics.Values.IValueProvider`1"/> or null returned by the compiled <see cref="T:System.Func`5"/>.
            If <paramref name="original"/> equals null then null will be returned instead.
            </returns>
            <typeparam name="TResult">Type of the return value for <paramref name="original"/>.</typeparam>
            <seealso cref="M:Obtics.Values.ExpressionObserver.Execute``5(``0,``1,``2,``3,System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}})"/>
        </member>
        <member name="T:Obtics.Values.Transformations.PipelineResultTransformation`3">
            <summary>
            Special transformation that helps caching the results of the pipeline factories.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TOut"></typeparam>
            <typeparam name="TPG"></typeparam>
            <remarks>
            In this class the source is not part of the (carrousel-)key. Only the input parameter to the 
            pipeline factory is part of the key. The actual type of the factory (with default constructor)
            is part of the type identity of the PipelineResultTransformation.
            
            The key in these objects will always be a composite key, consisting of a factory delegate and
            its arguments. The IValueTransformationPipelineFactory static instance knows how to call this
            delegate with its arguments.
            </remarks>
        </member>
        <member name="M:Obtics.Collections.Transformations.GroupFilterConverterTransformation`2.GetGroup(`1)">
            <summary>
            Returns a group collection by key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:Obtics.Values.SIValueProvider">
            <summary>
            Static information about the <see cref="T:Obtics.Values.IValueProvider"/> interface
            </summary>
        </member>
        <member name="F:Obtics.Values.SIValueProvider.ValuePropertyName">
            <summary>
            Property name of the Value property
            </summary>
        </member>
        <member name="F:Obtics.Values.SIValueProvider.IsReadOnlyPropertyName">
            <summary>
            Property name of the IsReadOnly property
            </summary>
        </member>
        <member name="F:Obtics.Values.SIValueProvider.ValuePropertyChangedEventArgs">
            <summary>
            ValuePropertyChangedEventArgs
            </summary>
        </member>
        <member name="F:Obtics.Values.SIValueProvider.IsReadOnlyPropertyChangedEventArgs">
            <summary>
            IsReadOnlyPropertyChangedEventArgs
            </summary>
        </member>
        <member name="T:Obtics.Collections.VersionedEnumerator">
            <summary>
            Static class with static helper methods for <see cref="T:Obtics.Collections.IVersionedEnumerator"/> and <see cref="T:Obtics.Collections.IVersionedEnumerator`1"/>.
            </summary>
        </member>
        <member name="M:Obtics.Collections.VersionedEnumerator.WithContentVersion``1(System.Collections.Generic.IEnumerator{``0},Obtics.Collections.VersionNumber)">
            <summary>
            Constructs an <see cref="T:Obtics.Collections.IVersionedEnumerator`1"/> out of an <see cref="T:System.Collections.Generic.IEnumerator`1"/> and a <see cref="T:Obtics.Collections.VersionNumber"/>.
            </summary>
            <typeparam name="TType">The type of the elements returned by the sequence.</typeparam>
            <param name="innerEnumerator">The <see cref="T:System.Collections.Generic.IEnumerator`1"/> or <typeparamref name="TType"/> that will be the source of the elements for the resulting <see cref="T:Obtics.Collections.IVersionedEnumerator`1"/> of <typeparamref name="TType"/>.</param>
            <param name="version">The <see cref="T:Obtics.Collections.VersionNumber"/> of the resulting <see cref="T:Obtics.Collections.IVersionedEnumerator`1"/> of <typeparamref name="TType"/>.</param>
            <returns>An <see cref="T:Obtics.Collections.IVersionedEnumerator`1"/> of <typeparamref name="TType"/> whose elements are provided by <paramref name="innerEnumerator"/> and whose ContentVersion is provided by <paramref name="version"/>.</returns>
        </member>
        <member name="M:Obtics.Collections.VersionedEnumerator.WithContentVersion``1(System.Collections.Generic.IEnumerable{``0},Obtics.Collections.VersionNumber)">
            <summary>
            Constructs an <see cref="T:Obtics.Collections.IVersionedEnumerator`1"/> out of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> and a <see cref="T:Obtics.Collections.VersionNumber"/>.
            </summary>
            <typeparam name="TType">The type of the elements returned by the sequence.</typeparam>
            <param name="innerEnumerable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> or <typeparamref name="TType"/> that will be the source of the elements for the resulting <see cref="T:Obtics.Collections.IVersionedEnumerator`1"/> of <typeparamref name="TType"/>.</param>
            <param name="version">The <see cref="T:Obtics.Collections.VersionNumber"/> of the resulting <see cref="T:Obtics.Collections.IVersionedEnumerator`1"/> of <typeparamref name="TType"/>.</param>
            <returns>An <see cref="T:Obtics.Collections.IVersionedEnumerator`1"/> of <typeparamref name="TType"/> whose elements are provided by <paramref name="innerEnumerable"/> and whose ContentVersion is provided by <paramref name="version"/>.</returns>
        </member>
        <member name="T:Obtics.Collections.SIVersionedEnumerator">
            <summary>
            Static information and methods about the <see cref="T:Obtics.Collections.IVersionedEnumerator`1"/> and <see cref="T:Obtics.Collections.IVersionedEnumerator"/> interfaces.
            </summary>
        </member>
        <member name="F:Obtics.Collections.SIVersionedEnumerator.ContentVersionPropertyName">
            <summary>
            Name of the <see cref="T:Obtics.Collections.IVersionedEnumerator"/>.ContentVersion property. 
            </summary>
        </member>
        <member name="T:Obtics.Collections.Patches.ONCCPatchBase`2">
            <summary>
            Base for transformation objects that transform an IVersionedEnumerable with INotifyCollectionChanged
            to an IVersionedEnumerable with INotifyChanged (internal change notification mechanism)
            </summary>
            <typeparam name="TOut">Type of the sequence items</typeparam>
            <typeparam name="TSource">Type of the source sequence. Must be an <see cref="T:Obtics.Collections.IVersionedEnumerable"/>.</typeparam>
        </member>
        <member name="T:Obtics.Collections.Patches.ONCCPatch">
            <summary>
            A transformation object that transforms an untyped <see cref="T:Obtics.Collections.IVersionedEnumerable"/> with <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/>
            to an untyped <see cref="T:Obtics.Collections.IVersionedEnumerable"/> with <see cref="T:Obtics.INotifyChanged"/> (internal change notification mechanism)
            </summary>
        </member>
        <member name="T:Obtics.Collections.Patches.ONCCPatch`1">
            <summary>
            A transformation object that transforms an <see cref="T:Obtics.Collections.IVersionedEnumerable`1"/> with <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/>
            to an <see cref="T:Obtics.Collections.IVersionedEnumerable`1"/> with <see cref="T:Obtics.INotifyChanged"/> (internal change notification mechanism)
            </summary>
            <typeparam name="TType">Type of the sequence elements</typeparam>
        </member>
        <member name="T:Obtics.Collections.ICollectionAdapterProvider">
            <summary>
            Interface for objects that can provide <see cref="T:Obtics.Collections.ICollectionAdapter"/> implementations for
            some types of unknown sequences.
            </summary>
        </member>
        <member name="M:Obtics.Collections.ICollectionAdapterProvider.GetCollectionAdapter(System.Type)">
            <summary>
            Gives an <see cref="T:Obtics.Collections.ICollectionAdapter"/> implementation for a specific type of unknown sequence.
            </summary>
            <param name="collectionType">The unknown sequence type</param>
            <returns>An <see cref="T:Obtics.Collections.ICollectionAdapter"/> that can adapt objects of type given by <paramref name="collectionType"/> or null of such an adapter can not be provided.</returns>
        </member>
        <member name="T:Obtics.Collections.CollectionAdapterProvider">
            <summary>
            Static class with static information about and helper methods for <see cref="T:Obtics.Collections.ICollectionAdapterProvider"/>.
            </summary>
        </member>
        <member name="P:Obtics.Collections.CollectionAdapterProvider.DefaultCollectionAdapterProviders">
            <summary>
            Gets and sets the default collection of adapter providers.
            </summary>
            <remarks>
            These adapter providers are considered after the ones configured in the configuration file.
            </remarks>
            <seealso cref="T:Obtics.Collections.ICollectionAdapterProvider"/>
            <permission cref="T:Obtics.Configuration.ExtendObticsPermission">Is needed for setting this property.</permission>
        </member>
        <member name="T:Obtics.Values.Transformations.AsCollectionNullableTransformation`1">
            <summary>
            AsCollectionNullableTransformation represents an IValueProvider as a Sequence (IEnumerable) with
            exactly one or no members. The result sequence will have no member if and only if 'predicate'
            returns false for the Value property of the source.
            </summary>
            <typeparam name="TType">Type of the Value property of the source and the members of the result sequence.</typeparam>
        </member>
        <member name="P:Obtics.Collections.Transformations.ConvertToPairsTransformation`2.Converter">
            <summary>
            Publication of COnverter specially for SortTransformation so that it doesn't need to
            maintain it's own copy.
            </summary>
        </member>
        <member name="T:Obtics.Values.ExpressionObserverMappingAttribute">
            <summary>
            Register an ExpressionObserver mapping for the member. This mapping is available in all ExpressionObserver(Object)s and can not be removed by an ExpressionObserverMaster.
            </summary>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMappingAttribute.#ctor(System.Reflection.MethodInfo[])">
            <summary>
            Register a specific set of target methods for the mapping
            </summary>
            <param name="targetMethods">The target methods the member is mapped to.</param>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMappingAttribute.#ctor(System.Type)">
            <summary>
            Register a declaring class to find the target methods in.
            </summary>
            <param name="targetMethodsDeclaringClass">The class to search for target methods.</param>
            <remarks>
            Target methods must be public static members of the declaring class and have the same name as the mapped member.
            </remarks>
        </member>
        <member name="M:Obtics.Values.ExpressionObserverMappingAttribute.#ctor(System.Type,System.String)">
            <summary>
            Register a declaring class to find the target methods in.
            </summary>
            <param name="targetMethodsDeclaringClass">The class to search for target methods.</param>
            <param name="targetMethodsName">Name of the target methods.</param>
            <remarks>
            Target methods must be public static members of the declaring class and have the same name as the mapped member.
            </remarks>
        </member>
        <member name="T:Obtics.Collections.CollectionsHelper">
            <summary>
            Probeert iets eerst te converteren naar een Ilist of een ICollection.
            Lukt dat niet, dan wordt een lijst aangemaakt.
            </summary>
        </member>
        <member name="M:Obtics.Collections.CollectionsHelper.TypedEnumerable``1(System.Collections.IEnumerable)">
            <summary>
            TypedEnumerable
            ConvertValue een untyped Enumerable naar een typed Enumerable
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:Obtics.INCEventArgsTypes">
            <summary>
            Different types of change notification
            </summary>
        </member>
        <member name="F:Obtics.INCEventArgsTypes.CollectionAdd">
            <summary>
            A single item has been added to a collection
            </summary>
        </member>
        <member name="F:Obtics.INCEventArgsTypes.CollectionRemove">
            <summary>
            A single item has been removed from a collection
            </summary>
        </member>
        <member name="F:Obtics.INCEventArgsTypes.CollectionReplace">
            <summary>
            A single item in a collection has been replaced with another single item.
            </summary>
        </member>
        <member name="F:Obtics.INCEventArgsTypes.CollectionReset">
            <summary>
            The entire contents of a collection has been changed.
            </summary>
        </member>
        <member name="F:Obtics.INCEventArgsTypes.PropertyChanged">
            <summary>
            A property of the supplier has changed value.
            </summary>
        </member>
        <member name="T:Obtics.INCEventArgs">
            <summary>
            Base class for change event argument objects.
            </summary>
        </member>
        <member name="T:Obtics.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Obtics.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Obtics.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Obtics.Properties.Resources.RewriteExceptionMessage">
            <summary>
              Looks up a localized string similar to Rewrite of System.Linq.Enumerable.ToList() or System.Linq.Enumerable.ToDictionary() not fully compatible. Cast result of call up to System.Collection.Generic.IList&lt;&gt; or System.Collection.Generic.IDictionary&lt;,&gt; before using in expression..
            </summary>
        </member>
        <member name="T:Obtics.Collections.Transformations.AllAggregate">
            <summary>
            Returns true if all booleans in the source have value true. Also returns true if the source is empty.
            </summary>
        </member>
        <member name="T:Obtics.Values.RewriteException">
            <summary>
            Represents errors that occurs during Expression rewriting.
            </summary>
        </member>
        <member name="M:Obtics.Values.RewriteException.#ctor">
            <summary>
            Initializes a new instance of the Obtics.Values.RewriteException class.
            </summary>
        </member>
        <member name="M:Obtics.Values.RewriteException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the Obtics.Values.RewriteException class with a specified
                error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Obtics.Values.RewriteException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the Obtics.Values.RewriteException class with serialized
                data.
            </summary>
            <param name="info">
            The System.Runtime.Serialization.SerializationInfo that holds the serialized
            object data about the exception being thrown.
            </param>
            <param name="context">
            The System.Runtime.Serialization.StreamingContext that contains contextual 
            information about the source or destination.
            </param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The info parameter is null.</exception>
        </member>
        <member name="M:Obtics.Values.RewriteException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the Obtics.Values.RewriteException class with a specified
            error message and a reference to the inner exception that is the cause of
            this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference
                (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="T:Obtics.Configuration.ExtendObticsPermission">
            <summary>
            Permission needed to be allowed to modify and extend the core functionality of Obtics from code.
            </summary>
        </member>
        <member name="M:Obtics.Configuration.ExtendObticsPermission.#ctor(System.Security.Permissions.PermissionState)">
            <summary>
            Create an ExtendObticsPermission object.
            </summary>
            <param name="state"><see cref="T:System.Security.Permissions.PermissionState"/> value indicating if permission or not is given.</param>
        </member>
        <member name="M:Obtics.Configuration.ExtendObticsPermission.Copy">
            <summary>
            Copy the current ExtendObticsPermission object. 
            </summary>
            <returns>A copy of the current ExtendObticsPermission object.</returns>
        </member>
        <member name="M:Obtics.Configuration.ExtendObticsPermission.ToXml">
            <summary>
            Converts the current ExtendObticsPermission object to an XML tag.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Obtics.Configuration.ExtendObticsPermission.FromXml(System.Security.SecurityElement)">
            <summary>
            Initializes the current ExtendObticsPermission object from an XML tag.
            </summary>
            <param name="elem">The XML tag to initialize the current ExtendObticsPermission object with.</param>
        </member>
        <member name="M:Obtics.Configuration.ExtendObticsPermission.Intersect(System.Security.IPermission)">
            <summary>
            Creates and returns a permission that is the intersection of the current permission and the specified permission.
            </summary>
            <param name="target">A permission to intersect with the current permission. It must be of the same type as the current permission.</param>
            <returns>A new permission that represents the intersection of the current permission and the specified permission. This new permission is a null reference if the intersection is empty.</returns>
        </member>
        <member name="M:Obtics.Configuration.ExtendObticsPermission.Union(System.Security.IPermission)">
            <summary>
            Creates a permission that is the union of the current permission and the specified permission.
            </summary>
            <param name="target">A permission to combine with the current permission. It must be of the same type as the current permission.</param>
            <returns>A new permission that represents the union of the current permission and the specified permission.</returns>
        </member>
        <member name="M:Obtics.Configuration.ExtendObticsPermission.IsSubsetOf(System.Security.IPermission)">
            <summary>
            Determines whether the current permission is a subset of the specified permission.
            </summary>
            <param name="target">A permission that is to be tested for the subset relationship. This permission must be of the same type as the current permission.</param>
            <returns>true if the current permission is a subset of the specified permission; otherwise, false.</returns>
        </member>
        <member name="M:Obtics.Configuration.ExtendObticsPermission.IsUnrestricted">
            <summary>
            Returns a value indicating whether the current permission is unrestricted.
            </summary>
            <returns>true if the current permission is unrestricted; otherwise, false.</returns>
        </member>
        <member name="T:Obtics.Configuration.ExtendObticsPermissionAttribute">
            <summary>
            Allows security actions for <see cref="T:Obtics.Configuration.ExtendObticsPermission"/> to be applied to code using declarative security. 
            </summary>
        </member>
        <member name="M:Obtics.Configuration.ExtendObticsPermissionAttribute.#ctor(System.Security.Permissions.SecurityAction)">
            <summary>
            Initializes a new instance of the ExtendObticsPermissionAttribute class with the specified SecurityAction.
            </summary>
            <param name="action">One of the <see cref="T:System.Security.Permissions.SecurityAction"/> values.</param>
        </member>
        <member name="M:Obtics.Configuration.ExtendObticsPermissionAttribute.CreatePermission">
            <summary>
            Creates and returns a new <see cref="T:Obtics.Configuration.ExtendObticsPermission"/>.
            </summary>
            <returns>A <see cref="T:Obtics.Configuration.ExtendObticsPermission"/> that corresponds to this attribute.</returns>
        </member>
    </members>
</doc>
