// Colony.cs
//
// Copyright (c) 2007 Mike Strobel
//
// This source code is subject to the terms of the Microsoft Reciprocal License (Ms-RL).
// For details, see <http://www.opensource.org/licenses/ms-rl.html>.
//
// All other rights reserved.

using Obtics.Values;
using Supremacy.Annotations;
using Supremacy.Buildings;
using Supremacy.Client;
using Supremacy.Collections;
using Supremacy.Diplomacy;
using Supremacy.Economy;
using Supremacy.Effects;
using Supremacy.Entities;
using Supremacy.Game;
using Supremacy.IO.Serialization;
using Supremacy.Orbitals;
using Supremacy.Tech;
using Supremacy.Types;
using Supremacy.Utility;

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;

namespace Supremacy.Universe
{
    /// <summary>
    /// Represents a colony in a star system.
    /// </summary>
    [Serializable]
    public class Colony : UniverseObject, IProductionCenter, ITradeCenter, IContactCenter
    {
        #region TotalEnergy Dynamic Property
        public static readonly DynamicProperty<int> TotalEnergyProperty = DynamicProperty<int>.Register(
            "TotalEnergy", 
            typeof(Colony), 
            new DynamicPropertyMetadata<int>(OnTotalEnergyChanged));

        private static void OnTotalEnergyChanged(DynamicObject d, DynamicPropertyChangedEventArgs<int> e)
        {
            ((Colony)d).OnPropertyChanged("TotalEnergy");
        }

        public int TotalEnergy
        {
            get { return GetValue(TotalEnergyProperty).CurrentValue; }
        }
        #endregion

        #region System Trade Routes Dynamic Property
        //public static readonly DynamicProperty<int> TotalTradeRoutesProperty = DynamicProperty<int>.Register(
        //    "ColonyTradeRoutes",
        //    typeof(Colony),
        //    new DynamicPropertyMetadata<int>(OnTotalTradeRoutesChanged));

        //public static void OnTotalTradeRoutesChanged(DynamicObject c, DynamicPropertyChangedEventArgs,<int> e)
        //{
        //    ((Colony)c).OnPropertyChanged("ColonyTradeRoutes");

        //}
        //public int ColonyTradeRoutes
        //{
        //    get { return GetValue(TotalTradeRoutesProperty).CurrentValue; }
        //   // get { return _tradeRoutes.Count(); }
        //}
        #endregion

        //public int ColonyTradeRoutes
        //{
        //    get { return _tradeRoutes.Count(); }
        //}

        /// <summary>
        /// The maximum number of production facilities per category that can exist
        /// on a single colony.
        /// </summary>
        public const int MaxProductionFacilities = 255;

        /// <summary>
        /// The base amount of food that is automatically produced without any food facilities
        /// being present in the system.  This must be enough to sustain a population that is
        /// smaller than the minimum labor allocation of a food production facility.
        /// </summary>
        public const int BaseFoodProduction = 10;

        private IValueProvider<int>[] _activeFacilities;
        private IValueProvider<int>[] _scrappedFacilities;
        private IValueProvider<int>[] _totalFacilities;
        private IValueProvider<int> _activeOrbitalBatteries;
        private IValueProvider<int> _scrappedOrbitalBatteries;
        private IValueProvider<int> _totalOrbitalBatteries;

        private IValueProvider<int> _activeFoodFacilities;
        private IValueProvider<int> _totalFoodFacilities;

        private IValueProvider<int> _activeIndustryFacilities;
        private IValueProvider<int> _totalIndustryFacilities;

        private IValueProvider<int> _activeEnergyFacilities;
        private IValueProvider<int> _totalEnergyFacilities;

        private IValueProvider<int> _activeResearchFacilities;
        private IValueProvider<int> _totalResearchFacilities;

        private IValueProvider<int> _activeIntelligenceFacilities;
        private IValueProvider<int> _totalIntelligenceFacilities;

        private ColonyFacilitiesAccessor _activeFacilitiesProvider;
        private ColonyFacilitiesAccessor _scrappedFacilitiesProvider;
        private ColonyFacilitiesAccessor _totalFacilitiesProvider;

        private byte _baseRawMaterials;         // amount of raw materials automatically generated by this colony
        private byte _baseDeuteriumGeneration;  // amount of deuterium automatically generated by this colony

        private KeyedCollectionBase<int, Building> _buildings;
        //private KeyedCollectionBase<GameObjectID, Inflitration> _infiltrations;

        private UniverseObjectList<OrbitalBattery> _orbitalBatteries;
        private ObservableCollection<BuildQueueItem> _buildQueue;
       // private ObservableCollection<BuildQueueItem> _buildSlotQueue;
        private BuildSlot _buildSlot;
        private Meter _creditsFromTrade;
        private int _tradeRoutesPossible = -1;
        private int _tradeRoutesAssigned = -1;
        private int[] _facilityTypes;
        private int _orbitalBatteryDesign;
        private Meter _foodReserves;
        private Meter _health;
        private string _inhabitantId;
        private bool _isProductionAutomated;
        private Meter _morale;
        private short _originalOwnerId;
        private Meter _population;
        private Meter _shieldStrength;

        private int _shipyardId;
        private int _systemId = -1;
        private CollectionBase<TradeRoute> _tradeRoutes;

        private Colony()
        {
            Initialize();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Colony"/> class.
        /// </summary>
        /// <param name="system">The system in which the <see cref="Colony"/> will exist.</param>
        /// <param name="inhabitants">The race that will inhabit the <see cref="Colony"/>.</param>
        public Colony(StarSystem system, Race inhabitants)
            : this()
        {
            if (system == null)
                throw new ArgumentNullException("system");
            if (inhabitants == null)
                throw new ArgumentNullException("inhabitants");
            
            _population.Maximum = system.GetMaxPopulation(inhabitants);

            _inhabitantId = inhabitants.Key;

            _shipyardId = -1;
            _systemId = system.ObjectID;

            if (system.HasRawMaterialsBonus)
            {
                _baseRawMaterials = (byte)(RandomHelper.Random(25) + 14);  // UPDATE X 31 july 2019. Adjust base duranium generation   // base value just in case its not customized

                var baseResProdTable = GameContext.Current.Tables.UniverseTables["BaseResourceProduction"];
                if (baseResProdTable != null)
                {
                    string random = "NO";

                    try
                    {
                        double.TryParse(baseResProdTable["RawMaterials"]["BaseValue"], out double baseValue);
                        random = baseResProdTable["RawMaterials"]["Random"];
                        random = random.ToUpperInvariant();
                        double.TryParse(baseResProdTable["RawMaterials"]["MinRandom"], out double rndMin);
                        double.TryParse(baseResProdTable["RawMaterials"]["MaxRandom"], out double rndMax);

                        byte tmpBaseRaw = (byte)baseValue;

                        int rndRange = (int)rndMax - (int)rndMin;
                        int rndValue = RandomHelper.Random(rndRange) + (int)rndMin;
                        if (random.Equals("YES"))
                        {
                            tmpBaseRaw = (byte)rndValue;
                        }
                        else if (random.Equals("ADD"))
                        {
                            tmpBaseRaw += (byte)rndValue;
                        }
                        else if (random.Equals("SUB"))
                        {
                            tmpBaseRaw -= (byte)rndValue;
                        }

                        _baseRawMaterials = tmpBaseRaw;
                    }
                    catch (Exception e)
                    {
                        GameLog.Core.General.Error(e);
                    }
                }
            }

            // Calculate random automatic generation/collection of Deuterium for this colony
            {
                byte baseValuePerGG = 10;

                var baseResProdTable = GameContext.Current.Tables.UniverseTables["BaseResourceProduction"];
                if (baseResProdTable != null)
                {
                    string random = "NO";

                    try
                    {
                        double.TryParse(baseResProdTable["Deuterium"]["BaseValue"], out double baseValue);
                        random = baseResProdTable["Deuterium"]["Random"];
                        random = random.ToUpperInvariant();
                        double.TryParse(baseResProdTable["Deuterium"]["MinRandom"], out double rndMin);
                        double.TryParse(baseResProdTable["Deuterium"]["MaxRandom"], out double rndMax);

                        byte tmpBaseValue = (byte)baseValue;

                        int rndRange = (int)rndMax - (int)rndMin;
                        int rndValue = RandomHelper.Random(rndRange) + (int)rndMin;
                        if (random.Equals("YES"))
                        {
                            tmpBaseValue = (byte)rndValue;
                        }
                        else if (random.Equals("ADD"))
                        {
                            tmpBaseValue += (byte)rndValue;
                        }
                        else if (random.Equals("SUB"))
                        {
                            tmpBaseValue -= (byte)rndValue;
                        }

                        baseValuePerGG = tmpBaseValue;
                    }
                    catch (Exception e)
                    {
                        GameLog.Core.General.Error(e);
                    }
                }

                _baseDeuteriumGeneration = (byte)system.Planets.Where(p => p.PlanetType == PlanetType.GasGiant).Sum(p => baseValuePerGG);
            }

            Location = system.Location;
            Owner = system.Owner;
            OriginalOwner = system.Owner;
        }

        public ColonyFacilitiesAccessor ActiveFacilities
        {
            get { return _activeFacilitiesProvider; }
        }

        public ColonyFacilitiesAccessor ScrappedFacilities
        {
            get { return _scrappedFacilitiesProvider; }
        }

        public ColonyFacilitiesAccessor TotalFacilities
        {
            get { return _totalFacilitiesProvider; }
        }

        public ColonyFacilitiesAccessor FoodActiveFacilities
        {
            get { return _activeFacilitiesProvider; }
        }
        public ColonyFacilitiesAccessor IndustryActiveFacilities
        {
            get { return _activeFacilitiesProvider; }
        }
        public ColonyFacilitiesAccessor EnergyActiveFacilities
        {
            get { return _activeFacilitiesProvider; }
        }
        public ColonyFacilitiesAccessor ResearchActiveFacilities
        {
            get { return _activeFacilitiesProvider; }
        }
        public ColonyFacilitiesAccessor IntelligenceActiveFacilities
        {
            get { return _activeFacilitiesProvider; }
        }
        public int AvailableLabor
        {
            get 
            {
                int _available = GetAvailableLabor() / 10 * -1;
                if (_available < 1)
                    _available = 0;
                return _available; 
            }
        }
        public OrbitalBatteryDesign OrbitalBatteryDesign
        {
            get
            {
                if (_orbitalBatteryDesign == TechObjectDesign.InvalidDesignID)
                    return null;

                return GameContext.Current.TechDatabase[_orbitalBatteryDesign] as OrbitalBatteryDesign;
            }
            set
            {
                if (value == null)
                    _orbitalBatteryDesign = TechObjectDesign.InvalidDesignID;
                else
                    _orbitalBatteryDesign = value.DesignID;
            }
        }

        public IIndexedCollection<OrbitalBattery> OrbitalBatteries
        {
            get { return _orbitalBatteries; }
        }

        /// <summary>
        /// Gets the type of the <see cref="UniverseObject"/>.
        /// </summary>
        /// <value>The type of the <see cref="UniverseObject"/>.</value>
        public override sealed UniverseObjectType ObjectType
        {
            get { return UniverseObjectType.Colony; }
        }

        /// <summary>
        /// Gets the original owner of this <see cref="Colony"/>.
        /// </summary>
        /// <value>The original owner.</value>
        /// <remarks>
        /// The original owner of a <see cref="Colony"/> is the <see cref="Civilization"/>
        /// that originally established the colony.  This value never changes.
        /// </remarks>
        public Civilization OriginalOwner
        {
            get
            {
                if (_originalOwnerId == Civilization.InvalidID)
                    return null;
                return GameContext.Current.Civilizations[_originalOwnerId];
            }
            private set
            {
                _originalOwnerId = (value != null)
                                       ? (short)value.CivID
                                       : (short)Civilization.InvalidID;
            }
        }

        public Percentage GrowthRate
        {
            get
            {
                var baseGrowthRate = ((decimal)System.GetGrowthRate(Inhabitants) * (((decimal)-0.8 + (decimal)_health.PercentFilled) * 5)) * 100;
                var modifier = new ValueModifier<decimal>
                               {
                                   IsOffsetAppliedFirst = false,
                                   HasCompoundMultiplier = false
                               };
                foreach (var building in Buildings.Where(b => b.IsActive))
                {
                    foreach (var bonus in building.BuildingDesign.Bonuses)
                    {
                        if (bonus.BonusType == BonusType.GrowthRate)
                        {
                            modifier.Offset += bonus.Amount;
                        }
                        else if (bonus.BonusType == BonusType.PercentGrowthRate)
                        {
                            modifier.Multiplier += (0.01f * bonus.Amount);
                        }
                    }
                }
                return Convert.ToSingle(0.01m * modifier.Apply(baseGrowthRate));
            }
        }

        public int MaxPopulation
        {
            get
            {
                int totalMoonSizes = 0;
                var baseValue = System.GetMaxPopulation(Inhabitants);

                totalMoonSizes += System.Planets.SelectMany(p => p.Moons.Where(m => m.GetSize() == MoonSize.Small)).Sum(m => 1);
                totalMoonSizes += System.Planets.SelectMany(p => p.Moons.Where(m => m.GetSize() == MoonSize.Medium)).Sum(m => 2);
                totalMoonSizes += System.Planets.SelectMany(p => p.Moons.Where(m => m.GetSize() == MoonSize.Large)).Sum(m => 3);

                var maxPopPerMoonSize = (
                                            from building in Buildings
                                            where building.IsActive
                                            select building.BuildingDesign.GetBonuses(BonusType.MaxPopulationPerMoonSize).Sum(o => o.Amount)
                                        ).Sum();

                return (baseValue + (maxPopPerMoonSize * totalMoonSizes));
            }
        }

        /// <summary>
        /// Gets the food reserves meter for this  <see cref="Colony"/>.
        /// </summary>
        /// <value>The food reserves.</value>
        public Meter FoodReserves
        {
            get { return _foodReserves; }
        }

        /// <summary>
        /// Gets the star system in which this <see cref="Colony"/> resides.
        /// </summary>
        /// <value>The star system.</value>
        public StarSystem System
        {
            get { return GameContext.Current.Universe.Get<StarSystem>(_systemId); }
        }

        /// <summary>
        /// Gets or sets the name of this <see cref="Colony"/>.
        /// </summary>
        /// <value>The name.</value>
        public override string Name
        {
            get { return base.Name ?? ((System != null) ? System.Name : null); }
        }

        /// <summary>
        /// Gets the race that inhabits this <see cref="Colony"/>.
        /// </summary>
        /// <value>The race.</value>
        public Race Inhabitants
        {
            get { return GameContext.Current.Races[_inhabitantId]; }
        }

        /// <summary>
        /// Gets or sets the shipyard present at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The shipyard.</value>
        public Shipyard Shipyard
        {
            get
            {
                if (_shipyardId == -1)
                    return null;
                return GameContext.Current.Universe.Objects[_shipyardId] as Shipyard;
            }
            set
            {
                if (value == null)
                    _shipyardId = -1;
                else
                    _shipyardId = value.ObjectID;

                OnPropertyChanged("Shipyard");
            }
        }

        public string ShipyardSlot_1_Status(ShipyardBuildSlot buildSlot)
        {
            string status = this.GetShipyardSlotStatus(buildSlot);
            //return status;
            return "hello";
        }

        public string GetShipyardSlotStatus(ShipyardBuildSlot buildSlot)
        {
                if (buildSlot == null)
                    return "not available";

                var shipyard = Shipyard;
                if (shipyard == null || !Equals(shipyard, buildSlot.Shipyard))
                    return "error";

                if (!buildSlot.IsActive)
                    return "in-active";

                if (shipyard.ShipyardDesign.BuildSlotEnergyCost > NetEnergy)
                    return "out of energy";

                string status = "hello";
                status = buildSlot.Project.BuildDesign.ToString();
                //return base.Name ?? ((System != null) ? System.Name : null); 

                return status;
        }

        /// <summary>
        /// Gets the population of this <see cref="Colony"/>.
        /// </summary>
        /// <value>The population.</value>
        public Meter Population
        {
            get { return _population; }
        }

        /// <summary>
        /// Gets the planetary shield strength of this <see cref="Colony"/>.
        /// </summary>
        /// <value>The planetary shield strength.</value>
        public Meter ShieldStrength
        {
            get { return _shieldStrength; }
        }

        /// <summary>
        /// Gets the local morale at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The morale.</value>
        public Meter Morale
        {
            get { return _morale; }
        }

        /// <summary>
        /// Gets the buildings at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The buildings.</value>
        public IObservableIndexedCollection<Building> Buildings
        {
            get { return _buildings; }
        }

        /// <summary>
        /// Gets the active buildings at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The active buildings.</value>
        public IEnumerable<Building> ActiveBuildings
        {
            get
            {
                return Obtics.Collections.ObservableEnumerable.Where(
                    _buildings, 
                    o => ValueProvider.Property<Building, bool>(o, "IsActive"));
            }
        }

        /// <summary>
        /// Gets the buildings at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The buildings.</value>
        internal IList<Building> BuildingsInternal
        {
            get { return _buildings; }
        }

        /// <summary>
        /// Gets or sets a value indicating whether production is automated.
        /// </summary>
        /// <value>
        /// <c>true</c> if production automated; otherwise, <c>false</c>.
        /// </value>
        public bool IsProductionAutomated
        {
            get { return _isProductionAutomated || !Owner.IsHuman; }
            set { _isProductionAutomated = value; }
        }

        /// <summary>
        /// Gets the scrap bonus at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The scrap bonus.</value>
        /// <remarks>
        /// The scrap bonus is a multiplier that gets applied to the amount of credits
        /// and resources recovered when scrapping an item at this <see cref="Colony"/>.
        /// </remarks>
        public Percentage ScrapBonus
        {
            get
            {
                return 0.01f * (from building in Buildings
                                where building.IsActive && !building.Scrap
                                from bonus in building.BuildingDesign.GetBonuses(BonusType.PercentScrapping)
                                select bonus).Sum(o => o.Amount);
            }
        }

        /// <summary>
        /// Gets the population health level at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The population health level.</value>
        public Meter Health
        {
            get { return _health; }
        }

        #region Properties for System Panel Data Binding
        /// <summary>
        /// Gets the credits produced at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The credits.</value>
        public int TaxCredits
        {
            get
            {
                int _taxCredits = 0;
                var modifier = new OutputModifier(0, 1.0f);
                var moraleMod = _morale.CurrentValue / (0.5f * MoraleHelper.MaxValue);
                var adjustedPop = Population.CurrentValue * moraleMod;

                foreach (var building in Buildings) // bonus from special structures
                {
                    if (!building.IsActive)
                        continue;

                    foreach (var bonus in building.BuildingDesign.Bonuses)
                    {
                        if (bonus.BonusType == BonusType.Credits)
                        {
                            modifier.Bonus += bonus.Amount;
                            GameLog.Core.Credits.DebugFormat("{0}: Bonus Credits Amount = {1}", building.Design, bonus.Amount);

                        }
                        else if (bonus.BonusType == BonusType.PercentCredits)
                        {
                            modifier.Efficiency += (bonus.Amount / 100f);
                            GameLog.Core.Credits.DebugFormat("{0}: Bonus Credits Percent = {1}", building.Design, bonus.Amount/100f);
                        }
                    }
                }


                // it's: 
                // a) Pop (* modifier, mostly 1.0) + modifier.Bonus (often 0) + NetIndustry
                // b) NetIndustry: it's 150% tax income from NetIndustry, so more income from Industry than from Population
                // c) base value = 200

                // OLD - 31 july 2019 *3 to *3.5 and +500
                _taxCredits = (int)((adjustedPop * modifier.Efficiency * moraleMod) + modifier.Bonus + NetIndustry * 1.5 + 200);

                // only for LocalPlayer
                //if (this.OwnerID == )
                //GameLog.Core.Credits.DebugFormat("########## Turn;{0};MoraleMOD =;{4};Effic.MOD =;{5};BonusMOD =;{7};Pop =;{3};NetIndustry =;{6};TaxCredits =;{8}; for ;{1};{2}"
                //    , GameContext.Current.TurnNumber
                //    , this.Name
                //    , Location
                //    , adjustedPop
                //    , moraleMod
                //    , modifier.Efficiency
                //    , NetIndustry
                //    , modifier.Bonus
                //    , _taxCredits
                //);

                return _taxCredits; 
            }
        }

        /// <summary>
        /// Gets the credits the civilization<see cref="Colony"/>.
        /// </summary>
        /// <value>The credits.</value>
        public int CreditsForSpyScreen
        {
            get
            {
                Int32.TryParse(GameContext.Current.CivilizationManagers[Owner].Credits.ToString(), out int creditsForSpyScreen);

                GameLog.Core.UI.DebugFormat("{0} - {1}: Credits = {2}, creditsForSpyScreen = {3}", GameContext.Current.CivilizationManagers[Owner].Civilization.Key,
                    this.Name, GameContext.Current.CivilizationManagers[Owner].Credits.CurrentValue, creditsForSpyScreen);

                return creditsForSpyScreen;
            }
        }

        /// <summary>
        /// Gets the credits the civilization<see cref="Colony"/>.
        /// </summary>
        /// <value>The credits.</value>
        public Meter ResearchForSpyScreen
        {
            get
            {
                Meter researchForSpyScreen = GameContext.Current.CivilizationManagers[Owner].Research.CumulativePoints;

                //var modifier = new OutputModifier(0, 1.0f);
                //var moraleMod = _morale.CurrentValue / (0.5f * MoraleHelper.MaxValue);
                //var adjustedPop = Population.CurrentValue * moraleMod;

                //foreach (var building in Buildings) // bonus from special structures
                //{
                //    if (!building.IsActive)
                //        continue;

                //    foreach (var bonus in building.BuildingDesign.Bonuses)
                //    {
                //        if (bonus.BonusType == BonusType.Credits)
                //            modifier.Bonus += bonus.Amount;
                //        else if (bonus.BonusType == BonusType.PercentCredits)
                //            modifier.Efficiency += (bonus.Amount / 100f);
                //    }
                //}

                return researchForSpyScreen;
            }
        }

        /// <summary>
        /// Gets the net food production at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The net food production.</value>
        public int NetFood
        {
            get { return GetProductionOutput(ProductionCategory.Food) - Population.CurrentValue; }
        }

        /// <summary>
        /// Gets the net industry production at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The net industry production.</value>
        public int NetIndustry
        {
            get { return GetProductionOutput(ProductionCategory.Industry); }
        }

        /// <summary>
        /// Gets the net energy production at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The net energy production.</value>
        public int NetEnergy
        {
            get
            {
                var energyUsed = Buildings
                    .Where(building => building.IsActive)
                    .Sum(building => building.BuildingDesign.EnergyCost);

                var shipyard = Shipyard;
                if (shipyard != null)
                {
                    energyUsed += shipyard.BuildSlots
                        .Where(o => o.IsActive)
                        .Sum(o => shipyard.ShipyardDesign.BuildSlotEnergyCost);
                }

                var orbitalBatteryDesign = OrbitalBatteryDesign;
                if (orbitalBatteryDesign != null)
                    energyUsed += (orbitalBatteryDesign.UnitEnergyCost * _activeOrbitalBatteries.Value);

                return (GetProductionOutput(ProductionCategory.Energy) - energyUsed);
            }
        }

        /// <summary>
        /// Gets the net research production at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The net research production.</value>
        public int NetResearch
        {
            get { return GetProductionOutput(ProductionCategory.Research); }
        }

        /// <summary>
        /// Gets the net intelligence production at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The net intelligence production.</value>
        public int NetIntelligence
        {
            get
            {
                //GameLog.Client.Intel.DebugFormat("NetIntelligence ={0}", GetProductionOutput(ProductionCategory.Intelligence));
                return GetProductionOutput(ProductionCategory.Intelligence);
            }
        }

        /// <summary>
        /// Gets the net dilithium production at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The net dilithium production.</value>
        public int NetDilithium
        {
            get { return GetResourceProduction(ResourceType.Dilithium); }
        }

        /// <summary>
        /// Gets the net deuterium production at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The net deuterium production.</value>
        public int NetDeuterium
        {
            get { return GetResourceProduction(ResourceType.Deuterium); }
        }

        /// <summary>
        /// Gets the net raw materials production at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The net raw materials production.</value>
        public int NetRawMaterials
        {
            get { return GetResourceProduction(ResourceType.RawMaterials); }
        }
        #endregion

        #region IProductionCenter Members
        /// <summary>
        /// Gets or sets the owner ID of this <see cref="Colony"/>.  This should be the
        /// CivID property of the owner Civilization.
        /// </summary>
        /// <value>The owner ID.</value>
        public override int OwnerID
        {
            get { return base.OwnerID; }
            set
            {
                base.OwnerID = value;

                if (value != -1)
                {
                    var system = System;
                    if (system != null)
                        system.OwnerID = value;

                    foreach (var building in Buildings)
                        building.OwnerID = value;
                }

                if (_originalOwnerId == -1)
                    _originalOwnerId = (short)value;
            }
        }

        /// <summary>
        /// Gets the build queue at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The build queue.</value>
        public IList<BuildQueueItem> BuildQueue
        {
            get { return _buildQueue; }
        }

        /// <summary>
        /// Gets the buildslot queue at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The build queue.</value>
        //public IList<BuildQueueItem> BuildSlotQueue
        //{
        //    get { return _buildSlotQueue; }
        //}

        /// <summary>
        /// Gets the build slots at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The build slots.</value>
        [NotNull]
        public IIndexedEnumerable<BuildSlot> BuildSlots
        {
            get { return IndexedEnumerable.Single(_buildSlot); }
        }

        /// <summary>
        /// Gets the build output for the specified build slot number.
        /// </summary>
        /// <param name="slot">The build slot number.</param>
        /// <returns>The build output.</returns>
        public int GetBuildOutput(int slot)
        {
            return GetProductionOutput(ProductionCategory.Industry);
        }

        /// <summary>
        /// Remove any completed projects from the build slots and dequeue new projects
        /// as slots become available.
        /// </summary>
        public void ProcessQueue()
        {
            int count = 0;
            foreach (var buildQueueItem in BuildQueue)
            {
                GameLog.Client.ShipProduction.DebugFormat("Colony BuildQueueItem = {0}, index {1}", buildQueueItem.Description, count);
                count++;
            }
            foreach (var slot in BuildSlots)
            {
                if (slot.HasProject && slot.Project.IsCancelled)
                    slot.Project = null;

                if (slot.Project != null)
                    continue;

                var queueItem = BuildQueue.FirstOrDefault(); // queue of colony non-ship build projects to construct
                if (queueItem == null)
                    continue;

                if (queueItem.Count > 1)
                {
                    slot.Project = queueItem.Project.CloneEquivalent(); 
                    queueItem.DecrementCount();
                }
                else
                {
                    slot.Project = queueItem.Project;
                    BuildQueue.Remove(queueItem);
                }                
            }
        }
        public void ProcessBuildSlotQueue()
        {
            //int count = 0;
            //foreach (var _buildSlotQueueItem in BuildSlotQueue)
            //{
            //    GameLog.Client.ShipProduction.DebugFormat("Colony BuildSlotQueueItem = {0}, index {1}", _buildSlotQueueItem.Description, count);
            //    count++;
            //}
            //var buildSlotQueueItem = BuildSlotQueue.FirstOrDefault();
            ////if (buildSlotQueueItem == null)
            ////    return;

            //if (buildSlotQueueItem != null && buildSlotQueueItem.Count > 1)
            //{
            //    BuildSlots[0].Project = buildSlotQueueItem.Project.CloneEquivalent();
            //    buildSlotQueueItem.DecrementCount();
            //}
            //else
            //{
            //    BuildSlots[0].Project = buildSlotQueueItem.Project;
            //    BuildSlotQueue.Remove(buildSlotQueueItem);
            //}
        }
        #endregion

        #region ITradeCenter Members
        /// <summary>
        /// Gets the trade routes available at this <see cref="Colony"/>.
        /// </summary>
        /// <value>The trade routes.</value>
        public IList<TradeRoute> TradeRoutes
        {
            get { return _tradeRoutes; }
        }

        public Meter CreditsFromTrade
        {
            get { return _creditsFromTrade; }
        }

        public int TradeRoutesPossible
        {
            get 
            {

                _tradeRoutesPossible = _tradeRoutes.Count - TradeRoutesAssigned;

                if (_tradeRoutesPossible < 1)
                    _tradeRoutesPossible = 0;

                return _tradeRoutesPossible; 
            }
        }

        public int TradeRoutesAssigned
        {
            get 
            {
                int tradeRouteAssigned = 0;
                foreach (var tr in TradeRoutes)
                {
                    if (tr.IsAssigned)
                    {
                        tradeRouteAssigned += 1;
                    }
                }
                return tradeRouteAssigned;
            }
        }

        public void UpdateCreditsFromTrade()
        {
            this.ResetCreditsFromTrade();
        }

        public int TurnNumberValuesFrom()
        {
            return GameContext.Current.TurnNumber;
        }
        #endregion


        private void Initialize()
        {
            var categories = EnumUtilities.GetValues<ProductionCategory>();

            EnsureValueProviders();

            _facilityTypes = new int[categories.Count];

            for (var i = 0; i < _facilityTypes.Length; i++)
                _facilityTypes[i] = TechObjectDesign.InvalidDesignID;

            _orbitalBatteryDesign = TechObjectDesign.InvalidDesignID;

            _population = new Meter(0, 0, Meter.MaxValue);
            _population.PropertyChanged += PopulationPropertyChanged;
            _health = new Meter(80, 0, 100);

            _shieldStrength = new Meter(0, 0, 0) { AutoClamp = false };

            _morale = new Meter(100, MoraleHelper.MinValue, MoraleHelper.MaxValue);

            _foodReserves = new Meter(0, Meter.MaxValue);

            _tradeRoutes = new CollectionBase<TradeRoute>();
            _buildings = new KeyedCollectionBase<int, Building>(o => o.ObjectID);
            _orbitalBatteries = new UniverseObjectList<OrbitalBattery>();
            _creditsFromTrade = new Meter();
            _buildSlot = new BuildSlot();
            _buildQueue = new ObservableCollection<BuildQueueItem>();
            //_buildSlotQueue = new ObservableCollection<BuildQueueItem>();

            _baseRawMaterials = 0;
            _baseDeuteriumGeneration = 0;
        }

        /// <summary>
        /// Handles the PropertyChanged event of the Population control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="PropertyChangedEventArgs"/> instance containing the event data.</param>
        protected void PopulationPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "CurrentValue")
                OnPropertyChanged("NetFood");
        }

        /// <summary>
        /// Captures this <see cref="Colony"/>.
        /// </summary>
        /// <param name="newOwner">The new owner.</param>
        /// <param name="isCapture"></param>
        /// <remarks>
        /// When capturing, the Owner of the <see cref="Colony"/> is changed, and the
        /// capture result of each building is checked and executed. 
        /// </remarks>
        public void TakeOwnership(Civilization newOwner, bool isCapture)
        {
            if (newOwner == null)
                return;

            var currentOwnerManager = CivilizationManager.For(OwnerID);
            var newOwnerManager = CivilizationManager.For(newOwner);

            Owner = newOwner;

            if (isCapture)
            {
                Buildings
                    .Where(building => building.BuildingDesign.CaptureResult == CaptureResult.Destroy)
                    .ToList()
                    .ForEach(o => o.Destroy());
            }

            Buildings.ForEach(o => o.Owner = newOwner);

            if (Shipyard != null)
                Shipyard.Owner = newOwner;

            currentOwnerManager.Colonies.Remove(this);
            newOwnerManager.Colonies.Add(this);

            newOwnerManager.MapData.SetExplored(Location, true);

            if (!newOwner.IsHuman)
                return;

            var diplomat = Diplomat.Get(newOwner);
            diplomat.GetForeignPower(currentOwnerManager.Civilization).UpdateStatus();
        }

        /// <summary>
        /// Called when the Build Queue changes.
        /// </summary>
        internal void OnBuildQueueChanged()
        {
            OnPropertyChanged("BuildQueue");
        }

        /// <summary>
        /// Adds a building to this <see cref="Colony"/>.
        /// </summary>
        /// <param name="building">The building to add.</param>
        public void AddBuilding(Building building)
        {
            if (Buildings.Contains(building))
                return;
            building.IsActive = false;
            building.Location = Location;
            _buildings.Add(building);
            ActivateBuilding(building);
            if (building.BuildingDesign.Bonuses.Any(o => o.BonusType == BonusType.MaxPopulationPerMoonSize))
                Population.Maximum = MaxPopulation;
        }

        /// <summary>
        /// Removes a building from this <see cref="Colony"/>.
        /// </summary>
        /// <param name="building">The building to remove.</param>
        public void RemoveBuilding(Building building)
        {
            if (!Buildings.Contains(building))
                return;
            DeactivateBuilding(building);
            _buildings.Remove(building);
            if (Shipyard == building)
                Shipyard = null;
            if (building.BuildingDesign.Bonuses.Any(o => o.BonusType == BonusType.MaxPopulationPerMoonSize))
                Population.Maximum = MaxPopulation;
        }

        /// <summary>
        /// Adds a single facility of the specified category to this <see cref="Colony"/>.
        /// </summary>
        /// <param name="category">The production category.</param>
        public void AddFacility(ProductionCategory category)
        {
            AddFacilities(category, 1);
        }

        /// <summary>
        /// Adds multiple facilities of the specified category to this <see cref="Colony"/>.
        /// </summary>
        /// <param name="category">The production category.</param>
        /// <param name="count">The number of facilities to add.</param>
        public void AddFacilities(ProductionCategory category, int count)
        {
            _totalFacilities[(int)category].Value += (byte)count;
        }

        /// <summary>
        /// Removes a single facility of the specified category from this <see cref="Colony"/>.
        /// </summary>
        /// <param name="category">The production category.</param>
        public void RemoveFacility(ProductionCategory category)
        {
            RemoveFacilities(category, 1);
        }

        /// <summary>
        /// Removes multiple facilities of the specified category from this <see cref="Colony"/>.
        /// </summary>
        /// <param name="category">The production category.</param>
        /// <param name="count">The number of facilities to remove.</param>
        public void RemoveFacilities(ProductionCategory category, int count)
        {
            int toDeactivate = -(_totalFacilities[(int)category].Value - _activeFacilities[(int)category].Value - count);
            for (int i = 0; i < toDeactivate; i++)
                DeactivateFacility(category);
            _totalFacilities[(int)category].Value -= (byte)count;
        }

        /// <summary>
        /// Gets the number of facilities to be scrapped for the specified category.
        /// </summary>
        /// <param name="category">The production category.</param>
        /// <returns>The number of facilities to be scrapped.</returns>
        public int GetScrappedFacilities(ProductionCategory category)
        {
            return _scrappedFacilities[(int)category].Value;
        }

        /// <summary>
        /// Sets the number of facilities to be scrapped for the specified category.
        /// </summary>
        /// <param name="category">The production category.</param>
        /// <param name="count">The number of facilities to be scrapped.</param>
        public void SetScrappedFacilities(ProductionCategory category, int count)
        {
            if (count < 0)
                count = 0;
            else if (count > _totalFacilities[(int)category].Value)
                count = _totalFacilities[(int)category].Value;
            _scrappedFacilities[(int)category].Value = (byte)count;
        }

        /// <summary>
        /// Perform the actual scrapping of the facilities designated as scrap.
        /// </summary>
        public void ScrapNonStructures()
        {
            foreach (var category in EnumHelper.GetValues<ProductionCategory>())
            {
                while (_scrappedFacilities[(int)category].Value > 0)
                {
                    RemoveFacility(category);
                    _scrappedFacilities[(int)category].Value--;
                }
            }

            while (_scrappedOrbitalBatteries.Value > 0)
            {
                _scrappedOrbitalBatteries.Value--;
                RemoveOrbitalBatteries(1);
                OnPropertyChanged("ScrappedOrbitalBatteries");
            }
        }

        /// <summary>
        /// Gets the natural production level of a given resource for this colony.
        /// </summary>
        /// <param name="resourceType">The resource type.</param>
        /// <param name="currentPopulation">The current population of the colony.</param>
        /// <returns>The natural production level.</returns>
        protected internal int GetBaseResourceProduction(ResourceType resourceType, int currentPopulation)
        {
            switch (resourceType)
            {
                case ResourceType.Deuterium:
                    return _baseDeuteriumGeneration;
                case ResourceType.RawMaterials:
                    return _baseRawMaterials;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// Gets the natural production level of a given resource for this colony.
        /// </summary>
        /// <param name="resourceType">The resource type.</param>
        /// <returns>The natural production level.</returns>
        protected internal int GetBaseResourceProduction(ResourceType resourceType)
        {
            return GetBaseResourceProduction(resourceType, Population.CurrentValue);
        }

        /// <summary>
        /// Gets the amount of output for the specified production category.
        /// </summary>
        /// <param name="category">The production category.</param>
        /// <returns>The production output.</returns>
        public int GetProductionOutput(ProductionCategory category)
        {
            int unitOutput = GetFacilityType(category).UnitOutput;
            int activeUnits = GetActiveFacilities(category);
            var modifier = GetProductionModifier(category);
            int baseOutput = unitOutput * activeUnits;
            switch (category)
            {
                case ProductionCategory.Food:
                    if (baseOutput < 10)
                        baseOutput = 10;
                    break;
                case ProductionCategory.Intelligence:
                    if (baseOutput < 10)
                        baseOutput = 10;
                    break;
                case ProductionCategory.Research:
                    {
                        float moraleMod = _morale.CurrentValue / (0.5f * MoraleHelper.MaxValue);
                        baseOutput = (int)(moraleMod * baseOutput);
                    }
                    break;
                case ProductionCategory.Industry:
                    {
                        float moraleMod = _morale.CurrentValue / (0.5f * MoraleHelper.MaxValue);
                        baseOutput = (int)(moraleMod * baseOutput);
                        if (baseOutput < 10)
                            baseOutput = 10;
                    }
                    break;
                case ProductionCategory.Energy:
                    {
                        float moraleMod = _morale.CurrentValue / (0.5f * MoraleHelper.MaxValue);
                        baseOutput = (int)(moraleMod * baseOutput);
                        if (baseOutput < 10)
                            baseOutput = 10;
                    }
                    break;
            }
            return ((int)(baseOutput + (baseOutput * modifier.Efficiency)) + modifier.Bonus);
        }

        /// <summary>
        /// Gets the estimated resource production levels for the next turn.
        /// </summary>
        /// <returns>The estimated resource production levels for the next turn.</returns>
        public ResourceValueCollection GetEstimatedResourcesProduction()
        {
            var values = new ResourceValueCollection();
            foreach (var resourceType in EnumHelper.GetValues<ResourceType>())
                values[resourceType] = GetResourceProduction(resourceType);
            return values;
        }

        /// <summary>
        /// Gets the current production output for the specified resource design.
        /// </summary>
        /// <param name="resource">The resource design.</param>
        /// <returns>The production output.</returns>
        public int GetResourceProduction(ResourceType resource)
        {
            int baseValue = 0;
            var modifier = GetResourceModifier(resource);
            if (resource == ResourceType.RawMaterials)
            {
                baseValue = GetBaseResourceProduction(resource);
            }
            else if (resource == ResourceType.Deuterium)
            {
                baseValue = GetBaseResourceProduction(ResourceType.Deuterium);
            }
            return (int)((baseValue + (baseValue * modifier.Efficiency) + modifier.Bonus+2)); // UPDATE X 28 july 2019 reduced a bit deuterium
        }

        /// <summary>
        /// Gets the resource production modifier for the specified resource design.
        /// </summary>
        /// <param name="resource">The resource design.</param>
        /// <returns>The resource production modifier.</returns>
        public OutputModifier GetResourceModifier(ResourceType resource)
        {
            var modifier = new OutputModifier(0, 0.0f);

            foreach (var building in Buildings)
            {
                if (!building.IsActive)
                    continue;
                foreach (var bonus in building.BuildingDesign.Bonuses)
                {
                    switch (resource)
                    {
                        case ResourceType.Deuterium:
                            if (bonus.BonusType == BonusType.Deuterium)
                                modifier.Bonus += bonus.Amount;
                            else if (bonus.BonusType == BonusType.PercentDeuterium)
                                modifier.Efficiency += (bonus.Amount / 100f);
                            break;
                        case ResourceType.Dilithium:
                            if (bonus.BonusType == BonusType.Dilithium)
                                modifier.Bonus += bonus.Amount;
                            break;
                        case ResourceType.RawMaterials:
                            if (bonus.BonusType == BonusType.RawMaterials)
                                modifier.Bonus += bonus.Amount;
                            else if (bonus.BonusType == BonusType.PercentRawMaterials)
                                modifier.Efficiency += (bonus.Amount / 100f);
                            break;
                    }
                }
            }

            return modifier;
        }

        /// <summary>
        /// Gets the production output modifier for the specified category.
        /// </summary>
        /// <param name="category">The production category.</param>
        /// <returns>The production output modifier.</returns>
        public OutputModifier GetProductionModifier(ProductionCategory category)
        {
            var modifier = new OutputModifier(0, 0.0f);
            Percentage moraleMod = _morale.CurrentValue / (0.5f * MoraleHelper.MaxValue);

            if (category == ProductionCategory.Food)
            {
                foreach (var planet in System.Planets)
                {
                    if (planet.HasFoodBonus)
                        modifier.Efficiency += 0.15f;
                }
            }
            else if (category == ProductionCategory.Energy)
            {
                foreach (var planet in System.Planets)
                {
                    if (planet.HasEnergyBonus)
                        modifier.Efficiency += 0.15f;
                }
            }

            foreach (var building in Buildings)
            {
                if (!building.IsActive)
                    continue;
                foreach (var bonus in building.BuildingDesign.Bonuses)
                {
                    switch (category)
                    {
                        case ProductionCategory.Food:
                            if (bonus.BonusType == BonusType.Food)
                                modifier.Bonus += bonus.Amount;
                            else if (bonus.BonusType == BonusType.PercentFood)
                                modifier.Efficiency += (bonus.Amount / 100f);
                            break;
                        case ProductionCategory.Intelligence:
                            if (bonus.BonusType == BonusType.Intelligence)
                                modifier.Bonus += bonus.Amount;
                            else if (bonus.BonusType == BonusType.PercentIntelligence)
                                modifier.Efficiency += (bonus.Amount / 100f);
                            break;
                        case ProductionCategory.Industry:
                            if (bonus.BonusType == BonusType.Industry)
                                modifier.Bonus += bonus.Amount;
                            else if (bonus.BonusType == BonusType.PercentIndustry)
                                modifier.Efficiency += (bonus.Amount / 100f);
                            break;
                        case ProductionCategory.Energy:
                            if (bonus.BonusType == BonusType.Energy)
                                modifier.Bonus += bonus.Amount;
                            else if (bonus.BonusType == BonusType.PercentEnergy)
                                modifier.Efficiency += (bonus.Amount / 100f);
                            break;
                        case ProductionCategory.Research:
                            if (bonus.BonusType == BonusType.Research)
                                modifier.Bonus += bonus.Amount;
                            break;
                    }
                }
            }

            modifier.Efficiency *= moraleMod;

            return modifier;
        }

        /// <summary>
        /// Gets the number of active facilities for the specified category.
        /// </summary>
        /// <param name="category">The production category.</param>
        /// <returns>The number of active facilities.</returns>
        public int GetActiveFacilities(ProductionCategory category)
        {
            return _activeFacilities[(int)category].Value;
        }

        /// <summary>
        /// Gets the total number of facilities for the specified category.
        /// </summary>
        /// <param name="category">The production category.</param>
        /// <returns>The total number of facilities.</returns>
        public int GetTotalFacilities(ProductionCategory category)
        {
            return _totalFacilities[(int)category].Value;
        }

        /// <summary>
        /// Gets the production facility design for the specified category.
        /// </summary>
        /// <param name="category">The production category.</param>
        /// <returns>The production facility design.</returns>
        public ProductionFacilityDesign GetFacilityType(ProductionCategory category)
        {
            var facilityId = _facilityTypes[(int)category];
            if (facilityId == TechObjectDesign.InvalidDesignID)
                return null;
            return GameContext.Current.TechDatabase.ProductionFacilityDesigns[facilityId];
        }

        /// <summary>
        /// Sets the production facility design for the specified category.
        /// </summary>
        /// <param name="category">The production category.</param>
        /// <param name="design">The design.</param>
        public void SetFacilityType(ProductionCategory category, ProductionFacilityDesign design)
        {
            if (design == null)
            {
                _facilityTypes[(int)category] = TechObjectDesign.InvalidDesignID;
                return;
            }
            
            if (design.Category != category)
                throw new ArgumentException("Production category mismatch");

            _facilityTypes[(int)category] = design.DesignID;
        }

        /// <summary>
        /// Activates a production facility in the specified category.
        /// </summary>
        /// <param name="category">The production category.</param>
        /// <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        public bool ActivateFacility(ProductionCategory category)
        {
            lock (_activeFacilities)
            {
                if (_activeFacilities[(int)category].Value >= _totalFacilities[(int)category].Value)
                    return false;
                var facilityType = GetFacilityType(category);
                if (facilityType == null)
                    return false;
                if (facilityType.LaborCost > GetAvailableLabor())
                    return false;
                _activeFacilities[(int)category].Value++;
            }
            switch (category)
            {
                case ProductionCategory.Food:
                    OnPropertyChanged("NetFood");
                    break;
                case ProductionCategory.Industry:
                    OnPropertyChanged("NetIndustry");
                    break;
                case ProductionCategory.Energy:
                    OnPropertyChanged("NetEnergy");
                    break;
                case ProductionCategory.Research:
                    OnPropertyChanged("NetResearch");
                    break;
                case ProductionCategory.Intelligence:
                    OnPropertyChanged("NetIntelligence");
                    break;
            }
            this.InvalidateBuildTimes();
            if (Shipyard != null)
                Shipyard.InvalidateBuildTimes();
            return true;
        }

        /// <summary>
        /// Deactivates a production facility in the specified category.
        /// </summary>
        /// <param name="category">The production category.</param>
        /// <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        public bool DeactivateFacility(ProductionCategory category)
        {
            lock (_activeFacilities)
            {
                if (_activeFacilities[(int)category].Value < 1)
                    return false;
                _activeFacilities[(int)category].Value--;
            }
            switch (category)
            {
                case ProductionCategory.Food:
                    OnPropertyChanged("NetFood");
                    break;
                case ProductionCategory.Industry:
                    OnPropertyChanged("NetIndustry");
                    break;
                case ProductionCategory.Energy:
                    OnPropertyChanged("NetEnergy");
                    break;
                case ProductionCategory.Research:
                    OnPropertyChanged("NetResearch");
                    break;
                case ProductionCategory.Intelligence:
                    OnPropertyChanged("NetIntelligence");
                    break;
            }
            this.InvalidateBuildTimes();
            if (Shipyard != null)
                Shipyard.InvalidateBuildTimes();
            return true;
        }

        /// <summary>
        /// Gets the amount of the population that is available for labor.
        /// </summary>
        /// <returns>The amount of the population that is available for labor.</returns>
        public int GetAvailableLabor()
        {
            int laborUsed = 0;
            for (int i = 0; i < _activeFacilities.Length; i++)
            {
                var facilityType = GetFacilityType((ProductionCategory)i);
                if (facilityType != null)
                    laborUsed += (_activeFacilities[i].Value * facilityType.LaborCost);
            }
            return (Population.CurrentValue - laborUsed);
        }

        /// <summary>
        /// Determines whether a <see cref="Building"/> of the specified design exists at this <see cref="Colony"/>.
        /// </summary>
        /// <param name="design">The building design.</param>
        /// <returns><c>true</c> if a building of the specified design exists; otherwise, <c>false</c>.</returns>
        internal bool HasBuilding(BuildingDesign design)
        {
            return HasBuilding(design, false);
        }

        /// <summary>
        /// Determines whether a <see cref="Shipyard"/> of the specified design exists at this <see cref="Colony"/>.
        /// </summary>
        /// <param name="design">The shipyard design.</param>
        /// <returns><c>true</c> if a shipyard of the specified design exists; otherwise, <c>false</c>.</returns>
        internal bool HasShipyard(ShipyardDesign design)
        {
            var shipyard = Shipyard;

            return shipyard != null &&
                   shipyard.ShipyardDesign == design;
        }

        /// <summary>
        /// Determines whether a <see cref="Building"/> of the specified design exists at this <see cref="Colony"/>.
        /// </summary>
        /// <param name="design">The building design.</param>
        /// <param name="isActive">Whether or not the building must be powered.</param>
        /// <returns><c>true</c> if a building of the specified design exists; otherwise, <c>false</c>.</returns>
        internal bool HasBuilding(BuildingDesign design, bool isActive)
        {
            return Buildings.Any(building => (building.Design == design) && (!isActive || building.IsActive));
        }

        /// <summary>
        /// Gets the current energy consumption at this <see cref="Colony"/>.
        /// </summary>
        /// <returns>The current energy consumption.</returns>
        internal int GetEnergyUsage()
        {
            return Buildings.Where(building => building.IsActive).Sum(building => ((BuildingDesign)building.Design).EnergyCost);
        }

        /// <summary>
        /// Ensures that enough energy is available for all active buildings.  If insufficient
        /// energy is available, then buildings will be shut down systematically until the
        /// situation is resolved.
        /// </summary>
        /// <returns>The number of buildings that were shut down.</returns>
        public int EnsureEnergyForBuildings()
        {
            var shutDown = 0;
            var shipyard = Shipyard;

            while (true)
            {
                var netEnergy = NetEnergy;
                if (netEnergy >= 0)
                    break;

                /*
                 * First try to shut down any unutilized shipyard build slots.  Those can be considered
                 * less critical than active buildings.
                 */
                if (shipyard != null)
                {
                    var deactivatedBuildSlot = shipyard.BuildSlots
                        .Where(o => o.IsActive && !o.HasProject)
                        .Where(DeactivateShipyardBuildSlot)
                        .FirstOrDefault();

                    if (deactivatedBuildSlot != null)
                    {
                        ++shutDown;
                        goto Next;
                    }
                }

                /*
                 * Next, try to shut down some buildings.  First check to see if we can get away with shutting
                 * down just one building.  If not, start with the most expensive active building in hopes of
                 * minimizing the number we have to shut down.
                 */
                var mostCostlyBuilding = Buildings
                    .Where(o => o.IsActive && !o.BuildingDesign.AlwaysOnline)
                    .OrderBy(o => o.BuildingDesign.EnergyCost)
                    .FirstOrDefault(o => o.BuildingDesign.EnergyCost >= -netEnergy);

                if (mostCostlyBuilding == null)
                {
                    mostCostlyBuilding = Buildings
                        .Where(o => o.IsActive && !o.BuildingDesign.AlwaysOnline)
                        .OrderByDescending(o => o.BuildingDesign.EnergyCost)
                        .FirstOrDefault();
                }

                if (mostCostlyBuilding != null &&
                    DeactivateBuilding(mostCostlyBuilding))
                {
                    shutDown++;
                    goto Next;
                }

                foreach (var building in Buildings.Where(o => o.IsActive && !o.BuildingDesign.AlwaysOnline).OrderByDescending(o => o.BuildingDesign.EnergyCost))
                {
                    if (DeactivateBuilding(building))
                    {
                        shutDown++;
                        goto Next;
                    }
                }

                /*
                 * Lastly, try to shut down some shipyard build slots.  To be fair to the player, we'll favor
                 * shutting down build slots with the least build progress.
                 */
                if (shipyard != null)
                {
                    var deactivatedBuildSlot = shipyard.BuildSlots
                        .Where(o => o.IsActive && !o.HasProject)
                        .Where(DeactivateShipyardBuildSlot)
                        .FirstOrDefault();

                    if (deactivatedBuildSlot != null)
                    {
                        ++shutDown;
                        goto Next;
                    }
                }
                break;
            Next:
                continue;
            }
            
            return shutDown;
        }

        // FOOD
        public int ActiveFoodFacilities
        {
            get { try { return GetActiveFacilities(ProductionCategory.Food); } catch { return 0; } }
        }

        public int TotalFoodFacilities
        {
            get { try { return GetTotalFacilities(ProductionCategory.Food); } catch { return 0; } }
        }
        // Industry
        public int ActiveIndustryFacilities
        {
            get { try { return GetActiveFacilities(ProductionCategory.Industry); } catch { return 0; } }
        }

        public int TotalIndustryFacilities
        {
            get { try { return GetTotalFacilities(ProductionCategory.Industry); } catch { return 0; } }
        }


        // Energy
        public int ActiveEnergyFacilities
        {
            get { try { return GetActiveFacilities(ProductionCategory.Energy); } catch { return 0; } }
        }

        public int TotalEnergyFacilities
        {
            get { try { return GetTotalFacilities(ProductionCategory.Energy); } catch { return 0; } }
        }
        // Research
        public int ActiveResearchFacilities
        {
            get { try { return GetActiveFacilities(ProductionCategory.Research); } catch { return 0; } }
        }

        public int TotalResearchFacilities
        {
            get { try { return GetTotalFacilities(ProductionCategory.Research); } catch { return 0; } }
        }
        // Intelligence 
        public int ActiveIntelligenceFacilities
        {
            get { try { return GetActiveFacilities(ProductionCategory.Intelligence); } catch { return 0; } }
        }

        public int TotalIntelligenceFacilities
        {
            get { try { return GetTotalFacilities(ProductionCategory.Intelligence); } catch { return 0; } }
        }

        public int EnergyCostEachOrbitalBattery
        {
            get { try 
                { 
                    if (OrbitalBatteryDesign != null)
                    return OrbitalBatteryDesign.UnitEnergyCost;

                    return 0;
                } catch { return 0; } }
        }
        /// <summary>
        /// //////////
        /// </summary>

        public int ActiveOrbitalBatteries
        {
            get { return _activeOrbitalBatteries.Value; }
        }

        public int TotalOrbitalBatteries
        {
            get { return _totalOrbitalBatteries.Value; }
        }

        public int ScrappedOrbitalBatteries
        {
            get { return _scrappedOrbitalBatteries.Value; }
        }

        public bool ActivateOrbitalBattery()
        {
            var design = OrbitalBatteryDesign;
            if (design == null)
                return false;

            lock (_activeOrbitalBatteries)
            {
                if (_activeOrbitalBatteries.Value >= _totalOrbitalBatteries.Value)
                    return false;

                if (design.UnitEnergyCost > 0)
                {
                    var netEnergy = NetEnergy;
                    if (netEnergy - design.UnitEnergyCost < 0)
                        return false;
                }

                ++_activeOrbitalBatteries.Value;

                var strongestBattery = OrbitalHelper.FindStrongestOrbitalBattery(_orbitalBatteries, o => !o.IsActive);
                if (strongestBattery != null)
                    strongestBattery.IsActive = true;
            }

            if (design.UnitEnergyCost > 0)
                OnPropertyChanged("NetEnergy");

            OnPropertyChanged("ActiveOrbitalBatteries");

            return true;
        }

        public bool DeactivateOrbitalBattery()
        {
            var design = OrbitalBatteryDesign;
            if (design == null)
                return false;

            lock (_activeOrbitalBatteries)
            {
                if (_activeOrbitalBatteries.Value <= 0)
                    return false;

                --_activeOrbitalBatteries.Value;

                var weakestBattery = OrbitalHelper.FindWeakestOrbitalBattery(_orbitalBatteries, o => o.IsActive);
                if (weakestBattery != null)
                    weakestBattery.IsActive = false;
            }

            if (design.UnitEnergyCost > 0)
                OnPropertyChanged("NetEnergy");

            OnPropertyChanged("ActiveOrbitalBatteries");

            return true;
        }

        public void SetScrappedOrbitalBatteries(int count)
        {
            if (count < 0)
                count = 0;
            else if (count > _totalOrbitalBatteries.Value)
                count = _totalOrbitalBatteries.Value;
            _scrappedOrbitalBatteries.Value = (byte)count;
        }

        public void RemoveOrbitalBatteries(int count)
        {
            if (count > TotalOrbitalBatteries)
                count = TotalOrbitalBatteries;

            var toDeactivate = -(_totalOrbitalBatteries.Value - _activeOrbitalBatteries.Value - count);

            for (var i = 0; i < toDeactivate; i++)
                DeactivateOrbitalBattery();

            _totalOrbitalBatteries.Value = (byte)(_totalOrbitalBatteries.Value - count);

            for (var i = 0; i < count; i++)
            {
                var weakestBattery = OrbitalHelper.FindWeakestOrbitalBattery(_orbitalBatteries);
                if (weakestBattery == null)
                    break;

                _orbitalBatteries.Remove(weakestBattery);

                GameContext.Current.Universe.Destroy(weakestBattery);
            }

            OnPropertyChanged("TotalOrbitalBatteries");
        }

        internal void OnOrbitalBatteryDestroyed(OrbitalBattery battery)
        {
            if (battery == null)
                return;

            if (!_orbitalBatteries.Contains(battery))
                return;

            if (battery.IsActive)
            {
                var strongestBattery = OrbitalHelper.FindStrongestOrbitalBattery(_orbitalBatteries, o => !o.IsActive);
                if (strongestBattery != null)
                    strongestBattery.IsActive = true;
                else
                    --_activeOrbitalBatteries.Value;
            }

            --_totalOrbitalBatteries.Value;
            _orbitalBatteries.Remove(battery);

            OnPropertyChanged("TotalOrbitalBatteries");
        }

        public void AddOrbitalBatteries(int count)
        {
            if (OrbitalBatteryDesign == null)
                throw new InvalidOperationException("Cannot add orbital batteries without first setting OrbitalBatteryDesign.");

            _totalOrbitalBatteries.Value = (byte)(_totalOrbitalBatteries.Value + count);

            for (var i = 0; i < count; i++)
            {
                var battery = new OrbitalBattery(OrbitalBatteryDesign)
                              {
                                  OwnerID = OwnerID,
                                  Location = Location
                              };

                GameContext.Current.Universe.Objects.Add(battery);

                _orbitalBatteries.Add(battery);
            }

            OnPropertyChanged("TotalOrbitalBatteries");
        }

        /// <summary>
        /// Deactivates the specified building.
        /// </summary>
        /// <param name="building">The building to deactivate.</param>
        public bool DeactivateBuilding(Building building)
        {
            return SetBuildingActive(building, false);
        }

        /// <summary>
        /// Activates the specified building.
        /// </summary>
        /// <param name="building">The building to activate.</param>
        /// <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        public bool ActivateBuilding(Building building)
        {
            return SetBuildingActive(building, true);
        }

        public bool ActivateShipyardBuildSlot(ShipyardBuildSlot buildSlot)
        {
            if (buildSlot == null)
                return false;

            var shipyard = Shipyard;
            if (shipyard == null || !Equals(shipyard, buildSlot.Shipyard))
                return false;

            if (buildSlot.IsActive)
                return true;

            if (shipyard.ShipyardDesign.BuildSlotEnergyCost > NetEnergy)
                return false;

            buildSlot.IsActive = true;
            
            OnPropertyChanged("NetEnergy");

            return true;
        }

        public bool DeactivateShipyardBuildSlot(ShipyardBuildSlot buildSlot)
        {
            if (buildSlot == null)
                return false;

            var shipyard = Shipyard;
            if (shipyard == null || !Equals(shipyard, buildSlot.Shipyard))
                return false;

            if (!buildSlot.IsActive)
                return true;

            buildSlot.IsActive = false;

            OnPropertyChanged("NetEnergy");

            return true;
        }

        private bool SetBuildingActive(Building building, bool value)
        {
            if (building == null)
                return false;
            if (building.IsActive == value)
                return true;
            if (value && building.BuildingDesign.AlwaysOnline)
                return false;
            if (!Buildings.Contains(building))
                return false;

            bool result = true;
            var propertyChanges = new HashSet<string>();
            var energyCost = building.BuildingDesign.EnergyCost;

            if (value && energyCost > 0)
                result = (energyCost <= NetEnergy);

            if (result)
            {
                building.IsActive = value;
                propertyChanges.Add("NetEnergy");
                foreach (var bonus in building.BuildingDesign.Bonuses)
                {
                    if (BonusHelper.IsGlobalBonus(bonus.BonusType))
                    {
                        var civManager = GameContext.Current.CivilizationManagers[OwnerID];
                        if (value)
                            civManager.GlobalBonuses.Add(bonus);
                        else
                            civManager.GlobalBonuses.Remove(bonus);
                        civManager.Research.RefreshBonuses();
                    }
                    else
                    {
                        switch (bonus.BonusType)
                        {
                            case BonusType.Credits:
                            case BonusType.PercentCredits:
                            case BonusType.PercentTotalCredits:
                                propertyChanges.Add("Credits");
                                break;
                            case BonusType.PercentTradeIncome:
                                propertyChanges.Add("Credits");
                                foreach (var tradeRoute in _tradeRoutes)
                                    tradeRoute.NotifyLocalPlayerCreditsChanged();
                                break;
                            case BonusType.Food:
                            case BonusType.PercentFood:
                                propertyChanges.Add("NetFood");
                                break;
                            case BonusType.Industry:
                            case BonusType.PercentIndustry:
                                propertyChanges.Add("NetIndustry");
                                this.InvalidateBuildTimes();
                                if (Shipyard != null)
                                    Shipyard.InvalidateBuildTimes();
                                break;
                            case BonusType.Energy:
                            case BonusType.PercentEnergy:
                                propertyChanges.Add("NetEnergy");
                                break;
                            case BonusType.Research:
                                propertyChanges.Add("NetResearch");
                                break;
                            case BonusType.Intelligence:
                                propertyChanges.Add("NetIntelligence");
                                break;
                            case BonusType.Dilithium:
                                propertyChanges.Add("NetDilithium");
                                break;
                            case BonusType.Deuterium:
                            case BonusType.PercentDeuterium:
                                propertyChanges.Add("NetDeuterium");
                                break;
                            case BonusType.RawMaterials:
                            case BonusType.PercentRawMaterials:
                                propertyChanges.Add("NetRawMaterials");
                                break;
                            case BonusType.GrowthRate:
                            case BonusType.PercentGrowthRate:
                                propertyChanges.Add("GrowthRate");
                                break;
                            case BonusType.ShieldPerEnergyTech:
                            case BonusType.PlanetaryShielding:
                            case BonusType.PercentPlanetaryShielding:
                                RefreshShielding(regenerate: false);
                                break;
                        }
                    }
                }
                foreach (var propertyChange in propertyChanges)
                {
                    OnPropertyChanged(propertyChange);
                }
            }

            return result;
        }

        public void RefreshShielding(bool regenerate)
        {
            var civManager = CivilizationManager.For(OwnerID);
            var energyTechLevel = civManager.Research.GetTechLevel(TechCategory.Energy);

            var maxShielding = 0;
            var replenishRate = 0;

            foreach (var building in _buildings.Where(o => o.IsActive))
            {
                var shielding = building.BuildingDesign.GetBonuses(BonusType.PlanetaryShielding).Sum(o => o.Amount) +
                                building.BuildingDesign.GetBonuses(BonusType.ShieldPerEnergyTech).Sum(o => o.Amount) * energyTechLevel;

                if (shielding == 0)
                    continue;

                maxShielding += shielding;

                var energyCost = building.BuildingDesign.EnergyCost * energyTechLevel;
                if (energyCost == 0)
                    replenishRate += shielding;
                else
                    replenishRate += Math.Min(energyCost, shielding);
            }

            var baseShielding = maxShielding;

            foreach (var building in _buildings.Where(o => o.IsActive))
            {
                var percentBonus = 0.01 * building.BuildingDesign.GetBonuses(BonusType.PercentPlanetaryShielding).Sum(o => o.Amount);

                var shielding = (int)(baseShielding * percentBonus);
                if (shielding == 0)
                    continue;

                maxShielding += shielding;
            }

            _shieldStrength.Maximum = maxShielding;

            if (!regenerate)
                return;

            _shieldStrength.AdjustCurrent(replenishRate);
            _shieldStrength.Clamp();
            _shieldStrength.UpdateAndReset();
        }

        /// <summary>
        /// Determines whether a building of the specified design is under construction.
        /// </summary>
        /// <param name="design">The building design.</param>
        /// <returns>
        /// <c>true</c> if a building of the specified design is under construction; otherwise, <c>false</c>.
        /// </returns>
        internal bool IsBuilding(TechObjectDesign design)
        {
            return BuildSlots.Any(t => t.Project != null && t.Project.BuildDesign == design) ||
                   BuildQueue.Any(item => item.Project.BuildDesign == design);
                   //||
                   //BuildSlotQueue.Any(item => item.Project.BuildDesign == design);
        }

        /// <summary>
        /// Compacts this <see cref="Colony"/> to reduce the serialization footprint.
        /// </summary>
        public override void Compact()
        {
            base.Compact();
            _tradeRoutes.TrimExcess();
        }

        public override void SerializeOwnedData(SerializationWriter writer, object context)
        {
            base.SerializeOwnedData(writer, context);
            writer.WriteOptimized(_systemId);
            writer.WriteOptimized(_originalOwnerId);
            writer.WriteOptimized(_inhabitantId);
            writer.Write(_shipyardId);
            _health.SerializeOwnedData(writer, context);
            _population.SerializeOwnedData(writer, context);
            _shieldStrength.SerializeOwnedData(writer, context);
            _morale.SerializeOwnedData(writer, context);
            _foodReserves.SerializeOwnedData(writer, context);
            writer.Write(_baseRawMaterials);
            writer.Write(_baseDeuteriumGeneration);
            writer.Write(_isProductionAutomated);
            writer.WriteOptimized(TradeRoutes.ToArray());
            writer.WriteBytesDirect(_scrappedFacilities.Select(o => (byte)o.Value).ToArray());
            writer.WriteBytesDirect(_activeFacilities.Select(o => (byte)o.Value).ToArray());
            writer.WriteBytesDirect(_totalFacilities.Select(o => (byte)o.Value).ToArray());
            writer.WriteOptimized(_facilityTypes);
            _creditsFromTrade.SerializeOwnedData(writer, context);
            _buildSlot.SerializeOwnedData(writer, context);
            writer.WriteOptimized(_buildQueue.ToArray());
            //writer.WriteOptimized(_buildSlotQueue.ToArray());

            writer.Write(_orbitalBatteryDesign);
            writer.Write((byte)_activeOrbitalBatteries.Value);
            writer.Write((byte)_totalOrbitalBatteries.Value);
            writer.Write((byte)_scrappedOrbitalBatteries.Value);
        }

        [Serializable]
        private sealed class ObservableValueProvider<T> : IValueProvider<T>, INotifyPropertyChanged
        {
            object IValueProvider.Value
            {
                get { return Value; }
                set { Value = (T)value; }
            }

            #region Value Property
            private T _value;

            public T Value
            {
                get { return _value; }
                set
                {
                    _value = value;
                    OnPropertyChanged("Value");
                }
            }
            #endregion

            public bool IsReadOnly
            {
                get { return false; }
            }

            #region Implementation of INotifyPropertyChanged
            [field: NonSerialized]
            public event PropertyChangedEventHandler PropertyChanged;

            private void OnPropertyChanged(string propertyName)
            {
                var handler = PropertyChanged;
                if (handler != null)
                    handler(this, new PropertyChangedEventArgs(propertyName));
            }
            #endregion
        }

        private void EnsureValueProviders()
        {
            var categories = EnumUtilities.GetValues<ProductionCategory>();
            var categoryCount = categories.Count;

            _activeFacilities = new IValueProvider<int>[categoryCount];
            _totalFacilities = new IValueProvider<int>[categoryCount];
            _scrappedFacilities = new IValueProvider<int>[categoryCount];

            for (var i = 0; i < categoryCount; i++)
            {
                _activeFacilities[i] = new ObservableValueProvider<int>();
                _totalFacilities[i] = new ObservableValueProvider<int>();
                _scrappedFacilities[i] = new ObservableValueProvider<int>();
            }

            _activeOrbitalBatteries = new ObservableValueProvider<int>();
            _totalOrbitalBatteries = new ObservableValueProvider<int>();
            _scrappedOrbitalBatteries = new ObservableValueProvider<int>();

            _activeFacilitiesProvider = new ColonyFacilitiesAccessor(_activeFacilities);
            _scrappedFacilitiesProvider = new ColonyFacilitiesAccessor(_scrappedFacilities);
            _totalFacilitiesProvider = new ColonyFacilitiesAccessor(_totalFacilities);

            _activeFoodFacilities = new ObservableValueProvider<int>();
            _totalFoodFacilities = new ObservableValueProvider<int>();

            _activeIndustryFacilities = new ObservableValueProvider<int>();
            _totalIndustryFacilities = new ObservableValueProvider<int>();

            _activeEnergyFacilities = new ObservableValueProvider<int>();
            _totalEnergyFacilities = new ObservableValueProvider<int>();

            _activeResearchFacilities = new ObservableValueProvider<int>();
            _totalResearchFacilities = new ObservableValueProvider<int>();

            _activeIntelligenceFacilities = new ObservableValueProvider<int>();
            _totalIntelligenceFacilities = new ObservableValueProvider<int>();
        }

        public override void DeserializeOwnedData(SerializationReader reader, object context)
        {
            base.DeserializeOwnedData(reader, context);

            Initialize();

            _systemId = reader.ReadOptimizedInt32();
            _originalOwnerId = reader.ReadOptimizedInt16();
            _inhabitantId = reader.ReadOptimizedString();
            _shipyardId = reader.ReadInt32();
            _health.DeserializeOwnedData(reader, context);
            _population.DeserializeOwnedData(reader, context);
            _shieldStrength.DeserializeOwnedData(reader, context);
            _morale.DeserializeOwnedData(reader, context);
            _foodReserves.DeserializeOwnedData(reader, context);
            _baseRawMaterials = reader.ReadByte();
            _baseDeuteriumGeneration = reader.ReadByte();
            _isProductionAutomated = reader.ReadBoolean();
            _tradeRoutes.AddRange((TradeRoute[])reader.ReadOptimizedObjectArray(typeof(TradeRoute)));
            reader.ReadBytesDirect(_scrappedFacilities.Length).ForEach((o, i) => _scrappedFacilities[i].Value = o);
            reader.ReadBytesDirect(_activeFacilities.Length).ForEach((o, i) => _activeFacilities[i].Value = o);
            reader.ReadBytesDirect(_totalFacilities.Length).ForEach((o, i) => _totalFacilities[i].Value = o);
            reader.ReadOptimizedInt32Array().CopyTo(_facilityTypes, 0);
            _creditsFromTrade.DeserializeOwnedData(reader, context);
            _buildSlot.DeserializeOwnedData(reader, context);
            _buildQueue.AddRange((BuildQueueItem[])reader.ReadOptimizedObjectArray(typeof(BuildQueueItem)));
            //_buildSlotQueue.AddRange((BuildQueueItem[])reader.ReadOptimizedObjectArray(typeof(BuildQueueItem)));
            _orbitalBatteryDesign = reader.ReadInt32();
            _activeOrbitalBatteries.Value = reader.ReadByte();
            _totalOrbitalBatteries.Value = reader.ReadByte();
            _scrappedOrbitalBatteries.Value = reader.ReadByte();
        }

        protected internal override void OnDeserialized()
        {
            _orbitalBatteries.Clear();
            _orbitalBatteries.AddRange(GameContext.Current.Universe.FindAt<OrbitalBattery>(Location));
        }

        public override void CloneFrom(Cloneable source, ICloneContext context)
        {
            var typedSource = (Colony)source;

            base.CloneFrom(source, context);

            EnsureValueProviders();

            _systemId = typedSource._systemId;

            _shipyardId = typedSource._shipyardId;
            OnPropertyChanged("Shipyard");

            _originalOwnerId = typedSource._originalOwnerId;
            OnPropertyChanged("OriginalOwner");

            _inhabitantId = typedSource._inhabitantId;

            _health = typedSource._health;
            OnPropertyChanged("Health");

            _isProductionAutomated = typedSource._isProductionAutomated;
            OnPropertyChanged("IsProductionAutomated");

            typedSource._activeFacilities.ForEach((v, i) => _activeFacilities[i].Value = v.Value);
            typedSource._totalFacilities.ForEach((v, i) => _totalFacilities[i].Value = v.Value);
            typedSource._scrappedFacilities.ForEach((v, i) => _scrappedFacilities[i].Value = v.Value);

            _activeOrbitalBatteries.Value = typedSource._activeOrbitalBatteries.Value;
            _totalOrbitalBatteries.Value = typedSource._totalOrbitalBatteries.Value;
            _scrappedOrbitalBatteries.Value = typedSource._scrappedOrbitalBatteries.Value;

            typedSource._facilityTypes.ForEach((v, i) => _facilityTypes[i] = v);

            _orbitalBatteryDesign = typedSource._orbitalBatteryDesign;

            _population.CloneFrom(typedSource._population, context);
            _shieldStrength.CloneFrom(typedSource._shieldStrength, context);
            _morale.CloneFrom(typedSource._morale, context);
            _foodReserves.CloneFrom(typedSource._foodReserves, context);
            _creditsFromTrade.CloneFrom(typedSource._creditsFromTrade, context);

            _tradeRoutes.Clear();
            _tradeRoutes.AddRange(typedSource._tradeRoutes.Select(o => o.Clone()));

            CloneBuildings(typedSource._buildings, context);

            _buildSlot = typedSource._buildSlot; // TODO: clone build slot
            OnPropertyChanged("BuildSlot");

            _buildQueue = typedSource._buildQueue; // TODO: clone build queue
            OnPropertyChanged("BuildQueue");

            //_buildSlotQueue = typedSource._buildSlotQueue; // TODO: clone build queue
            //OnPropertyChanged("BuildSlotQueue");

            _baseRawMaterials = typedSource._baseRawMaterials;
            _baseDeuteriumGeneration = typedSource._baseDeuteriumGeneration;
        }

        private void CloneBuildings([NotNull] IKeyedCollection<int, Building> sourceBuildings, ICloneContext context)
        {
            if (sourceBuildings == null)
                throw new ArgumentNullException("sourceBuildings");

            /*
             * Remove buildings that are not at the source.
             */
            var removedKeys = _buildings.Keys.ToHashSet();
            removedKeys.ExceptWith(sourceBuildings.Keys);
            _buildings.RemoveRange(removedKeys);

            /*
             * Add or update buildings from the source.
             */
            foreach (var sourceBuilding in sourceBuildings)
            {
                Building cloneTarget;

                if (context.TryRemap(sourceBuilding, out cloneTarget))
                    _buildings.Replace(sourceBuilding.ObjectID, cloneTarget);

                if (_buildings.TryGetValue(sourceBuilding.ObjectID, out cloneTarget))
                    cloneTarget.CloneFrom(sourceBuilding, context);
                else
                    _buildings.Add(context.CloneAnMap(sourceBuilding));
            }
        }

        protected override Cloneable CreateInstance(ICloneContext context)
        {
            return new Colony();
        }
    }

    public interface IContactCenter { }

    [Serializable]
    public sealed class ColonyFacilitiesAccessor
    {
        private readonly IValueProvider<int>[] _array;

        public ColonyFacilitiesAccessor([NotNull] IValueProvider<int>[] array)
        {
            if (array == null)
                throw new ArgumentNullException("array");
            _array = array;
        }

        public IValueProvider<int> this[ProductionCategory category]
        {
            get { return _array[(int)category]; }
        }
    }

}