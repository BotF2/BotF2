// IntelPool.cs
//
// Copyright (c) 2007 Mike Strobel
//
// This source code is subject to the terms of the Microsoft Reciprocal License (Ms-RL).
// For details, see <http://www.opensource.org/licenses/ms-rl.html>.
//
// All other rights reserved.

using Supremacy.Annotations;
using Supremacy.Collections;
using Supremacy.Entities;
using Supremacy.Game;
using Supremacy.IO.Serialization;
using Supremacy.Types;
using Supremacy.Utility;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Runtime.Serialization;

namespace Supremacy.Economy
{
    /// <summary>
    /// Represents a intel project being undertaken by a civilization in the game.
    /// </summary>
    [Serializable]
    public class IntelProject
    {
        private readonly int _applicationId;
        private readonly Meter _progress;

        /// <summary>
        /// Gets the progress of a <see cref="IntelProject"/>.
        /// </summary>
        /// <value>The progress.</value>
        public Meter Progress
        {
            get { return _progress; }
        }

        /// <summary>
        /// Gets a value indicating whether this <see cref="IntelProject"/> is finished.
        /// </summary>
        /// <value>
        /// <c>true</c> if this <see cref="IntelProject"/> is finished; otherwise, <c>false</c>.
        /// </value>
        public bool IsFinished
        {
            get { return _progress.IsMaximized; }
        }

        /// <summary>
        /// Gets the application being inteled in this <see cref="IntelProject"/>.
        /// </summary>
        /// <value>The application.</value>
        public IntelApplication Application
        {
            get { return GameContext.Current.IntelMatrix.GetApplication(_applicationId); }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IntelProject"/> class.
        /// </summary>
        /// <param name="application">The application.</param>
        public IntelProject(IntelApplication application)
        {
            if (application == null)
                throw new ArgumentNullException("application");
            _applicationId = application.ApplicationID;
            _progress = new Meter(0, 0, application.InitialIntelValue);
        }
    }

    /// <summary>
    /// Represents a civilization's intel pool.
    /// </summary>
    [Serializable]
    public class IntelPool : INotifyPropertyChanged
    {
        private readonly int _ownerId;
        private readonly int[] _intelLevels;
        private readonly DistributionGroup<int> _distributions;
        private readonly IntelPoolValueCollection _values;
        private readonly IntelBonusCollection _bonuses;
        private readonly List<IntelProject>[] _queue;
        private readonly Meter _cumulativePoints;

        /// <summary>
        /// Gets the owner of this <see cref="IntelPool"/>.
        /// </summary>
        /// <value>The owner.</value>
        public Civilization Owner
        {
            get { return GameContext.Current.Civilizations[_ownerId]; }
        }

        /// <summary>
        /// Gets the cumulative number of intel points generated by the owner.
        /// </summary>
        /// <value>The number cumulative intel points generated.</value>
        public Meter CumulativePoints
        {
            get { return _cumulativePoints; }
        }

        /// <summary>
        /// Gets the distribution of intel points between the various fields.
        /// </summary>
        /// <value>The distribution of points between fields.</value>
        public DistributionGroup<int> Distributions
        {
            get { return _distributions; }
        }

        /// <summary>
        /// Gets the intel points being allocated to each field for the current turn
        /// </summary>
        /// <value>The current intel point allocations.</value>
        public IntelPoolValueCollection Values
        {
            get { return _values; }
        }

        /// <summary>
        /// Gets the current bonuses available for each intel category.
        /// </summary>
        /// <value>The bonuses for each category.</value>
        public IntelBonusCollection Bonuses
        {
            get { return _bonuses; }
        }

        /// <summary>
        /// Determines whether the specified application has been inteled.
        /// </summary>
        /// <param name="application">The application.</param>
        /// <returns>
        /// <c>true</c> if the specified application has been inteled; otherwise, <c>false</c>.
        /// </returns>
        public bool IsInteled(IntelApplication application)
        {
            foreach (IntelField field in GameContext.Current.IntelMatrix.Fields)
            {
                if (field.Applications.Contains(application))
                {
                    foreach (IntelProject project in _queue[field.FieldID])
                    {
                        if (project.Application == application)
                            return false;
                    }
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Determines whether the specified application is currently being inteled.
        /// </summary>
        /// <param name="application">The application.</param>
        /// <returns>
        /// <c>true</c> if the application is being inteled; otherwise, <c>false</c>.
        /// </returns>
        public bool IsInteling(IntelApplication application)
        {
            foreach (IntelField field in GameContext.Current.IntelMatrix.Fields)
            {
                if (field.Applications.Contains(application))
                {
                    IntelProject project = GetCurrentProject(field);
                    return ((project != null) && (project.Application == application));
                }
            }
            return false;
        }

        /// <summary>
        /// Gets the current intel level of the specified field.
        /// </summary>
        /// <param name="field">The field.</param>
        /// <returns>The intel level.</returns>
        public int GetIntelLevel(IntelField field)
        {
            if (field == null)
                throw new ArgumentNullException("field");
            return GetIntelLevel(field.FieldID);
        }

        /// <summary>
        /// Gets the current intel level of the specified intel category.
        /// </summary>
        /// <param name="category">The intel category.</param>
        /// <returns>The intel level.</returns>
        public int GetIntelLevel(IntelCategory category)
        {
            var levels = new List<int>();
            foreach (var field in GameContext.Current.IntelMatrix.Fields.Where(o => o.IntelCategory == category))
            {
                levels.Add(GetIntelLevel(field));
            }
            if (levels.Count == 0)
                return 0;
            return levels.Min();
        }

        /// <summary>
        /// Gets the current intel level of the specified field.
        /// </summary>
        /// <param name="fieldId">The field ID.</param>
        /// <returns>The intel level.</returns>
        public int GetIntelLevel(int fieldId)
        {
            return _intelLevels[fieldId];
        }


        /// <summary>
        /// Gets the next application to be inteled in the specified field.
        /// </summary>
        /// <param name="field">The field.</param>
        /// <returns>The next application.</returns>
        public IntelApplication GetNextApplication(IntelField field)
        {
            if (field == null)
                throw new ArgumentNullException("field");
            if (_queue[field.FieldID].Count == 0)
                return null;
            return _queue[field.FieldID][0].Application;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IntelPool"/> class.
        /// </summary>
        /// <param name="owner">The owner.</param>
        /// <param name="matrix">The intel matrix.</param>
        public IntelPool(Civilization owner, IntelMatrix matrix)
        {
            if (owner == null)
                throw new ArgumentNullException("owner");
            if (matrix == null)
                throw new ArgumentNullException("matrix");

            var fieldIds = new List<int>();

            _ownerId = owner.CivID;
            _values = new IntelPoolValueCollection();
            _bonuses = new IntelBonusCollection(owner);
            _intelLevels = new int[matrix.Fields.Count];
            _queue = new List<IntelProject>[matrix.Fields.Count];
            _cumulativePoints = new Meter(0, int.MaxValue);

            var startingIntelLevelsTable = GameContext.Current.Tables.GameOptionTables["StartingIntelLevels"];
            var startingIntelLevel = GameContext.Current.Options.StartingTechLevel; // taking level from TechLevel !!

            Dictionary<IntelCategory, int> initialFieldLevelValues = null;

            var ownerIsEmpire = owner.IsEmpire;
            if (ownerIsEmpire)
            {
                initialFieldLevelValues = EnumHelper.GetValues<IntelCategory>().ToDictionary(
                    intelCategory => intelCategory,
                    intelCategory =>
                    Number.ParseInt32(startingIntelLevelsTable[startingIntelLevel.ToString()][intelCategory.ToString()]));
            }

            foreach (var field in matrix.Fields)
            {
                fieldIds.Add(field.FieldID);
                _intelLevels[field.FieldID] = ownerIsEmpire ? initialFieldLevelValues[field.IntelCategory] : 1;
                _queue[field.FieldID] = new List<IntelProject>();
                foreach (var application in field.Applications)
                {
                    if (application.Level > GetIntelLevel(field))
                        _queue[field.FieldID].Add(new IntelProject(application));
                    else
                    {
                        _cumulativePoints.BaseValue += application.InitialIntelValue;

                        // Make sure the current and last values match so to not show any deltas
                        _cumulativePoints.Reset();
                        _cumulativePoints.SaveCurrentAndResetToBase();
                    }
                }
            }

            _distributions = new DistributionGroup<int>(fieldIds);
            _distributions.DistributeEvenly();
        }

        /// <summary>
        /// Gets the project currently being inteled in the specified field.
        /// </summary>
        /// <param name="field">The field.</param>
        /// <returns>The current project.</returns>
        public IntelProject GetCurrentProject(IntelField field)
        {
            if (field == null)
                throw new ArgumentNullException("field");
            return GetCurrentProject(field.FieldID);
        }

        /// <summary>
        /// Gets the project currently being inteled in the specified field.
        /// </summary>
        /// <param name="fieldId">The field ID.</param>
        /// <returns>The current project.</returns>
        public IntelProject GetCurrentProject(int fieldId)
        {
            if (_queue[fieldId].Count == 0)
                return null;
            return _queue[fieldId][0];
        }

        /// <summary>
        /// Applies the specified number of intel points to the currently active projects.
        /// </summary>
        /// <param name="intelPoints">The number of intel points.</param>
        public void UpdateIntel(int intelPoints)
        {
            if (intelPoints < 0)
                intelPoints = 0;

            _distributions.TotalValue = intelPoints;



            foreach (IntelField field in GameContext.Current.IntelMatrix.Fields)
            {
                int fieldPoints = _distributions.Values[field.FieldID];

                // works but gives no good overview yet
                //GameLog.Print("BORG only: Total IntelPoints before {4} plus current {0} - {3} to {1}, plus Bonus ({2} * {3})",
                //    intelPoints, field.IntelCategory, _bonuses[field.IntelCategory], fieldPoints, _cumulativePoints);

                fieldPoints += (int)(_bonuses[field.IntelCategory] * fieldPoints);
                _cumulativePoints.AdjustCurrent(fieldPoints);

                for (int i = 0; i < _queue[field.FieldID].Count; i++)
                {
                    if (_queue[field.FieldID][i].IsFinished)
                    {
                        FinishProject(field.FieldID, i--);
                        continue;
                    }
                    fieldPoints -= _queue[field.FieldID][i].Progress.AdjustCurrent(fieldPoints);
                    if (_queue[field.FieldID][i].IsFinished)
                    {
                        FinishProject(field.FieldID, i--);
                        continue;
                    }
                    if (fieldPoints <= 0)
                        break;
                }
            }

            _cumulativePoints.UpdateAndReset();
        }

        /// <summary>
        /// Finishes the project located at the specified index in the queue for a given field.
        /// </summary>
        /// <param name="fieldId">The field id.</param>
        /// <param name="queueIndex">The index in the queue.</param>
        private void FinishProject(int fieldId, int queueIndex)
        {
            var finishedApp = _queue[fieldId][queueIndex].Application;
            var civManager = GameContext.Current.CivilizationManagers[Owner];
            //var designsBefore = TechTreeHelper.GetDesignsForCurrentTechLevels(Owner);

            _queue[fieldId].RemoveAt(queueIndex);
            UpdateIntelLevels();

            //var designsAfter = TechTreeHelper.GetDesignsForCurrentTechLevels(Owner);
            //var newDesigns = designsAfter.Except(designsBefore).ToList();

            // ToDo: Sitrep
            //if (civManager != null)
            //    civManager.SitRepEntries.Add(new IntelCompleteSitRepEntry(Owner, finishedApp, newDesigns));
        }

        /// <summary>
        /// Updates the current intel levels based on new intel completed.
        /// </summary>
        protected void UpdateIntelLevels()
        {
            foreach (IntelField field in GameContext.Current.IntelMatrix.Fields)
            {
                int nextIntelLevel = _intelLevels[field.FieldID];

                if (GetCurrentProject(field) != null)
                    nextIntelLevel = GetCurrentProject(field).Application.Level;

                if (nextIntelLevel > _intelLevels[field.FieldID])
                    _intelLevels[field.FieldID] = nextIntelLevel - 1;
            }
        }

        internal void RefreshBonuses()
        {
            OnPropertyChanged("Bonuses");
        }

        #region INotifyPropertyChanged Members
        /// <summary>
        /// Occurs when a property value changes.
        /// </summary>
        [field: NonSerialized]
        public event PropertyChangedEventHandler PropertyChanged;

        /// <summary>
        /// Raises the <see cref="PropertyChanged"/> event.
        /// </summary>
        /// <param name="propertyName">Name of the property that changed.</param>
        protected void OnPropertyChanged(string propertyName)
        {
            if (PropertyChanged != null)
                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
        }
        #endregion
    }

    /// <summary>
    /// A collection of <see cref="Meter"/>s indexed by <see cref="IntelCategory"/>.
    /// </summary>
    [Serializable]
    public class IntelPoolValueCollection
        : Dictionary<IntelCategory, Meter>,
          IOwnedDataSerializableAndRecreatable,
          ICloneable
    {

        public IntelPoolValueCollection()
        {
            EnumHelper.GetValues<IntelCategory>().ForEach(t => this.Add(t, new Meter()));
        }

        public IntelPoolValueCollection(SerializationInfo info, StreamingContext context) : base(info, context)
        {

        }

        object ICloneable.Clone()
        {
            return Clone();
        }

        public IntelPoolValueCollection Clone()
        {
            var clone = new IntelPoolValueCollection();
            foreach (var entry in this)
            {
                clone.Add(entry.Key, entry.Value.Clone());
            }
            return clone;
        }

        public void SerializeOwnedData(SerializationWriter writer, object context)
        {
            writer.Write(this);
        }

        public void DeserializeOwnedData(SerializationReader reader, object context)
        {
            var data = reader.ReadDictionary<IntelCategory, Meter>();
            EnumHelper.GetValues<IntelCategory>().ForEach(r => this[r] = data[r].Clone());
        }
    }

    /// <summary>
    /// A collection of percentage-based intel bonuses indexed by <see cref="IntelCategory"/>
    /// and intel field ID.
    /// </summary>
    [Serializable]
    public class IntelBonusCollection
    {
        private readonly int _ownerId;

        /// <summary>
        /// Gets or sets the percentage-based bonus for the specified field.
        /// </summary>
        /// <value>The bonus.</value>
        public Percentage this[IntelCategory field]
        {
            get
            {
                var civManager = GameContext.Current.CivilizationManagers[_ownerId];
                switch (field)
                {
                    //case IntelCategory.BioTech:
                    //    return civManager.GlobalBonuses
                    //        .Where(o => ((o.BonusType == BonusType.PercentBioTechIntel) || (o.BonusType == BonusType.PercentIntelEmpireWide)))
                    //        .Sum(o => 0.01f * o.Amount);
                    //case IntelCategory.Computers:
                    //    return civManager.GlobalBonuses
                    //        .Where(o => ((o.BonusType == BonusType.PercentComputerIntel) || (o.BonusType == BonusType.PercentIntelEmpireWide)))
                    //        .Sum(o => 0.01f * o.Amount);
                    //case IntelCategory.Construction:
                    //    return civManager.GlobalBonuses
                    //        .Where(o => ((o.BonusType == BonusType.PercentConstructionIntel) || (o.BonusType == BonusType.PercentIntelEmpireWide)))
                    //        .Sum(o => 0.01f * o.Amount);
                    //case IntelCategory.Energy:
                    //    return civManager.GlobalBonuses
                    //        .Where(o => ((o.BonusType == BonusType.PercentEnergyIntel) || (o.BonusType == BonusType.PercentIntelEmpireWide)))
                    //        .Sum(o => 0.01f * o.Amount);
                    //case IntelCategory.Propulsion:
                    //    return civManager.GlobalBonuses
                    //        .Where(o => ((o.BonusType == BonusType.PercentPropulsionIntel) || (o.BonusType == BonusType.PercentIntelEmpireWide)))
                    //        .Sum(o => 0.01f * o.Amount);
                    //case IntelCategory.Weapons:
                    //    return civManager.GlobalBonuses
                    //        .Where(o => ((o.BonusType == BonusType.PercentWeaponsIntel) || (o.BonusType == BonusType.PercentIntelEmpireWide)))
                    //        .Sum(o => 0.01f * o.Amount);
                }
                return 0.0f;
            }
        }

        /// <summary>
        /// Gets or sets the percentage-based bonus for the specified field ID.
        /// </summary>
        /// <value>The bonus.</value>
        public Percentage this[int fieldId]
        {
            get
            {
                GameLog.Core.General.DebugFormat("{0} percent of whatever", this[GameContext.Current.IntelMatrix.Fields[fieldId].IntelCategory]);
                return this[GameContext.Current.IntelMatrix.Fields[fieldId].IntelCategory];
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IntelBonusCollection"/> class.
        /// </summary>
        public IntelBonusCollection([NotNull] Civilization owner)
        {
            if (owner == null)
                throw new ArgumentNullException("owner");
            // works    GameLog.Print("IntelBonusCollection Owner = {0} = {1}", owner.CivID, owner.Name);
            _ownerId = owner.CivID;
        }
    }
}

